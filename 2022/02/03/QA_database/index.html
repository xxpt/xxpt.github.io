<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试QA整理(3)——数据库 | 夏普通</title><meta name="author" content="xpt"><meta name="copyright" content="xpt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！ 文档分享的初衷是给师弟师妹们作为参考，主要是适合想去大厂+测试开发岗的朋友们。建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！文章还未精细整理，如存在错误之处，可以邮件or微信反馈给我呀，感激不尽！ 想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百">
<meta property="og:type" content="article">
<meta property="og:title" content="面试QA整理(3)——数据库">
<meta property="og:url" content="https://xpt.hatake18.top/2022/02/03/QA_database/index.html">
<meta property="og:site_name" content="夏普通">
<meta property="og:description" content="Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！ 文档分享的初衷是给师弟师妹们作为参考，主要是适合想去大厂+测试开发岗的朋友们。建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！文章还未精细整理，如存在错误之处，可以邮件or微信反馈给我呀，感激不尽！ 想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_database_cover.png">
<meta property="article:published_time" content="2022-02-03T03:30:00.000Z">
<meta property="article:modified_time" content="2022-02-09T08:07:48.391Z">
<meta property="article:author" content="xpt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_database_cover.png"><link rel="shortcut icon" href="/img/xpt.jpg"><link rel="canonical" href="https://xpt.hatake18.top/2022/02/03/QA_database/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xpt","link":"链接: ","source":"来源: 夏普通","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试QA整理(3)——数据库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-09 16:07:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script async src="/js/busuanzi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/css/function.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xpt.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_database_cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">夏普通</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试QA整理(3)——数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-03T03:30:00.000Z" title="发表于 2022-02-03 11:30:00">2022-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-09T08:07:48.391Z" title="更新于 2022-02-09 16:07:48">2022-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试QA整理(3)——数据库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/02/03/QA_database/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/02/03/QA_database/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-3-——数据库"><a href="#面试QA整理-3-——数据库" class="headerlink" title="面试QA整理(3)——数据库"></a>面试QA整理(3)——数据库</h1><h2 id="基于MySQL数据库的几种连接查询-内连接、外连接-join"><a href="#基于MySQL数据库的几种连接查询-内连接、外连接-join" class="headerlink" title="基于MySQL数据库的几种连接查询(内连接、外连接 join)"></a>基于MySQL数据库的几种连接查询(内连接、外连接 join)</h2><p>内连接、外连接（ 左(外)连接、右(外)连接、全(外)连接）。</p>
<p>内连接、左连接（左外连接）、右连接（右外连接）、全连接（全外连接）</p>
<ul>
<li><p>inner join内连接就是左右俩表的交集</p>
</li>
<li><p>左(外)连接，<strong>左表(a_table)的记录将会全部表示出来</strong>，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。（在右表 (table_name2) 中没有匹配的行，右表选择列置为null）</p>
</li>
<li><p>右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而<strong>右表(b_table)的记录将会全部表示出来</strong>。左表记录不足的地方均为NULL。</p>
</li>
<li><p>全连接，显示符合条件的数据行，同时显示左右不符合条件的数据行，相应的左右两边显示NULL，即显示左连接、右连接和内连接的<strong>并集</strong></p>
<ul>
<li>MySQL是不支持全外的连接的， full  join写法适合Oracle和DB2</li>
<li>MySQL数据库不支持全外连接查询 但是可以通过UNION来实现【左连接语句 UNION 右连接语句】</li>
</ul>
</li>
</ul>
<blockquote>
<p>from子句中on条件主要用来连接表，其他不属于连接表的条件可以使用where子句来指定； </p>
</blockquote>
<ul>
<li>cross join，交叉连接，实际上就是将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积</li>
<li>交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的 <ul>
<li>数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</li>
</ul>
</li>
</ul>
<h2 id="【索引】是帮助MySQL高效获取数据的排好序的数据结构"><a href="#【索引】是帮助MySQL高效获取数据的排好序的数据结构" class="headerlink" title="【索引】是帮助MySQL高效获取数据的排好序的数据结构"></a>【索引】是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></h2><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。<strong>索引的实现通常使用B树及其变种B+树</strong>。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>索引的优点<br>　　1.创建唯一性索引，保证数据库表中每一行数据的唯一性<br>　　2.大大加快数据的检索速度，这也是创建索引的最主要的原因<br>　　3.减少磁盘IO（向字典一样可以直接定位）<br>索引的缺点<br>      1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加<br>      2.索引需要占用额外的物理空间<br>      3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p>
<h2 id="什么情况适合-x2F-不适合建立索引"><a href="#什么情况适合-x2F-不适合建立索引" class="headerlink" title="什么情况适合&#x2F;不适合建立索引"></a>什么情况适合&#x2F;不适合建立索引</h2><p>一、哪些情况下适合建索引</p>
<ol>
<li>频繁作为where条件语句<strong>查询</strong>的字段</li>
<li>关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等</li>
<li>排序字段可以建立索引</li>
<li>分组字段可以建立索引，因为分组的前提是排序</li>
<li>统计字段可以建立索引，例如count(),max()</li>
</ol>
<p>二、哪些情况下不适合建索引<br>1.频繁<strong>更新的字段</strong>不适合建立索引<br>2.where条件中用不到的字段不适合建立索引<br>3.表数据可以确定比较少的不需要建索引<br>4.数据重复且分布比较均匀的的字段不适合建索引（<strong>唯一性太差的字段不适合建立索引</strong>），例如性别，真假值</p>
<ol start="5">
<li>参与列计算的列不适合建索引</li>
</ol>
<h2 id="☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引"><a href="#☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引" class="headerlink" title="☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引"></a>☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引</h2><p><strong>普通索引</strong>（INDEX）这是最基本的索引，它没有任何限制</p>
<p><strong>唯一索引</strong>（UNIQUE） 避免同一个表中某数据列中的值重复</p>
<ul>
<li>索引列的值必须唯一， 但允许有空值。如果是组合索引，则列值的组合必须唯一。  </li>
<li>与主键索引的区别：主键索引只能有一个，唯一索引可有多个</li>
</ul>
<p><strong>主键索引</strong>（PRIMAY KEY）特殊的唯一索引， 不允许有空值。 一个表只能有一个主键。    </p>
<p><strong>联合索引</strong></p>
<p><strong>全文索引</strong>（FULLTEXT）快速定位特定数据</p>
<ul>
<li>只能用于MyISAM类型的数据表；只能用于CHAR ,VARCHAR,TEXT数据列类型；使用大型数据集</li>
</ul>
<p><strong>聚集索引</strong>：聚集索引的顺序就是数据的物理存储顺序，<strong>聚集索引：叶节点包含了完整的数据记录</strong></p>
<p><strong>非聚集索引</strong>：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（相当于就是个二级索引啊  </p>
<p><strong>非聚集索引和聚集索引的区别</strong>在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，</p>
<h3 id="B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="B+树一个节点有多大？一千万条数据，B+树多高？"></a>B+树一个节点有多大？一千万条数据，B+树多高？</h3><ul>
<li>B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 &lt; 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。</li>
<li>在 MySQL 中 B+ 树的<strong>一个节点大小为“1页”，也就是16k</strong>。之所以设置为一页，是因为对于大部分业务，一页就足够了：</li>
<li>首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。</li>
<li><strong>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</strong></li>
<li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，<strong>一共是14字节</strong>，则16k能存放 <strong>16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针</strong>。</li>
<li>于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li>
<li>而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的。</li>
</ul>
<h2 id="☆索引数据结构（二叉树，红黑树，Hash表，B树，B-树"><a href="#☆索引数据结构（二叉树，红黑树，Hash表，B树，B-树" class="headerlink" title="☆索引数据结构（二叉树，红黑树，Hash表，B树，B+ 树"></a>☆索引数据结构（二叉树，红黑树，Hash表，B树，B+ 树</h2><p>二叉树，红黑树，Hash表，B树，B+ 树</p>
<p><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803154123502.png" alt="image-20210803154123502" style="zoom:40%;" />

<p><strong>B树</strong><br>叶节点具有相同的深度，叶节点的指针为空<br>所有索引元素不重复<br>节点中的数据索引从左到右递增排列</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803153830548.png" alt="image-20210803153830548" style="zoom:40%;" />

<p><strong>红黑树的约束:</strong></p>
<ol>
<li>节点可以是红色的或者黑色的</li>
<li><code>根节点</code>、<code>叶子节点</code>、<code>每个红色节点的子节点</code>是黑色的</li>
<li><code>任何一个节点到其每一个叶子节点</code>的所有路径上黑色节点数相同</li>
</ol>
<p><strong>红黑树的特点:</strong><br>速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 </p>
<h2 id="为什么说B-树更适合数据库索引？"><a href="#为什么说B-树更适合数据库索引？" class="headerlink" title="为什么说B+树更适合数据库索引？"></a>为什么说B+树更适合数据库索引？</h2><p><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</p>
<p>1、 <strong>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</strong></p>
<p>2、<strong>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<h2 id="为什么mongodb里用B树、mysql里面用B-树"><a href="#为什么mongodb里用B树、mysql里面用B-树" class="headerlink" title="为什么mongodb里用B树、mysql里面用B+树"></a>为什么mongodb里用B树、mysql里面用B+树</h2><p>是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。</p>
<p>而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。</p>
<ul>
<li><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</li>
</ul>
<p>(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在<strong>做单一数据查询的时候，使用B树平均性</strong>能更好。但是，由于<strong>B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作</strong>。</p>
<p>(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，<strong>查询速度非常稳定</strong>（都要查到叶子节点）。因此，<strong>在做单一数据的查询上，其平均性能并不如B树。</strong>但是，<strong>B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可</strong>，这个特性使得<strong>B+树非常适合做范围查询</strong>。</p>
<h2 id="基于B-树的索引和基于hash的索引的区别"><a href="#基于B-树的索引和基于hash的索引的区别" class="headerlink" title="基于B+树的索引和基于hash的索引的区别"></a>基于B+树的索引和基于hash的索引的区别</h2><p><strong>哈希索引就是采用一定的哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p>
<p>B+树索引和哈希索引的明显区别是：</p>
<ul>
<li><strong>如果是等值查询，那么哈希索引明显有绝对优势</strong>，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>
<li><strong>如果是范围查询检索，这时候哈希索引就毫无用武之地了</strong>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，<strong>哈希索引也没办法利用索引完成排序</strong>，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li><strong>哈希索引也不支持多列联合索引的最左匹配规则</strong>；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<strong>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</strong>。</li>
</ul>
<h2 id="【mysql引擎】MyISAM索引实现-非聚集"><a href="#【mysql引擎】MyISAM索引实现-非聚集" class="headerlink" title="【mysql引擎】MyISAM索引实现(非聚集)"></a>【mysql引擎】MyISAM索引实现(非聚集)</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803155858999.png" alt="image-20210803155858999" style="zoom:33%;" />

<p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是<strong>分离</strong>的，<strong>索引保存的是数据文件的指针</strong>。主键索引和辅助索引是独立的。</p>
<h2 id="☆【mysql引擎】InnoDB索引实现-聚集"><a href="#☆【mysql引擎】InnoDB索引实现-聚集" class="headerlink" title="☆【mysql引擎】InnoDB索引实现(聚集)"></a>☆【mysql引擎】InnoDB索引实现(聚集)</h2><p>如果想看自己的数据库默认使用的那个存储引擎，可以通过使用命令<code>SHOW VARIABLES LIKE &#39;storage_engine&#39;</code></p>
<p><strong>InnoDB引擎采用B+Tree结构来作为索引结构。</strong></p>
<p><strong>聚集索引：叶节点包含了完整的数据记录</strong></p>
<blockquote>
<p>B+Tree在B-Tree的基础上有两点变化：<br>（1）数据是存在叶子节点中的<br>（2）数据节点之间是有指针指向的</p>
</blockquote>
<p><strong>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID）</strong></p>
<p>InnoDB的存储文件有两个，后缀名分别是 .frm（表的定义文件）和 .idb（表的数据文件）；</p>
<p>InnoDB是聚集索引，使用B+Tree作为索引结构，<strong>数据文件是和（主键）索引绑在一起的</strong>（表数据文件本身就是按B+Tree组织的一个索引结构）</p>
<p>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键）</p>
<p>必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803162510756.png" alt="image-20210803162510756" style="zoom:33%;" />

<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？</h3><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值-一致性和节省存储空间"><a href="#为什么非主键索引结构叶子节点存储的是主键值-一致性和节省存储空间" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值? (一致性和节省存储空间)"></a>为什么非主键索引结构叶子节点存储的是主键值? (一致性和节省存储空间)</h3><h3 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h3><p>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</p>
<h3 id="innodb默认隔离级别：可重复读-Repeated-Read"><a href="#innodb默认隔离级别：可重复读-Repeated-Read" class="headerlink" title="innodb默认隔离级别：可重复读(Repeated Read)"></a>innodb默认隔离级别：可重复读(Repeated Read)</h3><p>InnoDB默认级别：可重复读(Repeated Read)</p>
<h2 id="MyISAM与InnoDB-的区别-amp-如何选择？"><a href="#MyISAM与InnoDB-的区别-amp-如何选择？" class="headerlink" title="MyISAM与InnoDB 的区别 &amp; 如何选择？"></a>MyISAM与InnoDB 的区别 &amp; 如何选择？</h2><ol>
<li><p>InnoDB支持事务，MyISAM不支持；</p>
<p>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。</p>
</li>
</ol>
<p>  对一个包含外键的InnoDB表转为MYISAM会失败； </p>
<ol start="3">
<li><p>InnoDB的B+树主<strong>键索引的叶子节点就是数据文件</strong>，辅助索引的叶子节点是主键的值；</p>
<p>而MyISAM的B+树主键索引和辅助索引的叶子节点都是<strong>数据文件的地址指针</strong>。</p>
</li>
<li><p><strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。</strong></p>
<p>而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；<br>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询</p>
</li>
<li><p><strong>MyISAM表格可以被压缩后进行查询操作</strong></p>
</li>
<li><p><strong>InnoDB支持表、行(默认)级锁</strong>，而MyISAM支持表级锁</p>
<p>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p>
</li>
<li><p><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</strong></p>
</li>
<li><p><strong>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI</strong><br>Innodb：frm是表定义文件，ibd是数据文件<br>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</p>
</li>
</ol>
<p>如何选择：</p>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ol>
<h2 id="☆数据库的三大范式1NF-2NF-3NF"><a href="#☆数据库的三大范式1NF-2NF-3NF" class="headerlink" title="☆数据库的三大范式1NF,2NF,3NF"></a>☆数据库的三大范式1NF,2NF,3NF</h2><p><strong>1．1NF，第一范式(确保每列保持原子性)</strong></p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</p>
<p><strong>2．2NF，第二范式(确保表中的每列都和主键相关)</strong></p>
<p>必须是满足第一范式的前提下， 第二范式要求，确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言，因为如果出现不完全依赖，只可能发生在联合主键的情况下）。</p>
<p>比如要设计一个订单表，设计五个字段“订单id”、“商品id”、“顾客id”、“商品名称”、“顾客姓名”，因为一个订单中可能会有多种商品，一个顾客可能会下多个订单，所以要将“订单id”、“商品id”、“顾客id”作为数据库表的联合主键，但是“商品名称”只和“商品id”有关系，“顾客姓名”只和“顾客id”有关系，这样就不满足第二范式。需要拆表</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210723181127392.png" alt="image-20210723181127392" style="zoom:33%;" />

<p><strong>3．3NF，第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></p>
<p>必须是满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。【叫做不能有传递依赖】</p>
<p>比如在设计一个订单数据表的时候，可以将客户id作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、电话、地址等）的字段。</p>
<h2 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h2><p>BCNF范式消除了可能存在的<strong>主属性</strong>对<strong>主码</strong>的部分依赖和传递依赖</p>
<p>BCNF范式在3NF基础上<strong>消除对主码子集的依赖</strong>。</p>
<p>以考试分数表为例：身份证号，学号，科目，分数。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201135632.png" alt="image-20210808201135632" style="zoom:50%;" />

<p>首先该表满足第三范式，表中存在有如下依赖关系：</p>
<p>(身份证号，科目)→(学号，分数)<br>(学号，科目) → (身份证号，分数)</p>
<p>由以上依赖关系可以得知(身份证号，科目)和(学号，科目) 为表关系中的<strong>候选码</strong>。</p>
<p>主属性:身份证号、学号、科目<br>非主属性:分数</p>
<p>但是，由于存在如下决定关系：</p>
<p>(身份证号)——&gt;(学号)</p>
<p>(学号)——&gt;(身份证号)</p>
<p>即存在关键字段决定关键字段的情况，因此其不符合BCNF。</p>
<p>解决方法：把考试分数系表分解为两个关系表：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201510297.png" alt="image-20210808201510297" style="zoom:50%;" />

<p>这样这个数据库表是符合BCNF的，并消除了删除异常、插入异常和更新异常。</p>
<h2 id="4NF-消除多值依赖"><a href="#4NF-消除多值依赖" class="headerlink" title="4NF-消除多值依赖"></a>4NF-消除多值依赖</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201630368.png" alt="image-20210808201630368" style="zoom:50%;" />

<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p><strong>mysql中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。</strong></p>
<p>事务：在数据库系统中，<strong>一个事务是指由一系列连续的数据库操作组成的一个完整的逻辑过程</strong>。这组操作执行前后，系统需要处于一个可预知的、一致的状态。</p>
<h2 id="☆数据库的四大特性！ACID特性"><a href="#☆数据库的四大特性！ACID特性" class="headerlink" title="☆数据库的四大特性！ACID特性"></a>☆数据库的四大特性！ACID特性</h2><p>ACID是指在 数据库管理系统（DBMS）中事务所具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<ul>
<li>1、<strong>原子性：事务被视为不可分割的最小单元，在一个事务中所有的操作要么都成功，要么都失败。</strong><ul>
<li>如银行转账，A向B账户转账1000元，这里可分为三个操作，1.A向B转账、2.银行处理、3.B账户收到转账。原子性就是保证这三个操作要么都成功，要么都失败，如果1、2操作成功，3失败了，那么1、2操作要进行回滚</li>
<li>回滚可以通过日志来实现，主要是基于MySQL日志系统的redo和undo机制。日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</li>
</ul>
</li>
<li>2、<strong>一致性：一个事务执行前和执行后都必须处于一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</strong><ul>
<li>一旦一个事务结束了，不管成功还是失败，系统所处的状态和它的业务规则是一致的。也就是说，数据应当不会被破坏。</li>
<li>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来还得是5000，这就是事务的一致性。</li>
</ul>
</li>
<li>3、<strong>隔离性：隔离性是指两个事务之间互不干扰。一个事务所做的修改在最终提交以前，对其他事务是可不见的。</strong><ul>
<li>当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
</ul>
</li>
<li>4、<strong>持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</strong><ul>
<li>持久性需要考虑到事物在执行过程中可能出现的各种异常，并对异常做出相应的处理。</li>
</ul>
</li>
</ul>
<h3 id="mysql中如何控制（开启，关闭）事务"><a href="#mysql中如何控制（开启，关闭）事务" class="headerlink" title="mysql中如何控制（开启，关闭）事务?"></a><strong>mysql中如何控制（开启，关闭）事务?</strong></h3><ul>
<li><p><code>select @@autocommit;</code>语句可以查询事务是否开启，1为开启。mysql默认是开启事务的(<strong>自动提交</strong>)。</p>
<p><code>rollback;</code>回滚，事务开启时是撤销不了的。</p>
</li>
<li><p>设置mysql自动提交为false：<code>set autocommit=0 ;</code></p>
<p>​    这时插入数据后，再<code>rollback;</code>是可以撤销的。</p>
<p>​    但是比如插入数据后输入<code>commit</code><strong>手动提交</strong>，然后再<code>rollback;</code>是不能撤销的。</p>
</li>
<li><p>事务开启之后，一旦commit 提交，就不可以回滚(也就是当前的这个事务在提交的时候就结束了|<br><code>begin;</code>，或者<code>start transaction;</code></p>
<p>——都可以帮我们手动开启一个事务，而且<code>rollback;</code>是可以撤销的</p>
<p>想要提交就<code>commit</code><strong>手动提交</strong>，commit之后不可撤销。</p>
</li>
</ul>
<h2 id="☆数据库四种隔离等级-amp-事务并发问题"><a href="#☆数据库四种隔离等级-amp-事务并发问题" class="headerlink" title="☆数据库四种隔离等级 &amp; 事务并发问题"></a>☆数据库四种隔离等级 &amp; 事务并发问题</h2><p>MySQL定义了四种隔离级别：</p>
<ul>
<li><strong>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。【都可以避免】</strong> <ul>
<li>完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。</li>
<li>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</li>
</ul>
</li>
<li><strong>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。【不可避免幻读】</strong><ul>
<li>在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li>
<li>在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了<strong>在一个事务内两次读到的数据是一样的，因此称为是可重复读</strong></li>
</ul>
</li>
<li><strong>③ Read committed (读已提交、不可重复读)：可避免脏读的发生。</strong><ul>
<li><strong>只能读取到已经提交的数据</strong>。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li>
</ul>
</li>
<li><strong>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。【都不能避免】</strong><ul>
<li>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但<strong>允许其他事务读此行数据。</strong></li>
<li>a事务对数据进行操作，在操作的过程中，事务没有被提交，但是b可以看见a操作的结果。</li>
<li>SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li>
</ul>
</li>
</ul>
<p><strong>事务并发问题</strong><br><strong>1）脏读（Dirty Reads）</strong>：<br>事务A读取了事务B的更新的数据，但是事务B回滚了（未提交），导致A读取的为脏数据。</p>
<p><strong>2）不可重复读（Non-Repeatable Reads）</strong>：<br>事务A读取同一数据两次，但是在两次之间事务B对该数据进行了修改并提交，导致事务A读取两次读取不一致。</p>
<p><strong>3）幻读（Phantom Reads）</strong>：<br>事务A修改全表的数据，在事务A未提交时，事务B向表中插入或删除数据并提交，导致事务A读取的数据与需要修改的数据不一致。</p>
<p>PS: 不可重复读针对的是数据的修改，幻读针对的时数据的新增和删除。解决不可重复读问题只需要给对应记录上行锁，而解决幻读需要对表加锁。</p>
<ul>
<li><p>实现事物隔离性主要有两种方式</p>
<p><strong>读写锁</strong>和MVCC（Multi-Version Concurrency Control）<strong>多版本并发处理方式</strong>。</p>
</li>
</ul>
<p><strong>不考虑事务的隔离性，会发生的几种问题：</strong></p>
<ul>
<li>1，脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>
</ul>
<p>当一个事务正在多次修改某个数据，而在这个事务还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
<ul>
<li><p>2，不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<ul>
<li>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。</li>
<li><strong>不可重复读和脏读的区别是</strong>，脏读是某一事务读取了另一个事务<strong>未提交的脏数据</strong>，而不可重复读则是读取了<strong>前一事务提交的数据</strong>。</li>
<li>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</li>
</ul>
</li>
<li><p>3，虚读(幻读)：幻读是事务非独立执行时发生的一种现象。</p>
<ul>
<li>例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，<strong>这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。</strong>而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，<strong>其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</strong></li>
<li><strong>幻读和不可重复读</strong>都是读取了另一条<strong>已经提交的事务</strong>（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项</strong>，而<strong>幻读针对的是一批数据整体</strong>（比如数据的个数）。</li>
</ul>
</li>
</ul>
<h3 id="如何查看、修改数据库的隔离级别"><a href="#如何查看、修改数据库的隔离级别" class="headerlink" title="如何查看、修改数据库的隔离级别?"></a>如何查看、修改数据库的隔离级别?</h3><p>如何查看数据库的隔离级别?（默认是REPEATABLE-READ）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysq <span class="number">8.0</span>:</span><br><span class="line"><span class="comment">-- 系统级别的</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.transaction_isolation;</span><br><span class="line"><span class="comment">-- 会话级别的</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure>

<p>如何修改数据库的隔离级别?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<h2 id="☆关系型数据库和非关系型数据库（区别、各自特性优缺点"><a href="#☆关系型数据库和非关系型数据库（区别、各自特性优缺点" class="headerlink" title="☆关系型数据库和非关系型数据库（区别、各自特性优缺点"></a>☆关系型数据库和非关系型数据库（区别、各自特性优缺点</h2><p><strong>区别总结：</strong></p>
<p><strong>1、数据存储结构不同</strong></p>
<ul>
<li>非关系型数据库存储数据的格式，可以是K-V键值对文形式、文档形式、图片形式等，对于数据的格式十分灵活。非关系型数据库可以存储基础类型以及对象或集合等；</li>
<li>而关系型数据库只支持基础类型。(例如在 MySQL 中，主要支持数值类型、日期&#x2F;时间类型、字符串字符类型)</li>
<li>因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</li>
</ul>
<p><strong>2、可扩展性不同</strong></p>
<ul>
<li>关系型数据库一般都有固定的表结构，不是很容易进行扩展，灵活度稍欠缺。</li>
<li>非关系型数据库具有高扩展性：基于键值对，数据没有耦合性，容易扩展。</li>
</ul>
<p><strong>3、数据一致性方面不同</strong></p>
<ul>
<li>关系型数据库的最大特点就是事务的一致性</li>
<li>而非关系型数据库一般不支持ACID特性。</li>
<li>因此如果业务对于数据的一致性要求很高，那么非关系型数据库并不一个很好的选择</li>
<li>非关系型数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的<ul>
<li>什么是CAP？Consistency一致性，Availability可用性，Partition tolerance分区容错性。</li>
</ul>
</li>
</ul>
<p><strong>4、读写速度不同</strong></p>
<ul>
<li>关系型数据库，数据读写必须经过sql解析，大量数据、高并发下读写性能不足，对传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</li>
<li>非关系型数据库，在高并发，大数据下读写能力较强。无需经过sql层的解析，读写性能很高。</li>
<li>而且，nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li>
</ul>
<p><strong>5、复杂查询方面</strong></p>
<ul>
<li>关系型数据库，支持SQL，可用于一个表以及多个表之间非常复杂的查询。例如进行join等复杂查询。</li>
<li>非关系型数据库，数据结构相对复杂，复杂查询方面稍欠。</li>
</ul>
<p><strong>6、成本方面</strong></p>
<ul>
<li>关系型数据库，昂贵，像oracle需要花费大量成本购买使用。</li>
<li>nosql数据库部署简单，成本低，基本都是开源软件。</li>
</ul>
<p><strong>7、存储载体不同</strong></p>
<ul>
<li>nosql可以使用硬盘或者随机存储器作为载体</li>
<li>而关系型数据库只能使用硬盘。</li>
</ul>
<hr>
<p>关系型数据库通过外键关联来建立表与表之间的关系，非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</p>
<p>当前主流的<strong>关系型数据库</strong>有Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL等。</p>
<p><strong>非关系型数据库</strong>有 MongoDB、NoSql、Redis、Memcached、HBase   。</p>
<p>非关系型数据库也叫Nosql数据库，全称是not only sql</p>
<p>非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。</p>
<hr>
<p><strong>关系型数据库的特性</strong><br>1、关系型数据库，是指采用了关系模型来组织数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p>
<p><strong>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织</strong><br><strong>优点：</strong><br>1、易于维护：都是使用表结构，格式一致；丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br><strong>缺点：</strong><br>1、为了维护一致性所付出的巨大代价，就是其读写性能比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，灵活度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。<br>数据读写必须经过sql解析，大量数据、高并发下读写性能不足。</p>
<hr>
<p><strong>非关系型数据库的特性</strong><br>1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。可以是文档或者键值对等</p>
<p><strong>非关系型数据库的优点：</strong><br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式；而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、无需经过sql层的解析，读写性能很高；<br>4、高扩展性：基于键值对，数据没有耦合性，容易扩展；<br>5、成本低：nosql数据库部署简单，基本都是开源软件。</p>
<p><strong>非关系型数据库的缺点</strong><br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p>
<h2 id="☆非关系型数据库Mangodb（简介、增删改查命令"><a href="#☆非关系型数据库Mangodb（简介、增删改查命令" class="headerlink" title="☆非关系型数据库Mangodb（简介、增删改查命令"></a>☆非关系型数据库Mangodb（简介、增删改查命令</h2><p>MongoDB是用C++语言编写的非关系型数据库。</p>
<p>MongoDB是一个开源、 高性能、无模式的文档型数据库。是最像关系型数据库(MySQL) 的非关系型数据库。</p>
<p>它支持的数据结构非常松散，是一种类似于JSON的格式叫<strong>BSON</strong>,所以它既可以存储比较复杂的数据类型，又相当的灵活。</p>
<p>MongoDB中的记录是一个文档， MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。 </p>
<p>特点是高性能、易部署、易使用，存储数据十分方便，主要特性有：<br>    面向集合存储，易于存储对象类型的数据<br>    模式自由（不用像MySQL需要指定列啥的<br>    支持动态查询<br>    支持完全索引，包含内部对象<br>    支持复制和故障恢复<br>    使用高效的二进制数据存储，包括大型对象<br>    文件存储格式为BSON(一种JSON的扩展)</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805171429968.png" alt="image-20210805171429968" style="zoom:55%;" />

<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805144217821.png" alt="image-20210805144217821"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805144202411.png" alt="image-20210805144202411"></p>
<h2 id="mysql和redis两种数据库有什么区别"><a href="#mysql和redis两种数据库有什么区别" class="headerlink" title="mysql和redis两种数据库有什么区别"></a>mysql和redis两种数据库有什么区别</h2><p>mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p>
<p>redis是缓存数据库，即将数据存储在缓存中，用于存储使用频繁的数据，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p>
<blockquote>
<p>缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p>
</blockquote>
<p>redis和mysql的区别总结</p>
<p>（1）类型上</p>
<p>从类型上来说，mysql是关系型数据库，redis是缓存数据库</p>
<p>（2）作用上</p>
<p>mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快<strong>，但是不受空间容量限制</strong>，性价比高</p>
<p>redis用于存储使用较为频繁的数据到缓存中，读取速度快，基于内存，读写速度快，也可做持久化，但是<strong>内存空间有限</strong>，当数据量超过内存空间时，需扩充内存，但内存价格贵</p>
<p>（3）需求上</p>
<p>mysql和redis因为需求的不同，一般都是<strong>配合使用</strong>。<br>需要<strong>高性能的地方使用Redis</strong>，<strong>不需要高性能的地方使用MySQL</strong>。存储数据在MySQL和Redis之间做同步。</p>
<h2 id="☆Redis面试题总结"><a href="#☆Redis面试题总结" class="headerlink" title="☆Redis面试题总结"></a>☆Redis面试题总结</h2><p><strong>redis 简介</strong><br>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 <strong>redis 的数据是存在内存中的，所以存写速度非常快</strong>，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<hr>
<p><strong>为什么要用 redis &#x2F;为什么要用缓存</strong></p>
<p>主要考虑两个角度：<strong>性能和并发</strong></p>
<p>如果说数据要去硬盘上读取，那么过程会比较慢。如果将频繁使用的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，<strong>所以速度相当快</strong>。</p>
<p>在<strong>大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常</strong>。这个时候，就需要使用 Redis 做一个缓冲操作。<strong>直接操作缓存</strong>能够承受的请求是<strong>远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，让请求到 Redis这里而不用经过数据库。</p>
<hr>
<p><strong>Redis支持哪几种数据类型？</strong></p>
<ol>
<li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p>
<p>最常规的 set&#x2F;get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p>
</li>
<li><p>list：按照添加顺序保持顺序的字符串列表。</p>
<p>使用 List 的数据结构（双向链表，可以做简单的消息队列的功能。比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。另外，可以利用 lrange 命令，就是从某个元素开始读取多少个元素,可以做基于 Redis 的分页功能，性能极佳，用户体验好。可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
</li>
<li><p>set：无序的字符串集合，不存在重复的元素。</p>
<p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p>
</li>
<li><p>Zset：有序集合。</p>
<p>多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p>
</li>
<li><p>hash：key-value对的一种集合。</p>
<p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p>
</li>
</ol>
<hr>
<p><strong>Redis到底是多线程还是单线程？单线程的 Redis 为什么这么快</strong></p>
<p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>
<p>(1) 绝大部分请求是<strong>纯粹的内存操作</strong>（非常快速）</p>
<p>(2) 采用单线程，<strong>避免了不必要的上下文切换和竞争</strong>条件</p>
<p>(3) 采用了非阻塞 <strong>I&#x2F;O 多路复用</strong>机制</p>
<p><strong>仔细说一说 I&#x2F;O 多路复用机制</strong></p>
<p>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I&#x2F;O 多路复用程序，将其置入<strong>队列</strong>之中。然后，文件事件分派器，<strong>依次去队列中取</strong>，转发到不同的事件处理器中。</p>
<hr>
<p><strong>redis 持久化机制</strong>（怎么保证 redis 挂掉之后再重启数据可以进行恢复）</p>
<p><strong>持久化</strong>就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis支持持久化，Redis 提供两种持久化机制 <strong>RDB（默认） 和 AOF 机制:</strong></p>
<p><strong>快照（snapshotting，RDB），只追加文件（append-only file,AOF）</strong></p>
<p>对比区别：</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全，但AOF 文件比 RDB 文件大，且恢复速度慢</li>
<li>RDB性能比AOF好，数据集大的时候，AOF比 rdb 启动效率低。</li>
<li><strong>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</strong></li>
</ul>
<p>（1）<strong>RDB：是Redis DataBase缩写快照</strong>。RDB是Redis默认的持久化方式。<strong>按照一定的时间将内存的数据以快照的形式保存到硬盘中</strong>，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：数据安全性低。RDB 是间隔一段时间进行持久化，<strong>如果持久化之间 redis 发生故障，会发生数据丢失</strong>。所以这种方式更适合数据要求不严谨的时候)</p>
<p>（2）<strong>AOF持久化，</strong>开启AOF持久化后<strong>每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</strong>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p><strong>如何选择合适的持久化方式</strong></p>
<ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p><strong>Redis持久化数据和缓存怎么做扩容？</strong></p>
<ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<hr>
<p><strong>Redis主要消耗什么物理资源？</strong>内存。</p>
<p><strong>Redis的内存用完了会发生什么？</strong><br>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<p><strong>Redis如何做内存优化？</strong><br>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<hr>
<p><strong>知道跳跃表吗？在 Redis 中主要用在哪些地方？</strong></p>
<p>zset 有序集合，可以使用范围查找，排行榜功能或者topN功能。</p>
<p><strong>zset 有序集合 就是用跳表来实现的。</strong></p>
<p>跳跃表是一种有序的数据结构,它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<ul>
<li>跳跃表基于<strong>单链表加索引</strong>的方式实现</li>
<li>跳跃表<strong>以空间换时间</strong>的方式提升了查找速度</li>
<li>Redis有序集合在<strong>节点元素较大</strong>（比如很长的字符串）或者<strong>元素数量较多</strong>时使用跳跃表实现</li>
</ul>
<p>像这种链表<strong>加多级索引</strong>的结构，就是跳跃表：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805220023861.png" alt="image-20210805220023861" style="zoom:33%;" />

<p>思考一个问题，为什么元素数量比较多或者成员 比较长的字符串的时候Redis要使用跳跃表来实现?<br>跳跃表在链表的基础上增加了多级索引以提升查找的效率,其是一个<strong>空间换时间</strong>的方案, 必然会带来个问题：索引是 占内存的。</p>
<p>原始链表中存储的有可能是很大的对象,索引结点只要存储关键值和几个指针,并不需要要存储对象，因此当节点本身比较大或者元素数量比较多的时候,其优势必然会被放大,而缺点则可以忽略。</p>
<hr>
<p><strong>Redis的过期键的删除策略</strong></p>
<p>Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong></p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当客户端访问一个key时，才会判断该key是否已过期，过期则清除。<ul>
<li>该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
</ul>
</li>
<li>定期过期：redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。<ul>
<li>不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略</li>
<li>该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
</li>
</ul>
<hr>
<p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据<br>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<p><strong>Redis的内存淘汰策略有哪些</strong><br>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<ul>
<li><p><strong>全局的键空间</strong>选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，首先通过<strong>LRU算法</strong>驱逐最久没有使用的键。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，随机移除某个key。</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
</li>
<li><p><strong>设置过期时间的键空间</strong>选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，移除最久没有使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，有更早过期时间的key优先移除。</li>
<li>volatile-lfu：从所有配置了过期时间的键中<strong>驱逐使用频率最少的键</strong></li>
</ul>
</li>
</ul>
<p>总结：Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<p><strong>LRU</strong></p>
<ol>
<li><p>新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。</p>
</li>
<li><p>修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。</p>
</li>
<li><p>访问key对应的值的时候把访问的Node节点移动到队尾即可。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805225025923.png" alt="image-20210805225025923" style="zoom:50%;" />

<p><strong>Redis缓存雪崩、穿透、击穿</strong></p>
<p>缓存处理流程：前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果</p>
<p><strong>缓存雪崩</strong>：redis缓存key同一时间大量失效，导致大量请求全部打到数据库，造成数据库挂掉</p>
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</p>
<p>和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p> <strong>解决方案</strong>：</p>
<ol>
<li>设置缓存数据的过期时间，防止同一时间大量数据过期现象发生，随机初始化缓存失效时间。</li>
<li>redis一般都是集群部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
<li>不断的用定时任务去刷新缓存</li>
</ol>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击，但是不能可能会用不同的ID攻击。</p>
</li>
<li><p>IP拉黑，但可能会用不同的IP来攻击。</p>
</li>
<li><p>接口层增加参数合法性校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
</li>
<li><p>布隆过滤器，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下：</p>
<ul>
<li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li>
<li>这些K个hash值映射到对应的K个二进制的数组下标</li>
<li>将K个下标对应的二进制数据改成1。</li>
</ul>
<p>布隆过滤器筛掉非法的key，就是缓存中不存在且数据库也不存在的数据。布隆过滤器跟redis缓存其实是配合的，都是为了减少无效查询，当然redis缓存可以增加热数据的查询效率，布隆过滤器一般用redis的bitmap来存储，他不可能存数据库的全部信息，只是用来判断数据在或者不在。<br><strong>所以流程是1 查redis的布隆过滤器（如果未命中直接结束） 2 查redis缓存数据 3 查询数据库 淘汰更新缓存。</strong></p>
</li>
</ol>
<p><strong>缓存击穿</strong>是指突然该key失效，一瞬间大量该key的请求打到数据库上</p>
<p>缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，在请求数据库这边给他上锁，那么这个时候就只有一个线程，能抢到这个锁，所以也就只有一个线程能操作这个数据库，那么对数据库的压力就很小，当查询到数据之后呢，还会把缓存重新写到redis里去。其他没有抢到锁的线程，让他先睡几毫秒，然后再重新去redis里面去查询</li>
</ol>
<h2 id="CAP——非关系型数据库是基于CAP模型"><a href="#CAP——非关系型数据库是基于CAP模型" class="headerlink" title="CAP——非关系型数据库是基于CAP模型"></a>CAP——非关系型数据库是基于CAP模型</h2><p>一个经典的分布式系统理论。CAP理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。</p>
<p>1、一致性</p>
<p>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</p>
<p>2、可用性</p>
<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<p>3、分区容错性</p>
<p>分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h2 id="和-区别"><a href="#和-区别" class="headerlink" title="#和$区别"></a>#和$区别</h2><p>面试回答：</p>
<ul>
<li><p><strong>#对传入的参数视为字符串。</strong></p>
</li>
<li><p><strong>$引用参数时，不做任何处理，直接将值拼接在sql语句中。</strong></p>
</li>
<li><p><strong>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译，不能避免注入攻击。</strong></p>
</li>
</ul>
<hr>
<p>向sql语句传参，在sql语句中引用这些参数的时候，有两种方式：#， $。</p>
<p>开启预编译，<strong>如果是$是在此时将参数一起编译；如果是#参数不编译</strong>，会在执行sql查询的时候，将参数当成字符串放进去，也就是同样的sql语句只需要编译一次。</p>
<p><strong>两者的区别：</strong></p>
<ul>
<li><p>使用#方式引用参数的时候，会把传入的参数当成是一个字符串，自动添加双引号。</p>
</li>
<li><p>$引用参数时，不做任何处理，直接将值拼接在sql语句中。</p>
</li>
</ul>
<p>他们之间的区别用最直接的话来说就是：</p>
<p>#是一个占位符，$是拼接符。</p>
<p>#相当于对数据加上双引号，$相当于直接显示数据。</p>
<ul>
<li><p><strong>1、#对传入的参数视为字符串。</strong></p>
<ul>
<li><strong>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值</strong></li>
<li>也就是它会预编译select * from user where name &#x3D; #{name}</li>
<li>比如我传一个csdn，那么传过来就是select * from user where name &#x3D; ‘csdn’</li>
</ul>
</li>
<li><p><strong>2、$引用参数时，不做任何处理，直接将值拼接在sql语句中。</strong>select * from user where name&#x3D;${name}</p>
<ul>
<li>比如我穿一个csdn，那么传过来就是select * from user where name&#x3D;csdn</li>
</ul>
</li>
<li><p><strong>3、使用 # 能够防止sql注入，$不能避免注入攻击。</strong></p>
<ul>
<li>比如：用户进行一个登录操作，后台sql验证式样的：select * from user where username&#x3D;#{name} and password &#x3D; #{pwd}</li>
<li>如果前台传来的用户名是“wang”，密码是 “1 or 1&#x3D;1”，用#的方式就不会出现sql注入，而如果换成$方式，sql语句就变成了select * from user where username&#x3D;wang and password &#x3D; 1 or 1&#x3D;1，这样的话就形成了sql注入。</li>
</ul>
</li>
<li><p>4、Mybatis 默认情况下，将对所有的 sql 进行预编译。</p>
</li>
<li><p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#。</p>
</li>
</ul>
<h2 id="mysql预编译"><a href="#mysql预编译" class="headerlink" title="mysql预编译"></a>mysql预编译</h2><p><strong>预编译：指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</strong></p>
<p> <strong>为什么需要预编译？预编译的好处：</strong><br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译<strong>。预编译阶段可以优化 sql 的执行。</strong></p>
<ul>
<li><strong>1、预编译之后DBMS可以省去编译，直接运行sql。</strong><ul>
<li>预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译。</li>
</ul>
</li>
<li><strong>2、</strong>一般而言，越复杂的SQL，编译的复杂度将越大，<strong>预编译可以将多个操作合并成一个操作。</strong></li>
<li><strong>3、预编译语句对象可以重复利用。</strong>（把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个 SQL，可以直接使用这个缓存的 PreparedState 对象。）</li>
<li><strong>4、可以将这类SQL语句中的值用占位符替代，不需要每次编译，可以直接执行，只需执行的时候，直接将每次请求的不同的值设置到占位符的位置。</strong></li>
<li><strong>5、预编译可以视为将sql语句模板化或者说参数化。</strong></li>
</ul>
<p><strong>mysql如何开启预编译</strong></p>
<ul>
<li>Mysql是默认 没有开启预编译的，需要在配置中加上<br>jdbc:mysql:&#x2F;&#x2F;xxx.22.11.31:3306&#x2F;dbname?useServerPrepStmts&#x3D;true</li>
</ul>
<p>（有兴趣的可以查看mysql驱动包里面的ConnectionImpl类是如何操作预编译的。这里提一下缓存PreparedStatement，在执行预编译时会先去判断是否存在缓存，如果存在则对参数清空，绑定新的参数。如果不存在则调用数据库进行预编译处理生成一个PreparedStatement对象。）</p>
<p>那如果按照默认不开启预编译的话，会是什么情况？ 每次JDBC都需要编译一条新的sql，即使查询的是同样的sql，也是重新编译一条sql</p>
<img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3c3df9bd05105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:33%;" />

<p>开启预编译，<strong>如果是${}是在此时将参数一起编译，如果是#{}参数不编译</strong>，会在执行sql查询的时候，将参数当成字符串放进去，也就是同样的sql语句只需要编译一次。</p>
<img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3c48dfb843898?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:33%;" />

<p>所以使用${}会编译你参数的这个参数，会有sql风险，而使用#{}仅仅是 select * from t_user where id &#x3D; xxx ，将参数不编译以字符串的形式，放到xxx的位置，参数你写别的sql想注入就会报错。 <strong>能用#{}尽量用#{}！</strong></p>
<h2 id="mysql-读写分离"><a href="#mysql-读写分离" class="headerlink" title="mysql 读写分离"></a>mysql 读写分离</h2><p>1、what 读写分离 </p>
<p>读写分离，基本的原理是让<strong>主数据库</strong>处理事务性<strong>增、改、删</strong>操作（INSERT、UPDATE、DELETE），而<strong>从数据库</strong>处理SELECT<strong>查询</strong>操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p>
<p><strong>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。</strong></p>
<p>2、why 那么为什么要读写分离呢？<br>因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。<br>但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。<br>所以读写分离，解决的是，数据库的写入，影响了查询的效率。</p>
<p>3、when 什么时候要读写分离？<br>数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。</p>
<h2 id="如何优化MySQL"><a href="#如何优化MySQL" class="headerlink" title="如何优化MySQL"></a>如何优化MySQL</h2><p>① SQL语句及索引的优化</p>
<p>② 数据库表结构的优化：使得数据库结构符合三大范式与BCNF</p>
<p>③ 系统配置的优化</p>
<p>④ 硬件的优化</p>
<p>SQL语句的优化：<br>        1、<strong>尽量避免使用子查询</strong>(先查外表再匹配内表,而不是先查内表,当外表的数据很大时,查询速度会非常慢。)<br>        2、<strong>避免函数索引</strong>（WHERE YEAR(d) &gt;&#x3D; 2016;即使d字段有索引，也会直接全表扫描。d &gt;&#x3D; ‘2016-01-01’）<br>        3、用IN来替换OR（MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。对于连续的数值，能用 between 就不要用 in 了）<br>        4、LIKE前缀%号、双百分号、<code>_</code>下划线查询非索引列或<code>*</code>无法使用到索引，如果查询的是索引列则可以<br>        5、<strong>读取适当的记录</strong>LIMIT M,N，而不要读多余的记录<br>        6、避免数据类型不一致<br>        7、分组统计可以禁止排序sort，总和查询可以禁止排重用union all<br>        8、避免随机取记录（MySQL不支持函数索引，会导致全表扫描<br>        9、禁止不必要的ORDER BY排序<br>        10、<strong>批量INSERT插入</strong><br>        11、<strong>不要使用NOT等负向查询条件</strong>（你可以想象一下，对于一棵B+树，根节点是40，如果你的条件是等于20，就去左面查，你的条件等于50，就去右面查，但是你的条件是不等于66，索引应该咋办？还不是遍历一遍才知道。<br>        12、**尽量不用<code>select *</code><em>*（SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）<br>        13、区分in和exists（区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</em>*</p>
<p>​        14、优化Group By语句</p>
<p>​        如果对group by语句的结果没有排序要求，<strong>要在语句后面加 order by null（group 默认会去排序）</strong>；</p>
<p>​        尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</p>
<p>​        如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</p>
<p>​        如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法（直接用磁盘临时表）得到group by的结果。</p>
<p>​        15、多表关联尽量用join，减少子查询的使用。表的关联字段如果能用主键就用主键，也就是尽可能的使用索引字段。如果关联字段不是索引字段可以根据情况考虑添加索引。</p>
<p>​    索引的优化：<br>​        1、<strong>Join语句的优化</strong><br>​        2、避免索引失效</p>
<p>​            1）如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<p>​            <strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>​            2）<strong>不在索引列上做任何操作</strong> (计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描。<br>​            3）存储引擎不能使用索引中范围条件右边的列。如这样的sql: <code>select * from user where username=&#39;123&#39; and age&gt;20 and phone=&#39;1390012345&#39;</code>,其中username, age, phone都有索引，只有username和age会生效，phone的索引没有用到。</p>
<p>​            4）尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))</p>
<pre><code>   如select age from user减少select *
</code></pre>
<p>​            5）mysql在使用不等于(!&#x3D; 或者 &lt;&gt;)的时候无法使用索引会导致全表扫描。</p>
<p>​            6）is null, is not null 也无法使用索引，在实际中尽量不要使用null。</p>
<p>​            7）like 以通配符开头(‘%abc..’)mysql索引失效会变成全表扫描的操作。</p>
<pre><code>   所以最好用右边like &#39;abc%&#39;。如果两边都要用，可以用select age from user where username like &#39;%abc%&#39;,其中age是必须是索引列，才可让索引生效
</code></pre>
<h2 id="如果数据库查询很慢该怎么定位问题"><a href="#如果数据库查询很慢该怎么定位问题" class="headerlink" title="如果数据库查询很慢该怎么定位问题"></a>如果数据库查询很慢该怎么定位问题</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ibytecoding/p/13859625.html">https://www.cnblogs.com/ibytecoding/p/13859625.html</a></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815230704693.png" alt="image-20210815230704693" style="zoom:60%;" />

<h1 id="x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-mysql实例-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-mysql实例-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1><h2 id="【学生表，老师表，统计每个老师教了多少学生，降序排序】"><a href="#【学生表，老师表，统计每个老师教了多少学生，降序排序】" class="headerlink" title="【学生表，老师表，统计每个老师教了多少学生，降序排序】"></a>【学生表，老师表，统计每个老师教了多少学生，降序排序】</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> teachername,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> teacher</span><br><span class="line"><span class="keyword">on</span> student.teacherid<span class="operator">=</span>teacher.teacherid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student.teacherid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> A <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h2 id="【☆按小时统计每个不同的小时数据出现的个数】sql-的-DATE-FORMATE-函数"><a href="#【☆按小时统计每个不同的小时数据出现的个数】sql-的-DATE-FORMATE-函数" class="headerlink" title="【☆按小时统计每个不同的小时数据出现的个数】sql 的 DATE_FORMATE()函数"></a>【☆按小时统计每个不同的小时数据出现的个数】sql 的 DATE_FORMATE()函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DATE_FORMAT(a_time,<span class="string">&#x27;%Y-%m-%d %H&#x27;</span>) a_hour,<span class="built_in">count</span>(id) hour_count</span><br><span class="line"><span class="keyword">from</span> abc_log</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a_hour;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804104554233.png" alt="image-20210804104554233" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804104627399.png" alt="image-20210804104627399" style="zoom:50%;" />

<h2 id="【sql查询今天温度比昨天高的日期】DATEDIFF函数"><a href="#【sql查询今天温度比昨天高的日期】DATEDIFF函数" class="headerlink" title="【sql查询今天温度比昨天高的日期】DATEDIFF函数"></a>【sql查询今天温度比昨天高的日期】DATEDIFF函数</h2><p>日期之间差一天，即将表Weather定义为两个表A、B。</p>
<p>把A表看到昨日数据，B表看作今日数据。即A表的日期加1天等于B表的日期，B表的温度大于A表温度即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210806013113170.png" alt="image-20210806013113170"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.starttime <span class="keyword">FROM</span> Weather <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Weather <span class="keyword">AS</span> B <span class="keyword">ON</span> A.temperature<span class="operator">&gt;</span>B.temperature <span class="keyword">and</span> DATEDIFF(B.starttime,A.starttime) <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.starttime <span class="keyword">FROM</span> Weather <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Weather <span class="keyword">AS</span> B <span class="keyword">ON</span> A.temperature<span class="operator">&gt;</span>B.temperature <span class="keyword">and</span> DATE_ADD(A.starttime,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> ) <span class="operator">=</span> B.starttime</span><br></pre></td></tr></table></figure>

<h2 id="【查询分数-gt-80分的学生名字，查询列表的第10-20条】"><a href="#【查询分数-gt-80分的学生名字，查询列表的第10-20条】" class="headerlink" title="【查询分数&gt;80分的学生名字，查询列表的第10-20条】"></a>【查询分数&gt;80分的学生名字，查询列表的第10-20条】</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from scoretablename</span><br><span class="line">where 成绩&gt;80</span><br><span class="line">limit 9,11</span><br></pre></td></tr></table></figure>

<h2 id="【查找所有分数大于80的学生】"><a href="#【查找所有分数大于80的学生】" class="headerlink" title="【查找所有分数大于80的学生】"></a>【查找所有分数大于80的学生】</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">having</span> <span class="built_in">min</span>(code)<span class="operator">&gt;</span><span class="number">80</span>;</span><br></pre></td></tr></table></figure>



<h2 id="【按字段进行分组group-by】"><a href="#【按字段进行分组group-by】" class="headerlink" title="【按字段进行分组group by】"></a>【按字段进行分组group by】</h2><p>SQL如何查询一张表的所有字段并按其中一个字段进行分组</p>
<p>假设一个表tab有一个id字段、一个Name字段，内容如下</p>
<blockquote>
<p>id  Name<br>3  张三<br>5  李四<br>1  王五<br>1  赵六</p>
</blockquote>
<p>sql 语句<br><strong>select * from tab group by id</strong></p>
<p>这条SQL的结果应该是</p>
<blockquote>
<p>id Name<br>1  王五<br>3  张三<br>5  赵六</p>
</blockquote>
<p>第一个Name显示的是王五 因为sql group by满足条件的有多个时是取第一个的</p>
<p>group by 一般结合合计函数一起使用<br>比如 sql语句<br>select id,count(*) AS total from tab group by id<br>用于统计每个id有多少个<br>结果</p>
<blockquote>
<p>id total<br>1  2<br>3 1<br>5  1</p>
</blockquote>
<p>sql语句中的AS可以省略,一般as 后边是别名；能省略，但是不建议，建议写上as，增加可读性</p>
<h2 id="【给定id-name-score，统计每一个分数的人数】"><a href="#【给定id-name-score，统计每一个分数的人数】" class="headerlink" title="【给定id,name,score，统计每一个分数的人数】"></a>【给定id,name,score，统计每一个分数的人数】</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score,<span class="built_in">count</span>(id)</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> score;</span><br></pre></td></tr></table></figure>

<h2 id="【数据库查询时间最新-order-by降序取desc-的前十行-limit-】"><a href="#【数据库查询时间最新-order-by降序取desc-的前十行-limit-】" class="headerlink" title="【数据库查询时间最新(order by降序取desc)的前十行(limit)】"></a>【数据库查询时间最新(order by降序取desc)的前十行(limit)】</h2><p>MYSQL,根据日期查询最新10条数据</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721012951842.png" alt="image-20210721012951842" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013012784.png" alt="image-20210721013012784" style="zoom:50%;" />

<blockquote>
<p>ORDER BY 关键字用于对结果集进行排序。</p>
<p>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
<p> <strong>limit</strong> 子句用于限制 SELECT 语句中查询的数据的数量。</p>
</blockquote>
<p>查询数据库中最近的十条数据，并按时间升序进行排列</p>
<ul>
<li>最近的十条数据：取最近的数据，降序排列，取十条</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013202198.png" alt="image-20210721013202198" style="zoom:50%;" />

<ul>
<li>但是要求按时间升序进行排列：<ul>
<li>即：将查询的结果作为一个中间表，然后再次进行查询</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013234284.png" alt="image-20210721013234284" style="zoom:50%;" />



<h2 id="【组合两个表】join连接-left-join解释一下"><a href="#【组合两个表】join连接-left-join解释一下" class="headerlink" title="【组合两个表】join连接:left join解释一下"></a>【组合两个表】join连接:left join解释一下</h2><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。对于这样的行，右表选择列置为null</p>
<p><strong>注释：</strong>在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></p>
<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013559792.png" alt="image-20210721013559792" style="zoom:67%;" />

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address</span><br><span class="line"><span class="keyword">on</span> Person.PersonId <span class="operator">=</span> Address.PersonId</span><br></pre></td></tr></table></figure>

<h2 id="【查询student表中两门科成绩90分以上的学生学号】"><a href="#【查询student表中两门科成绩90分以上的学生学号】" class="headerlink" title="【查询student表中两门科成绩90分以上的学生学号】"></a>【查询student表中两门科成绩90分以上的学生学号】</h2><p>查询student表中两门科成绩90分以上的学生学号的SQL语句？<br>（学号，姓名，课程号，成绩）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 学号</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> 成绩<span class="operator">&gt;</span><span class="number">90</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="【☆查出表中学生成绩最好的学生信息】"><a href="#【☆查出表中学生成绩最好的学生信息】" class="headerlink" title="【☆查出表中学生成绩最好的学生信息】"></a>【☆查出表中学生成绩最好的学生信息】</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804100831418.png" alt="image-20210804100831418" style="zoom:67%;" />

<h2 id="【查找or删除重复的电子邮箱】"><a href="#【查找or删除重复的电子邮箱】" class="headerlink" title="【查找or删除重复的电子邮箱】"></a>【查找or删除重复的电子邮箱】</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210722102030346.png" alt="image-20210722102030346" style="zoom:50%;" />

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 </span><br><span class="line"><span class="keyword">FROM</span> Person p1,Person p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210722102350174.png" alt="image-20210722102350174" style="zoom:50%;" />



<h2 id="【mysql语句：查重复城市信息…-返回表中有两名以上学员的城市的所有学员信息】"><a href="#【mysql语句：查重复城市信息…-返回表中有两名以上学员的城市的所有学员信息】" class="headerlink" title="【mysql语句：查重复城市信息….返回表中有两名以上学员的城市的所有学员信息】"></a>【mysql语句：查重复城市信息….返回表中有两名以上学员的城市的所有学员信息】</h2><p> ID Name <strong>City</strong> Address<br>1 包彦钦 北京 北京市东四北大街520号<br>2 王洪涛 北京 北京市西单北大街151号<br>3 张立涛 大连 大连市西岗区新开路69号<br>4 佘高峰 济南 山东省济南市泺文路50号<br>5 徐俊 上海 上海市静安区南阳路46号<br>6 张忠飞 上海 上海市肇嘉浜路414号<br>7 徐俊 上海 上海市乳山路150号<br>返回表中有两名以上学员的城市的所有学员信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> City</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>




<h2 id="sql优化——count-1-、count-与count-列名-的区别"><a href="#sql优化——count-1-、count-与count-列名-的区别" class="headerlink" title="sql优化——count(1)、count(*)与count(列名)的区别"></a>sql优化——count(1)、count(*)与count(列名)的区别</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wx1528159409/article/details/95643499">https://blog.csdn.net/wx1528159409/article/details/95643499</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xpt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xpt.hatake18.top/2022/02/03/QA_database/">https://xpt.hatake18.top/2022/02/03/QA_database/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xpt.hatake18.top" target="_blank">夏普通</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_database_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_reward.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_reward.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay_reward.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_reward.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/02/QA_os/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_os_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试QA整理(2)——操作系统</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/04/QA_datastructure/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_datastructure_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试QA整理(4)——数据结构</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xpt.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xpt</div><div class="author-info__description">wechat: is_xpt</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://xxxpt.blog.csdn.net/"><i class="fab fa-cuttlefish"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:namexiafan@foxmail.com" target="_blank" title="namexiafan@foxmail.com"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">菜单栏搜索可以搜文章标题及内容，最近在更新面试整理。博客正在逐步完善~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95QA%E6%95%B4%E7%90%86-3-%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">面试QA整理(3)——数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5-join"><span class="toc-text">基于MySQL数据库的几种连接查询(内连接、外连接 join)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E7%B4%A2%E5%BC%95%E3%80%91%E6%98%AF%E5%B8%AE%E5%8A%A9MySQL%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">【索引】是帮助MySQL高效获取数据的排好序的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E9%80%82%E5%90%88-x2F-%E4%B8%8D%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">什么情况适合&#x2F;不适合建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E3%80%81%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E3%80%81%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8CB-%E6%A0%91%E5%A4%9A%E9%AB%98%EF%BC%9F"><span class="toc-text">B+树一个节点有多大？一千万条数据，B+树多高？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8CHash%E8%A1%A8%EF%BC%8CB%E6%A0%91%EF%BC%8CB-%E6%A0%91"><span class="toc-text">☆索引数据结构（二叉树，红黑树，Hash表，B树，B+ 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">为什么说B+树更适合数据库索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88mongodb%E9%87%8C%E7%94%A8B%E6%A0%91%E3%80%81mysql%E9%87%8C%E9%9D%A2%E7%94%A8B-%E6%A0%91"><span class="toc-text">为什么mongodb里用B树、mysql里面用B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EB-%E6%A0%91%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9F%BA%E4%BA%8Ehash%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">基于B+树的索引和基于hash的索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90mysql%E5%BC%95%E6%93%8E%E3%80%91MyISAM%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-%E9%9D%9E%E8%81%9A%E9%9B%86"><span class="toc-text">【mysql引擎】MyISAM索引实现(非聚集)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E3%80%90mysql%E5%BC%95%E6%93%8E%E3%80%91InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-%E8%81%9A%E9%9B%86"><span class="toc-text">☆【mysql引擎】InnoDB索引实现(聚集)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%95%B4%E5%9E%8B%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-text">为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E4%B8%BB%E9%94%AE%E5%80%BC-%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E8%8A%82%E7%9C%81%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">为什么非主键索引结构叶子节点存储的是主键值? (一致性和节省存储空间)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">innodb引擎的4大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Repeated-Read"><span class="toc-text">innodb默认隔离级别：可重复读(Repeated Read)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB-amp-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">MyISAM与InnoDB 的区别 &amp; 如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F1NF-2NF-3NF"><span class="toc-text">☆数据库的三大范式1NF,2NF,3NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BCNF%E8%8C%83%E5%BC%8F"><span class="toc-text">BCNF范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4NF-%E6%B6%88%E9%99%A4%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-text">4NF-消除多值依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-text">什么是事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%81ACID%E7%89%B9%E6%80%A7"><span class="toc-text">☆数据库的四大特性！ACID特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%EF%BC%88%E5%BC%80%E5%90%AF%EF%BC%8C%E5%85%B3%E9%97%AD%EF%BC%89%E4%BA%8B%E5%8A%A1"><span class="toc-text">mysql中如何控制（开启，关闭）事务?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7-amp-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">☆数据库四种隔离等级 &amp; 事务并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E3%80%81%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">如何查看、修改数据库的隔离级别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%8C%BA%E5%88%AB%E3%80%81%E5%90%84%E8%87%AA%E7%89%B9%E6%80%A7%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">☆关系型数据库和非关系型数据库（区别、各自特性优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93Mangodb%EF%BC%88%E7%AE%80%E4%BB%8B%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%91%BD%E4%BB%A4"><span class="toc-text">☆非关系型数据库Mangodb（简介、增删改查命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%92%8Credis%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">mysql和redis两种数据库有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%86Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">☆Redis面试题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E2%80%94%E2%80%94%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%9F%BA%E4%BA%8ECAP%E6%A8%A1%E5%9E%8B"><span class="toc-text">CAP——非关系型数据库是基于CAP模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="toc-text">#和$区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-text">mysql预编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">mysql 读写分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96MySQL"><span class="toc-text">如何优化MySQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="toc-text">如果数据库查询很慢该怎么定位问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-mysql%E5%AE%9E%E4%BE%8B-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><span class="toc-text">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%AD%A6%E7%94%9F%E8%A1%A8%EF%BC%8C%E8%80%81%E5%B8%88%E8%A1%A8%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E8%80%81%E5%B8%88%E6%95%99%E4%BA%86%E5%A4%9A%E5%B0%91%E5%AD%A6%E7%94%9F%EF%BC%8C%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F%E3%80%91"><span class="toc-text">【学生表，老师表，统计每个老师教了多少学生，降序排序】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E2%98%86%E6%8C%89%E5%B0%8F%E6%97%B6%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B0%8F%E6%97%B6%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%91sql-%E7%9A%84-DATE-FORMATE-%E5%87%BD%E6%95%B0"><span class="toc-text">【☆按小时统计每个不同的小时数据出现的个数】sql 的 DATE_FORMATE()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90sql%E6%9F%A5%E8%AF%A2%E4%BB%8A%E5%A4%A9%E6%B8%A9%E5%BA%A6%E6%AF%94%E6%98%A8%E5%A4%A9%E9%AB%98%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%91DATEDIFF%E5%87%BD%E6%95%B0"><span class="toc-text">【sql查询今天温度比昨天高的日期】DATEDIFF函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%9F%A5%E8%AF%A2%E5%88%86%E6%95%B0-gt-80%E5%88%86%E7%9A%84%E5%AD%A6%E7%94%9F%E5%90%8D%E5%AD%97%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%88%97%E8%A1%A8%E7%9A%84%E7%AC%AC10-20%E6%9D%A1%E3%80%91"><span class="toc-text">【查询分数&gt;80分的学生名字，查询列表的第10-20条】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%9F%A5%E6%89%BE%E6%89%80%E6%9C%89%E5%88%86%E6%95%B0%E5%A4%A7%E4%BA%8E80%E7%9A%84%E5%AD%A6%E7%94%9F%E3%80%91"><span class="toc-text">【查找所有分数大于80的学生】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%8C%89%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84group-by%E3%80%91"><span class="toc-text">【按字段进行分组group by】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E7%BB%99%E5%AE%9Aid-name-score%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E7%9A%84%E4%BA%BA%E6%95%B0%E3%80%91"><span class="toc-text">【给定id,name,score，统计每一个分数的人数】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E6%9C%80%E6%96%B0-order-by%E9%99%8D%E5%BA%8F%E5%8F%96desc-%E7%9A%84%E5%89%8D%E5%8D%81%E8%A1%8C-limit-%E3%80%91"><span class="toc-text">【数据库查询时间最新(order by降序取desc)的前十行(limit)】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%E3%80%91join%E8%BF%9E%E6%8E%A5-left-join%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="toc-text">【组合两个表】join连接:left join解释一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%9F%A5%E8%AF%A2student%E8%A1%A8%E4%B8%AD%E4%B8%A4%E9%97%A8%E7%A7%91%E6%88%90%E7%BB%A990%E5%88%86%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AD%A6%E7%94%9F%E5%AD%A6%E5%8F%B7%E3%80%91"><span class="toc-text">【查询student表中两门科成绩90分以上的学生学号】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E2%98%86%E6%9F%A5%E5%87%BA%E8%A1%A8%E4%B8%AD%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E3%80%91"><span class="toc-text">【☆查出表中学生成绩最好的学生信息】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E6%9F%A5%E6%89%BEor%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E3%80%91"><span class="toc-text">【查找or删除重复的电子邮箱】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90mysql%E8%AF%AD%E5%8F%A5%EF%BC%9A%E6%9F%A5%E9%87%8D%E5%A4%8D%E5%9F%8E%E5%B8%82%E4%BF%A1%E6%81%AF%E2%80%A6-%E8%BF%94%E5%9B%9E%E8%A1%A8%E4%B8%AD%E6%9C%89%E4%B8%A4%E5%90%8D%E4%BB%A5%E4%B8%8A%E5%AD%A6%E5%91%98%E7%9A%84%E5%9F%8E%E5%B8%82%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%A6%E5%91%98%E4%BF%A1%E6%81%AF%E3%80%91"><span class="toc-text">【mysql语句：查重复城市信息….返回表中有两名以上学员的城市的所有学员信息】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94count-1-%E3%80%81count-%E4%B8%8Ecount-%E5%88%97%E5%90%8D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">sql优化——count(1)、count(*)与count(列名)的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/10/Hexo_txy_CDN/" title="Hexo+Github.io 配置腾讯云CDN"><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/Hexo_txy_CDN_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo+Github.io 配置腾讯云CDN"/></a><div class="content"><a class="title" href="/2022/02/10/Hexo_txy_CDN/" title="Hexo+Github.io 配置腾讯云CDN">Hexo+Github.io 配置腾讯云CDN</a><time datetime="2022-02-10T03:30:00.000Z" title="发表于 2022-02-10 11:30:00">2022-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/09/QA_test/" title="面试QA整理(9)——测试开发相关知识"><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_test_cover_.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(9)——测试开发相关知识"/></a><div class="content"><a class="title" href="/2022/02/09/QA_test/" title="面试QA整理(9)——测试开发相关知识">面试QA整理(9)——测试开发相关知识</a><time datetime="2022-02-09T03:30:00.000Z" title="发表于 2022-02-09 11:30:00">2022-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/08/QA_code/" title="面试QA整理(8)——常考编程题"><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_code_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(8)——常考编程题"/></a><div class="content"><a class="title" href="/2022/02/08/QA_code/" title="面试QA整理(8)——常考编程题">面试QA整理(8)——常考编程题</a><time datetime="2022-02-08T03:30:00.000Z" title="发表于 2022-02-08 11:30:00">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/QA_linux/" title="面试QA整理(7)——linux"><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_linux_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(7)——linux"/></a><div class="content"><a class="title" href="/2022/02/07/QA_linux/" title="面试QA整理(7)——linux">面试QA整理(7)——linux</a><time datetime="2022-02-07T03:30:00.000Z" title="发表于 2022-02-07 11:30:00">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/QA_java/" title="面试QA整理(6)——java"><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/QA_java_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(6)——java"/></a><div class="content"><a class="title" href="/2022/02/06/QA_java/" title="面试QA整理(6)——java">面试QA整理(6)——java</a><time datetime="2022-02-06T03:30:00.000Z" title="发表于 2022-02-06 11:30:00">2022-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xpt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'pO1KsEpccyt4dWMrhqlARlKB-gzGzoHsz',
      appKey: 'tlUclKHXgsPbWNYvnmqg7YQE',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/xpt.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="多发paper,少掉头发,offer多多,升职加薪,健康快乐" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="/%5Bobject%20Object%5D"></script></div></body></html>
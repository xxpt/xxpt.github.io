<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试QA整理(6)——java | 夏普通</title><meta name="author" content="xpt"><meta name="copyright" content="xpt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！ 文档分享的初衷是给师弟师妹们作为参考，主要是适合想去大厂+测试开发岗的朋友们。建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！文章还未精细整理，如存在错误之处，可以邮件or微信反馈给我呀，感激不尽！ 想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百">
<meta property="og:type" content="article">
<meta property="og:title" content="面试QA整理(6)——java">
<meta property="og:url" content="https://xpt.hatake18.top/2022/02/06/QA_java/index.html">
<meta property="og:site_name" content="夏普通">
<meta property="og:description" content="Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！ 文档分享的初衷是给师弟师妹们作为参考，主要是适合想去大厂+测试开发岗的朋友们。建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！文章还未精细整理，如存在错误之处，可以邮件or微信反馈给我呀，感激不尽！ 想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-02-06T03:30:00.000Z">
<meta property="article:modified_time" content="2022-02-08T18:43:41.018Z">
<meta property="article:author" content="xpt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/xpt.jpg"><link rel="canonical" href="https://xpt.hatake18.top/2022/02/06/QA_java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试QA整理(6)——java',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-02-09 02:43:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xpt.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">夏普通</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试QA整理(6)——java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-06T03:30:00.000Z" title="发表于 2022-02-06 11:30:00">2022-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-08T18:43:41.018Z" title="更新于 2022-02-09 02:43:41">2022-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试QA整理(6)——java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-6-——java"><a href="#面试QA整理-6-——java" class="headerlink" title="面试QA整理(6)——java"></a>面试QA整理(6)——java</h1><p>面试官会问你熟悉的语言，我一般都说python，有些面试还会问些java，这里整理的比较少。</p>
<h2 id="面向对象的三大特征：封装性、继承性、多态性。"><a href="#面向对象的三大特征：封装性、继承性、多态性。" class="headerlink" title="面向对象的三大特征：封装性、继承性、多态性。"></a>面向对象的三大特征：封装性、继承性、多态性。</h2><p>封装性在Java当中的体现:</p>
<ul>
<li>1.方法就是一种封装</li>
<li>2.关键字private也是一 种封装</li>
</ul>
<p>封装就是将一 些细节信息隐藏起来，对于外界不可见。</p>
<p>继承是多态的前提，如果没有继承，就没有多态。<br>继承主要解决的问题就是：共性抽取。</p>
<p>多态</p>
<p>一个<strong>对象</strong>拥有多种形态，这就是:<strong>对象的多态性</strong>。<br><strong>多态</strong>： 是指同一行为，具有多个不同表现形式</p>
<p>小明是一个对象,<br>这个对象既有学生形态，也有人类形态。<br>一个对象拥有多种形态，这就是:<br>对象的多态性。</p>
<h2 id="对象的内存分配方式"><a href="#对象的内存分配方式" class="headerlink" title="对象的内存分配方式"></a>对象的内存分配方式</h2><p>Java堆这块内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在堆上分配。</p>
<p>创建对象内存分配</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804124648795.png" alt="image-20210804124648795" style="zoom:33%;" />

<p>Ⅰ、将内存进行了划分，一部分是年轻代（Young区），还有一部分是老年代（Old区）<br>Ⅱ、年轻代也进行了划分，分别是1个Eden区和2个Survivor区；Old区就是整个的一块<br>Ⅲ、new的对象产生在Eden区，当Eden区快满的时候，就会触发GC，这个GC是在Young区的，所以也叫Young GC,Young GC采用的是复制算法，把在Eden区需要删除的打上一个标记，不需要删除的复制到Survivor区（S0或者S1均可，内存大小 S0:S1:E区&#x3D;1：1：8）。<br>为什么要2块Survivor区？因为这两个S区是交替工作的，在E区打完标记后，不需要删除的被放到S0区，然后把E区+S1区一起删除，等下一次E区快满的时候，将不需要删除的被放到S1区，然后把E区+S0区一起删除…如此往复的工作，比将内存一分为二的效率要高一些的（主要是针对 对象的朝生夕死的特点去设计的）<br>Ⅳ、Old区：在每一次的Young GC的时候，存活下来的对象的年龄都会加1，直到年龄到达了？岁，它就不在Survivor区里面进行复制了，而是直接将不需要删除的对象放到Old区里面，因为之前的Young GC都没去掉，说明可能要过很久才能去掉；<br>除了存了年龄大于等于？岁的，还存了大的对象（如：1个1千万大小的int数组），Old区满的时候也会触发GC，Old GC一般也会伴随着Young GC,所以也叫做Full GC,Full GC会引起Stop-The-World,整个Java程序直接暂停，来全力的进行垃圾回收，</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804124511423.png" alt="image-20210804124511423" style="zoom:50%;" />

<h2 id="堆与栈区别"><a href="#堆与栈区别" class="headerlink" title="堆与栈区别"></a>堆与栈区别</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804123956413.png" alt="image-20210804123956413" style="zoom:55%;" />

<p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p>
<p>（2）空间大小不同。<strong>每个进程拥有的栈的大小要远远小于堆的大小</strong>。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，<strong>内存地址由低到高</strong>；栈的生长方向向下，<strong>内存地址由高到低</strong>。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p>
<p>（6）<strong>存放内容不同</strong>。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
<p>从以上可以看到，堆和栈相比，由于大量malloc()&#x2F;free()或new&#x2F;delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p>
<p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池</strong>：其实就是一个容纳多个线程的容器，其中的线程可以<u>反复使用</u>，【执行完一个任务，并不被销毁，而是可以继续执行其他的任务】。<u>省去了频繁创建线程对象的操作</u>，<u>无需反复创建线程而消耗过多资源</u>。</p>
<p><strong>合理利用线程池能够带来三个好处</strong>：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。使用线程池可以进行统一分配、调优和监控。可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下</li>
<li>(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>有三种方式可以用来创建线程：<br>继承Thread类<br>实现Runnable接口<br>应用程序可以使用Executor框架来创建线程池<br><strong>实现Runnable接口这种方式更受欢迎</strong>，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<hr>
<p>方式一、<strong>创建Thread类的子类</strong></p>
<p>实现步骤:</p>
<ul>
<li>1.创建一个Thread类的<strong>子类</strong></li>
<li>2.在Thread类的子类中<strong>重写Thread类中的run方法</strong>,设置线程任务(开启线程要做什么?)</li>
<li>3.创建Thread类的子类<strong>对象</strong></li>
<li>4.调用Thread类中的方法<strong>start方法</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726115133590.png" alt="image-20210726115133590" style="zoom:33%;" />

<p>方式二、<strong>实现Runnable接口</strong></p>
<p>实现步骤:</p>
<p>  1.创建<strong>一个Runnable接口的实现类</strong></p>
<p>  2.在实现类中<strong>重写Runnable接口的run方法</strong>,设置线程任务</p>
<p>  3.<strong>创建一个Runnable接口的实现类对象</strong></p>
<p>  4**.创建Thread类对象**,构造方法中<strong>传递Runnable接口的实现类对象</strong></p>
<p>  5.<strong>调用Thread类中的start方法,开启新的线程</strong>执行run方法</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726115244664.png" alt="image-20210726115244664" style="zoom:33%;" />

<h2 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h2><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p>
<ol>
<li><p>都是上层的抽象层。</p>
</li>
<li><p>都不能被实例化</p>
</li>
<li><p>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。<br>他们的区别如下：</p>
</li>
<li><p><strong>在抽象类中可以写非抽象的方法</strong>，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；<strong>接口中只能有抽象的方法</strong>。</p>
</li>
<li><p><strong>一个类只能继承一个直接父类</strong>，这个父类可以是具体的类也可是抽象类；<strong>但是一个类可以实现多个接口</strong>。</p>
</li>
</ol>
<h2 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h2><p>类是描述，对象是实例。</p>
<p>类与对象的关系<br>●<strong>类是</strong>对一类事物的<strong>描述</strong>,是<strong>抽象</strong>的。<br>●<strong>对象</strong>是一类事物的<strong>实例</strong>，是<strong>具体</strong>的。<br>●类是对象的模板，对象是类的实体。</p>
<p>类:是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</p>
<p>对象:是一类事物的具体体现。<strong>对象是类的一个实例</strong>，必然具备该类事物的属性和行为。</p>
<h2 id="object类中有哪些方法"><a href="#object类中有哪些方法" class="headerlink" title="object类中有哪些方法"></a>object类中有哪些方法</h2><p>boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”</p>
<p>public String toString(): 返回该对象的字符串表示。</p>
<p>void wait()<br>          在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</p>
<p>void notify()<br>          唤醒在此对象监视器上等待的单个线程。<br>          会继续执行wait方法之后的代码</p>
<p> Object类中wait带参方法</p>
<p>​            使用<strong>wait(long     m)<strong>方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒</strong>,就会自动醒来</strong>,线程睡醒进入到Runnable&#x2F;Blocked状态</p>
<p>唤醒的方法:</p>
<p>​    void notify() 唤醒在此对象监视器上等待的<strong>单个线程</strong>。</p>
<p>​    void notifyAll() 唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726114846192.png" alt="image-20210726114846192" style="zoom:50%;" />

<h2 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection<br>    List<br>        ArrayList<br>        LinkedList<br>        Vector</p>
<p>​    Set<br>​        HashSet<br>​            LinkedHashSet<br>​        TreeSet</p>
<p>Map<br>    HashMap<br>        LinkedHashMap</p>
<p>​    TreeMap<br>​    ConcurrentHashMap<br>​    Hashtable<br>数据容器主要分为了两类：</p>
<p>​    Collection: 存放独立元素的序列。</p>
<p>​    Map：存放key-value型的元素对。（这对于需要利用key查找value的程序十分的重要！）</p>
<h2 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h2><h3 id="HashMap的get方法能否判断某个元素是否在map中"><a href="#HashMap的get方法能否判断某个元素是否在map中" class="headerlink" title="HashMap的get方法能否判断某个元素是否在map中?"></a>HashMap的get方法能否判断某个元素是否在map中?</h3><p>HashMap 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，<strong>并允许使用 null 值和 null 键。</strong></p>
<p>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。<br>    • 返回值:V<br>        ○ key存在,返回对应的value值<br>        ○ <strong>key不存在,返回null</strong></p>
<p>boolean containsKey(Object key) 判断集合中是否包含指定的键。<br>    • 包含返回true,不包含返回false</p>
<h2 id="list-相关"><a href="#list-相关" class="headerlink" title="list 相关"></a>list 相关</h2><h3 id="arraylist和linkedlist区别"><a href="#arraylist和linkedlist区别" class="headerlink" title="arraylist和linkedlist区别"></a>arraylist和linkedlist区别</h3><p><strong>ArrayList集合</strong> </p>
<p>java.util.ArrayList 集合数据存储的结构是<strong>数组结构</strong>。元素<strong>增删慢，查找快</strong>，由于日常开发中使用最多的功能为</p>
<p>查询数据、遍历数据，所以 ArrayList 是最常用的集合。 </p>
<p><strong>LinkedList集合</strong> </p>
<p>java.util.LinkedList 集合数据存储的结构是<strong>链表结构</strong>。元素<strong>增删快，查找慢</strong>。 </p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法</p>
<h2 id="数组-Array-和列表-ArrayList-的区别"><a href="#数组-Array-和列表-ArrayList-的区别" class="headerlink" title="数组(Array)和列表(ArrayList)的区别"></a>数组(Array)和列表(ArrayList)的区别</h2><p>Array和ArrayList的不同点：<br>Array可以<strong>包含基本类型和对象类型</strong>，ArrayList<strong>只能包含对象类型</strong>。<br><strong>Array大小是固定的</strong>，<strong>ArrayList的大小是动态变化的。</strong><br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>Java提供了final 关键字,用于修饰不可改变内容。</p>
<p>final:不可改变。可以用于修饰类、方法和变量。</p>
<ul>
<li>类:被修饰的类，不能被继承。</li>
<li>方法:被修饰的方法，不能被重写。</li>
<li>变量:被修饰的变量，不能被重新赋值。</li>
</ul>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>关于static 关键字的使用，它可以用来修饰的成员变量和成员方法，</p>
<p>被修饰的成员是属于类的，而不是单单是属于某个对象的。</p>
<p>也就是说，既然属于类,就可以不靠创建对象来调用了。</p>
<p>凡是本类的对象，都共享同一份。</p>
<p> static关键字最基本的用法是：</p>
<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来</p>
<p>被static修饰的变量、被static修饰的方法统一属于类的<strong>静态资源，是类实例之间共享的，换言之，一处变、处处变</strong>。JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处：</p>
<p>1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了</p>
<p>2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。</p>
<p>3、避免静态资源类无限膨胀，这很好理解。</p>
<h2 id="简述一下servlet的生命周期"><a href="#简述一下servlet的生命周期" class="headerlink" title="简述一下servlet的生命周期"></a>简述一下servlet的生命周期</h2><p>Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段</p>
<p>servlet的生命周期就是从servlet出现到销毁的全过程。主要分为以下几个阶段:<br>加载类- -&gt;实例化(为对象分配空间)- -&gt; 初始化(为对象的属性赋值)一&gt; 请求处理(服务阶段)- &gt; 销毁</p>
<p>（1）加载和实例化</p>
<p>当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接读取该实例响应请求；如果不存在，就创建一个Servlet实例。</p>
<p>（2） 初始化</p>
<p>实例化后，Servlet容器将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）。</p>
<p>（3）服务</p>
<p>初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法。</p>
<p>（4）销毁</p>
<p>当Servlet容器关闭时，Servlet实例也随时销毁。其间，Servlet容器会调用Servlet 的destroy()方法去判断该Servlet是否应当被释放（或回收资源）。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726121132764.png" alt="image-20210726121132764" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726122315229.png" alt="image-20210726122315229" style="zoom:50%;" />

<p>servlet是干什么的</p>
<p>浏览器发送一个HTTP请求，HTTP请求由Web容器分配给特定的Servlet进行处理，Servlet的本质是一个Java对象，这个对象拥有一系列的方法来处理HTTP请求。常见的方法有doGet()，doPost()等。Web容器中包含了多个Servlet，特定的HTTP请求该由哪一个Servlet来处理是由Web容器中的web.xml来决定的。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726122132556.png" alt="image-20210726122132556" style="zoom:50%;" /></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xpt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xpt.hatake18.top/2022/02/06/QA_java/">https://xpt.hatake18.top/2022/02/06/QA_java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xpt.hatake18.top" target="_blank">夏普通</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_reward.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_reward.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay_reward.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_reward.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/05/QA_python/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试QA整理(5)——python</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/07/QA_linux/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试QA整理(7)——linux</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xpt.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xpt</div><div class="author-info__description">wechat: is_xpt</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://xxxpt.blog.csdn.net/"><i class="fab fa-cuttlefish"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:namexiafan@foxmail.com" target="_blank" title="namexiafan@foxmail.com"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">菜单栏搜索可以搜文章标题及内容，最近在更新面试整理。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95QA%E6%95%B4%E7%90%86-6-%E2%80%94%E2%80%94java"><span class="toc-text">面试QA整理(6)——java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E3%80%82"><span class="toc-text">面向对象的三大特征：封装性、继承性、多态性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">对象的内存分配方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="toc-text">堆与栈区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-text">线程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">创建线程的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">抽象类与接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">类和对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-text">object类中有哪些方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java 容器都有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E7%9B%B8%E5%85%B3"><span class="toc-text">Map相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8map%E4%B8%AD"><span class="toc-text">HashMap的get方法能否判断某个元素是否在map中?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list-%E7%9B%B8%E5%85%B3"><span class="toc-text">list 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E5%92%8Clinkedlist%E5%8C%BA%E5%88%AB"><span class="toc-text">arraylist和linkedlist区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">数组(Array)和列表(ArrayList)的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">final关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">static关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bservlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">简述一下servlet的生命周期</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/09/QA_test/" title="面试QA整理(9)——测试开发相关知识"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(9)——测试开发相关知识"/></a><div class="content"><a class="title" href="/2022/02/09/QA_test/" title="面试QA整理(9)——测试开发相关知识">面试QA整理(9)——测试开发相关知识</a><time datetime="2022-02-09T03:30:00.000Z" title="发表于 2022-02-09 11:30:00">2022-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/08/QA_code/" title="面试QA整理(8)——常考编程题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(8)——常考编程题"/></a><div class="content"><a class="title" href="/2022/02/08/QA_code/" title="面试QA整理(8)——常考编程题">面试QA整理(8)——常考编程题</a><time datetime="2022-02-08T03:30:00.000Z" title="发表于 2022-02-08 11:30:00">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/QA_linux/" title="面试QA整理(7)——linux"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(7)——linux"/></a><div class="content"><a class="title" href="/2022/02/07/QA_linux/" title="面试QA整理(7)——linux">面试QA整理(7)——linux</a><time datetime="2022-02-07T03:30:00.000Z" title="发表于 2022-02-07 11:30:00">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/QA_java/" title="面试QA整理(6)——java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(6)——java"/></a><div class="content"><a class="title" href="/2022/02/06/QA_java/" title="面试QA整理(6)——java">面试QA整理(6)——java</a><time datetime="2022-02-06T03:30:00.000Z" title="发表于 2022-02-06 11:30:00">2022-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/05/QA_python/" title="面试QA整理(5)——python"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试QA整理(5)——python"/></a><div class="content"><a class="title" href="/2022/02/05/QA_python/" title="面试QA整理(5)——python">面试QA整理(5)——python</a><time datetime="2022-02-05T03:30:00.000Z" title="发表于 2022-02-05 11:30:00">2022-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xpt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="/%5Bobject%20Object%5D"></script></div></body></html>
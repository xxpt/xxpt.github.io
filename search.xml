<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试QA整理(1)——计算机网络</title>
    <url>/2022/02/01/QA_network/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-1-——计算机网络"><a href="#面试QA整理-1-——计算机网络" class="headerlink" title="面试QA整理(1)——计算机网络"></a>面试QA整理(1)——计算机网络</h1><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="请你来说一说http协议"><a href="#请你来说一说http协议" class="headerlink" title="请你来说一说http协议"></a>请你来说一说http协议</h3><p>HTTP (Hyper Text Transfer Protocol,超文本传输协议)</p>
<p>是用于web服务器和本地浏览器之间传输文件的传输协议，</p>
<p>是一个基于请求与响应模式的、无状态的、应用层的协议，</p>
<p>是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）的协议</p>
<p>HTTP协议工作于客户端-服务端架构之上。</p>
<p>浏览器作为HTTP客户端通过URL，向HTTP服务端，即WEB服务器发送所有请求。Web服务器根据接收到的请求，向客户端发送响应信息。</p>
<p>HTTP工作流程</p>
<p>1、客户端与服务器建立TCP连接。<br>2、客户端向服务器发出请求。<br>3、服务器接收到客户端的请求，根据请求向客户端返回响应内容。<br>4、客户端接收服务器的响应内容，解析内容在前端展示;然后客户端与服务断开连接。</p>
<p>HTTP协议特点</p>
<p>1、<strong>简单快速</strong>:客户向服务器请求服务时，只需传送请求方法和路径。</p>
<p>2、灵活: HTTP允许传输<strong>任意类型</strong>的数据对象。</p>
<p>3、**无状态，不保存状态:**无状态是指协议对于事务处理没有记忆能力。缺少状态意味着：如果后续处理需要前面的信息，则它必须重传。</p>
<p>4、<strong>无连接的</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。也就是服务器处理完一次请求后会关闭连接。</p>
<p>5、支持B&#x2F;S及C&#x2F;S模式。【支持客户端C&#x2F;服务器S模式，浏览器B&#x2F;服务器S模式】</p>
<p>6、默认端口80</p>
<p>7、基于TCP&#x2F;IP通信协议</p>
<h3 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h3><p>1、客户端与服务器建立TCP连接。<br>2、客户端向服务器发出请求。<br>3、服务器接收到客户端的请求，根据请求返回响应内容。<br>4、客户端接收服务器的响应内容，解析内容在前端展示;然后客户端与服务<br>器断开连接。</p>
<h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><p>1、<strong>简单快速</strong>:客户向服务器请求服务时，只需传送请求方法和路径。</p>
<ul>
<li>请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。</li>
<li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
</ul>
<p>2、灵活: HTTP允许传输<strong>任意类型</strong>的数据对象。</p>
<ul>
<li>正在传输的类型由Content-Type加以标记。</li>
</ul>
<p>3、**无状态，不保存状态:**无状态是指协议对于事务处理没有记忆能力。缺少状态意味着：如果后续处理需要前面的信息，则它必须重传。</p>
<ul>
<li>缺点:可能导致每次连接传送的数据量增大。</li>
<li>优点:在服务器不需要先前信息时应答较快，减少服务器CPU和内存的消耗。</li>
<li>引入cookie和session机制:Cookie在客户端记录信息确定用户身份，Session在服务器端记录信息确定用户身份。</li>
</ul>
<p>4、<strong>无连接的</strong>:限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p>
<ul>
<li>缺点:每次请求都要建立\断开TCP连接，通信量开销增大。</li>
<li>优点:采用这种方式可以节省传输时间。</li>
<li>后续引进持久连接(HTTP keep-alive) :在一次TCP连接中可以持续发送多份数据而不会断开连接，减少tcp连接建立次数;一般服务端会设置keep- alive timeout最大连接数</li>
<li>keep- alive timeout:传送完后超过这个时间就关闭连接</li>
<li>最大连接数:到达最大连接数后，有新请求发起连接，未达到超时也会关闭前面的连接</li>
</ul>
<p>5、支持B&#x2F;S及C&#x2F;S模式。【支持客户端C&#x2F;服务器S模式，浏览器B&#x2F;服务器S模式】</p>
<p>6、默认端口80</p>
<p>7、基于TCP&#x2F;IP通信协议，</p>
<ul>
<li>HTTP使用的是可靠的数据传输协议(底层是tcp协议，确保顺序内容的正确，确保没有丢包)，因此<br>即使数据来自地球的另- -端，它也能够确保数据在传输的过程中不会被损坏或产生混乱。这样，用户在<br>访问信息时就不用担心其完整性了，因此对用户来说，这是件好事。</li>
</ul>
<h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><p>1、被窃取: Http通信使用明文，传输过程中没有任何的加密措施，可能会被窃听。<br>2、被伪装:在传输过过程中，不验证通信方的身份，这中间就有可能被伪装<br>3、被篡改: Http只是对报文进行了解析，并没有对其进行完整的校验，所以无法验证报文<br>的完整形，可能被遭篡改</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li>
<li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li>
<li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li>
</ul>
<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><p>➢HTTP报文是由一行一行的简单字符串组成的。<br>➢HTTP报文都是纯文本，不是二进制代码，所以人们可以很方便地对其进行读写。<br>➢从Web客户端发往Web服务器的HTTP报文称为请求报文(request message)<br>➢从服务器发往客户端的报文称为响应报文(response message)。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721004305325.png" alt="image-20210721004305325" style="zoom:50%;" />

<p><strong>一个http请求报文由请求行（request line）、请求头部（header）、空行和请求数据4部分组成。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/2012072810301161.png" alt="img"></p>
<p><strong>一个http响应由状态行、响应头部、空行和响应数据4部分组成。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/2012072810301162.png" alt="img"></p>
<h3 id="HTTP常见的请求头里有什么内容？"><a href="#HTTP常见的请求头里有什么内容？" class="headerlink" title="HTTP常见的请求头里有什么内容？"></a>HTTP常见的请求头里有什么内容？</h3><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721003915186.png" alt="image-20210721003915186" style="zoom:50%;" />

<ul>
<li><strong>HTTP请求方式</strong>，请求Web服务器的目录地址，HTTP协议版本</li>
<li><strong>Accept:浏览器可接受的数据类型</strong>;<ul>
<li>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</li>
</ul>
</li>
<li>Accept-Charset:浏览器可接受的字符集;</li>
<li><strong>Accept-Encoding:浏览器能够进行解码的数据编码方式</strong>，比如gzip。 Servlet能够向支持gzip的浏<br>览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间; .</li>
<li><strong>Accept-Language:浏览器所希望的语言种类</strong>，当服务器能够提供一种以上的语言版本时要用到;</li>
<li>Authorization:授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中;</li>
<li><strong>Connection:表示是否需要持久连接</strong>。如果Servlet看 到这里的值为”<strong>Keep-Alive</strong>“,或者看到请求使<br>用的是HTTP 1.1 <strong>(HTTP 1.1默认进行持久连接</strong>)，它就可以利用持久连接的优点，当页面包含多个元素<br>时(例如Applet, 图片)，显著地减少下载所需要的时间。要实现这一点， Servlet需要在应答中发送一<br>个Content-Length头，最简单的实现方法是:先把内容写入ByteArrayOutputStream,然后在正式写出<br>内容之前计算它的大小;<ul>
<li>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li>
</ul>
</li>
<li><strong>Content-Length:表示请求消息正文的长度;</strong></li>
<li><strong>Cookie:这是最重要的请求头信息之一;</strong></li>
<li>From:请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它;</li>
<li><strong>Host:初始URL中的主机和端口;</strong></li>
<li>If-Modified- Since:只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304”Not<br>Modified”应答;</li>
<li>Pragma:指定”no- cache”值表示服务器必须返回-个刷新后的文档，即使它是代理服务器而且已经<br>有了页面的本地拷贝;</li>
<li>Referer:包含一个URL,用户从该URL代表的页面出发访问当前请求的页面。</li>
<li><strong>User-Agent:浏览器类型</strong>，如果Servlet返回的内容与浏览器类型有关则该值非常有用;</li>
<li>UA-Pixels, UA-Color, UA-OS, UA-CPU: 由某些版本的IE浏览器所发送的非标准的请求头，表示<br>屏幕大小、颜色深度、操作系统和CPU类型。</li>
</ul>
<h3 id="HTTP常见的响应头里有什么内容？"><a href="#HTTP常见的响应头里有什么内容？" class="headerlink" title="HTTP常见的响应头里有什么内容？"></a>HTTP常见的响应头里有什么内容？</h3><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721003935260.png" alt="image-20210721003935260" style="zoom:50%;" />



<ul>
<li><strong>Allow</strong>:服务器支持哪些请求方法(如GET、POST等) ;</li>
<li><strong>Content-Encoding</strong>:<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式<ul>
<li>文档的编码(Encode) 方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows.上的IE4、IE 5才支持它。因此,Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept-Encoding’”)) 检查浏览器是否支持gzip，为支持gzip的浏览 器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面;</li>
</ul>
</li>
<li><strong>Content-Length:表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据</strong>。如果你想<br>要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram,完成后查看其大小，然后把该值<br>放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream)发送内容;</li>
<li><strong>Content-Type:<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</strong>Servlet默认为text&#x2F;plain, 但通常需要显式地<br>指定为text&#x2F;html。由于经常要设置Content-Type,因此HttpServletResponse提供了 一个专用的方法<br>setContentTyep。可在web.xml文件中配置 扩展名和MIME类型的对应关系;</li>
<li><strong>Date:当前的GMT时间。</strong>你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦;</li>
<li>Expires:指明应该在什么时候认为文档已经过期，从而不再缓存它。</li>
<li>Last-Modified:文档的最后改动时间。客户可以通过lf-Modified- Since请求头提供一个日期, 该请<br>求将被视为一个条件GET,只有改动时间迟于指定时间的文档才会返回，否则返回-个304 (Not<br>Modified)状态。, Last-Modified也可用setDateHeader方法来设置;</li>
<li>Location:表示客户应当到哪里去提取文档。Location通常不是 直接设置的，而是通过<br>HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302;</li>
<li>Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。</li>
</ul>
<h2 id="什么是Cookie？Cookie用来干什么的？"><a href="#什么是Cookie？Cookie用来干什么的？" class="headerlink" title="什么是Cookie？Cookie用来干什么的？"></a>什么是Cookie？Cookie用来干什么的？</h2><p>1.Cookie是什么？</p>
<p>cookie是浏览器支持的一种本地存储机制。一般由服务端设置生成，在响应请求时被自动存储在浏览器中。</p>
<p>2.为什么会有Cookie的存在？</p>
<p>cookie是为了辨别用户身份的。我们知道HTTP本身是无状态的协议，服务端不会记得是谁向它发来的请求。但在某些情况下我们需要记住用户在未登录的状态下浏览了什么，比如淘宝。这时候就需要借助我们的Cookie了。 客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等较验。</p>
<h2 id="cookie-amp-session的用处？他们的区别和联系。cookie为什么不安全"><a href="#cookie-amp-session的用处？他们的区别和联系。cookie为什么不安全" class="headerlink" title="cookie &amp; session的用处？他们的区别和联系。cookie为什么不安全"></a>cookie &amp; session的用处？他们的区别和联系。cookie为什么不安全</h2><p>http是无状态协议，——服务器不记录谁访问过它，减少服务器的压力(减少维护信息)<br>那么服务端如何识别特定的客户端呢?</p>
<ul>
<li>1.每次http请求的时候，客户端（在请求头里）都会发送相应的cookie信息到服务端</li>
<li>2.实际.上大多数应用都是用cookie来实现session跟踪的，</li>
<li><strong>第一次创建session的时候， 服务端会在http协议中告诉客服端，需要在cookie里记录一个sessionid, 以后每次请求把这个id发送到服务器，我就知道你是谁了</strong></li>
<li>3.如果客户端禁用cookie怎么办?一般这种情况下，会使用一种叫做url重写的技术来进行会话跟踪，即<br>每次http交互，url后面都会被附加上一个诸如sid&#x3D;**的参数，服务端据此来识别用户。</li>
</ul>
<p>虽然Cookie和Session都可以跟踪客户端的访问记录，但是它们的工作方式显然是不同的，</p>
<p><strong>【cookie为什么不安全】</strong></p>
<ul>
<li>Cookie通过把所有要保存的数据通过HTTP协议的头部从客户端传递到服务端，又从服务端再传回到客<br>户端，<strong>所有的数据都存储在客户端的浏览器里，所以这些Cookie 数据可以被访问到</strong>，不仅可以查看<br>Cookie,甚至可以通过插件添加、修改Cookie, 所以Cookie 的安全性受到了很大的挑战。</li>
<li>相比较而言Session的安全性要高很多，因为Session是将数据保存在服务端，只是通过Cookie传递<br>一个SessionID而已，所以Session 更适合存储用户隐私和重要的数据。</li>
</ul>
<p><strong>Cookie和Session的区别</strong></p>
<p><strong>简单阐述：</strong></p>
<p>cookie 是把用户的数据写给用户浏览器， session 是把用户的数据写到用户独占的 session 中</p>
<ul>
<li>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正  Cookie中的内容。</li>
<li>而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险</li>
</ul>
<p> session 对象由服务器创建，开发人员可以调用 request 对象的 getsession 方法得到 session 对象<br>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗,<strong>如果主要考虑到安全应当使用 session。</strong>【隐私策略的不同】<br>session 会在一定时间内保存在服务器上。 当访问增多，会比较占用你服务器的性能，<strong>如果主要考虑到减轻服务器性能方面，应当使用 COOKIE</strong>  【服务器压力的不同】</p>
<p><strong>详细阐述：</strong></p>
<p><strong>1.存取方式的不同</strong></p>
<ul>
<li>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。</li>
<li>Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比较艰难的。</li>
<li>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。</li>
<li>Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</li>
</ul>
<p><strong>2.隐私策略的不同</strong></p>
<ul>
<li>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正  Cookie中的内容。</li>
<li>而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li>
<li>假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信 息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。</li>
<li>而假如选择Session就省事多了，反正是放在服务器上，Session里 任何隐私都能够有效的保护。</li>
</ul>
<p><strong>3.有效期上的不同</strong></p>
<ul>
<li>使用过Google的人都晓得，假如登录过Google,则Google的登录信息 长期有效。用户不用每次访问都<br>重新登录，Google会持久地记载该用户的登录信息。</li>
<li>要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。</li>
<li>由于Session依赖于名为JSESSIONID的Cookie,而Cookie JSESSIONID的过期时间默许为-1，只需关闭<br>了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完<br>成。</li>
<li>而且假如设置Session的超时时间过长，<strong>服务器累计的Session就会越多，越容易招致内存溢出</strong>。</li>
</ul>
<p><strong>4.服务器压力的不同</strong></p>
<ul>
<li>Session是保管在服务器端的，每个用户都会产生一个Session。 假如并发访问的用户十分多，会产生十<br>分多的Session,耗费大量的内存。</li>
<li>因而像Google、Baidu、 Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。</li>
<li>而Cookie保管在客户端，不占用服务器资源。</li>
<li>假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、 Sina来说， Cookie或许是唯一 的选择 。</li>
</ul>
<p><strong>5.浏览器支持的不同</strong></p>
<ul>
<li>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie,或者不支持Cookie,则会话跟踪会失<br>效。<ul>
<li>关于WAP上的应用，常规的Cookie就派不上用场了。</li>
</ul>
</li>
<li>假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。 需要注意的是一切的用到<br>Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。<ul>
<li>关于WAP应用来说，Session+URL地址重写或许是它唯一的选择 。</li>
</ul>
</li>
<li>假如客户端支持Cookie,则Cookie既能够设为本浏览器窗口以及子窗口内有效(把过期时间设为-1)，<br>也能够设为一切阅读器窗口内有效(把过 期时间设为某个大于0的整数)。 但Session只能在本阅读器窗<br>口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。(IE8 下不同<br>窗口Session相干)</li>
</ul>
<p><strong>6.跨域支持上的不同</strong></p>
<ul>
<li>Cookie可以通过如下方式实现跨域名访问，例如将domain属性设置为”.xxx.com”,则”a.xxx.com”和<br>  “b.xxx.com”均能够访问该Cookie。事实上只要是以.xx.com”结尾的域名均可访问。跨域名Cookie如今<br>  被普遍用在网络中，例如Google、 Baidu、 Sina等。 </li>
<li>而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</li>
</ul>
<h2 id="HTTP请求命令，http有哪些请求方式，HTTP方法"><a href="#HTTP请求命令，http有哪些请求方式，HTTP方法" class="headerlink" title="HTTP请求命令，http有哪些请求方式，HTTP方法"></a>HTTP请求命令，http有哪些请求方式，HTTP方法</h2><p>➢HTTP支持几种不同的请求命令,这些命令被称为HTTP方法(HTTP method)。<br>➢每条HTTP请求报文都包含一个方法。<br>➢这个方法会告诉服务器要执行什么动作(获取一个Web页面、运行一个网关程序、删除一 个文件等)<br>常见的HTTP方法:</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721001617248.png" alt="image-20210721001617248" style="zoom:50%;" />

<p>HTTP中的<strong>GET，POST，PUT，DELETE</strong>就对应着对这个资源的<strong>查，改，增，删</strong>4个操作。</p>
<h2 id="☆GET和POST的区别"><a href="#☆GET和POST的区别" class="headerlink" title="☆GET和POST的区别"></a>☆GET和POST的区别</h2><ol>
<li><p><strong>GET重点在从服务器上获取资源</strong>，一般用于获取&#x2F;查询资源信息，<strong>是无副作用的，是幂等的，且可缓存</strong>；</p>
<p><strong>而POST重点在向服务器发送数据</strong>，一般用于更新资源信息。<strong>有副作用，非幂等，不可缓存</strong>。</p>
</li>
<li><p><strong>post比get安全性更高。</strong><br><strong>Get通过URL来传输数据，因为URL是可见的，可能会泄露私密信息，如密码等</strong></p>
<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如<code>http://127.0.0.1/est/login. action?name= admin&amp;password=admin</code>这个过程用户是可见的</p>
<p><strong>POST通过URL和请求体requrest body传输数据</strong>，将字段与对应值封存在请求体中发送给服务器。<strong>在请求体中的数据，我们是无法直接观测到的。</strong><br>在安全性上，GET没有POST安全。但是他们都不是绝对安全。因为POST中的数据，可以通过抓包获取</p>
</li>
<li><p><strong>在数据大小上，GET有限制，而POST没有上限。</strong><br>Get传输的数据量小，因为URL长度受浏览器及服务器的限制，但效率较高；<br>Post可以传输大量数据，所以上传文件时都用Post方式; </p>
</li>
<li><p>对于参数的数据类型<br><strong>GET只接受ASCII字符，</strong> 向服务器传的中文字符可能会乱码<br><strong>而POST没有限制</strong></p>
</li>
<li><p>GET请求会被浏览器主动cache（缓存），而POST不会，除非手动设置。</p>
</li>
<li><p>GET请求只能进行url编码，而POST支持多种编码方式。</p>
</li>
<li><p><strong>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</strong></p>
<p>其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了</p>
</li>
<li><p>GET在浏览器<strong>回退时是无害的</strong>，而POST会再次提交请求。</p>
</li>
<li><p>GET产生的URL地址<strong>可以被Bookmark（可收藏为书签）</strong>，而POST不可以。</p>
</li>
</ol>
<p>POST 方法会产生两个TCP数据包？</p>
<ul>
<li>header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</li>
<li>简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。<br>长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。但是，</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox，Chrome都只发送一次。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803104646572.png" alt="image-20210803104646572" style="zoom:67%;" />

<h2 id="get和post在哪里传参"><a href="#get和post在哪里传参" class="headerlink" title="get和post在哪里传参"></a>get和post在哪里传参</h2><h2 id="☆get的幂等性由什么保证？（安全和幂等"><a href="#☆get的幂等性由什么保证？（安全和幂等" class="headerlink" title="☆get的幂等性由什么保证？（安全和幂等"></a>☆get的幂等性由什么保证？（安全和幂等</h2><ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p><strong>GET 方法就是安全且幂等的</strong>，get通常都是查询，不涉及数据修改。因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
<p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<p>　(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>注意：这里安全的含义仅仅是指是非修改信息。</p>
<p>　(2).幂等的意味着对同一URL的多个请求，不应有副作用，不会改变资源。</p>
<p>这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。比如：访问百度，这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用。</p>
<h2 id="☆常见响应状态码"><a href="#☆常见响应状态码" class="headerlink" title="☆常见响应状态码"></a>☆<strong>常见响应状态码</strong></h2><p>例如：200（成功）&#x2F;300（重定向别的地方）&#x2F;400（请求语法错误）&#x2F;500（服务器异常）</p>
<p>1xx:指示信息，表示请求已接收，还需要后续操作，继续处理。<br>2xx:成功，表示请求已被成功接收、理解、接受。<br>3xx:重定向，要完成请求必须进行更进一步的操作。客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源<br>4xx:客户端错误，请求有语法错误或请求无法实现。<br>5xx:服务器端错误，服务器未能实现合法的请求。</p>
<p>「<strong>200 OK</strong>」是最常见的成功状态码，如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p>
<p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
<p>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p>
<p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
<p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p>
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
<p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
<p>「<strong>500 Internal Server Error</strong>」是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，<strong>表示服务器自身工作正常，访问后端服务器发生了错误。</strong></p>
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721001904852.png" alt="image-20210721001904852" style="zoom:67%;" />

<h2 id="浏览器输入一个URL之后，网络各层发生了什么？（输入url涉及哪些协议、DNS过程"><a href="#浏览器输入一个URL之后，网络各层发生了什么？（输入url涉及哪些协议、DNS过程" class="headerlink" title="浏览器输入一个URL之后，网络各层发生了什么？（输入url涉及哪些协议、DNS过程"></a>浏览器输入一个URL之后，网络各层发生了什么？（输入url涉及哪些协议、DNS过程</h2><p>访问一个完整http请求会经历哪些步骤?<br><strong>一个完整的http请求主要有六个步骤:</strong></p>
<ul>
<li>1.输入url后，将url发送给dns, 域名解析(DNS服务) ，根据域名找到服务器的ip地址,和端口号</li>
<li>2.发起TCP的3次握手,</li>
<li>3.建立TCP连接后发起http请求，发送header, body等信息</li>
<li>4.服务器端响应http请求，将资源封装成响应包返回，服务器返回完了之后会进行四次挥手，关闭连接，浏览器得到html代码</li>
<li>5.浏览器解析html代码，并请求html代码中的资源，浏览器拿到返回包做解析，比如会收到图片，js, css等，然后再次发送http请求，拿到这些数据，最终显示出这些内容</li>
<li>6.浏览器对页面进行渲染呈现给用户。</li>
</ul>
<p><strong>发送端由应用层往下走，接收端由数据链路层往上走，步骤如下：</strong>  </p>
<p>１、浏览器输入url，若协议为 http，<br>２、应用层 DNS 解析，返回对应的 ip 地址（DNS协议，DNS服务器是基于UDP的，因此会用到UDP协议。<br>３、<strong>应用层客户端发送 http 请求</strong>，（http协议<br>４、传输层传输报文建立tcp连接，（TCP协议<br>５、网络层 ip 查询mac地址（IP协议，ARP协议<br>６、数据到达数据链路层<br>7、物理层：物理传输bit。<br>8、服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。<br>9、关闭连接，TCP四次挥手。<br>10、客户端解析HTTP响应报文，浏览器开始显示HTML</p>
<p><strong>输入url涉及哪些协议</strong></p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到<strong>DNS协议</strong>，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。<strong>DNS服务器是基于UDP的，因此会用到UDP协议。</strong></p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到<strong>http协议。</strong>http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到<strong>TCP协议</strong>。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。</p>
<p>TCP的数据包然后会发送给IP层，<strong>用到IP协议</strong>。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目<strong>的IP地址的物理地址，有需要ARP协议</strong>。<strong>ARP（地址解析协议）</strong>ARP解决的是同一个局域网内，主机或路由器的IP地址和MAC地址的映射问题。</p>
<p><strong>网络各层发生了什么？</strong>（详细描述）<br>1、<strong>查询DNS，获取域名对应的IP</strong>。<br>（1）检查浏览器缓存、检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。<br>（2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。<br>（3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：<br>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。<br>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。<br>（4）如果本地DNS服务器也失效：<br>如果未采用转发模式（迭代），<strong>本地DNS就把请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<a href="http://baidu.com)的ip给本地dns服务器,**循环往复直至查询到映射**,将解析结果返回本地dns服务器,再由本地dns服务器返回解析结果,查询完成./">http://baidu.com）的IP给本地DNS服务器，**循环往复直至查询到映射**，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</a></p>
<p>如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</p>
<p>2、<strong>得到目标服务器的IP地址及端口号（http 80端口，https 443端口）</strong>，会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文：<br>（1）应用层：客户端发送HTTP请求报文。<br>（2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。<br>（3）网络层：（加入IP头）路由寻址。<br>（4）数据链路层：（加入frame头）传输数据。<br>（5）物理层：物理传输bit。<br>3、服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。<br>4、关闭连接，TCP四次挥手。<br>5、客户端解析HTTP响应报文，浏览器开始显示HTML</p>
<h2 id="理解URL，以及URL的组成部分"><a href="#理解URL，以及URL的组成部分" class="headerlink" title="理解URL，以及URL的组成部分"></a>理解URL，以及URL的组成部分</h2><p>Uniform Resoure Locator<br>资源定位符</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721165414309.png" alt="image-20210721165414309" style="zoom:33%;" />

<p>就以下面这个URL为例，介绍下普通URL的各部分组成</p>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>**1.**协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符</p>
<p>**2.**域名部分：该URL的域名部分为“aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721170124056.png" alt="image-20210721170124056" style="zoom:25%;" />

<p>**3.**端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p>**4.**虚拟目录部分：从域名后的第一个“&#x2F;”最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721165708925.png" alt="image-20210721165708925" style="zoom:25%;" />

<p>**5.**文件名部分：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721165818013.png" alt="image-20210721165818013" style="zoom:25%;" />

<p>**6.**锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721165856430.png" alt="image-20210721165856430" style="zoom:25%;" />

<p>**7.**参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<h2 id="☆http和https的区别"><a href="#☆http和https的区别" class="headerlink" title="☆http和https的区别"></a>☆http和https的区别</h2><ol>
<li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是使用密钥进行加密（经过SSL&#x2F;TLS加密）的，所以HTTPS具有更高的安全性。</li>
<li>HTTPS部署成本高，HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书，一般免费证书较少，功能越强的证书，越贵，因而需要一定费用。</li>
<li>HTTPS握手阶段延时较高：HTTPS在TCP三次握手阶段之后，还需要进行SSL&#x2F;TLS的handshake（握手），协商加密使用的对称加密密钥，有统计延长大概50%</li>
<li>https会更多占用服务器的连接资源：由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</li>
<li>https在缓存方面，不如http</li>
<li>HTTP协议端口是80，HTTPS协议端口是443</li>
</ol>
<h3 id="☆ssl具体握手过程（https流程，具体是怎么连接的）https是如何实现安全的"><a href="#☆ssl具体握手过程（https流程，具体是怎么连接的）https是如何实现安全的" class="headerlink" title="☆ssl具体握手过程（https流程，具体是怎么连接的）https是如何实现安全的"></a>☆ssl具体握手过程（https流程，具体是怎么连接的）https是如何实现安全的</h3><p>https是如何实现安全的</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。混合加密的方式实现信息的机密性，解决了窃听的风险。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示。摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</li>
<li><strong>身份证书</strong>：证明服务端是真的服务端。将服务器公钥放入到数字证书中，解决了冒充的风险。</li>
</ul>
<p>SSL&#x2F;TLS 协议基本流程：（前两步也就是 SSL&#x2F;TLS 的建立过程，也就是握手阶段</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>！！！！！！<strong>SSL&#x2F;TLS 协议建立的详细流程：</strong></p>
<p>（1）<strong>client_hello</strong>，客户端发起请求，<br>以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息<br>（2）<strong>server_hello+server_certificate+sever_hello_done</strong><br>server_hello, 服务端产生第一次应答，服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法、随机数等，其中随机数用于后续的密钥协商;<br>server_certificates, 服务端向客户端发送自己<strong>的证书，用于身份验证与密钥交换</strong>；客户端验证证书的合法性，如果验证通过才会进行后续通信。<br>server_hello_done，通知客户端 server_hello 信息发送结束;（一个空的指令，仅表示结束。）<br>（3）<strong>client_key_exchange+change_cipher_spec+encrypted_handshake_message</strong><br>client_key_exchange，合法性验证通过之后，客户端计算产生一个随机数字 Pre-master，并<strong>用证书公钥加密</strong>，发送给服务器;（此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数与自己计算产生的 Pre-master，计算得到协商密钥;）<br>change_cipher_spec，这步是一个提示，相当于客户端告诉服务端，后续的通信都采用协商的密钥与算法进行加密通信;<br>encrypted_handshake_message，该报文包含连接至今全部报文的整体校验值，采用协商密钥与算法进行加密，然后发送给服务器用于数据与握手验证;（这次握手协商是否能够成功， 要以服务器是否能够正确解密该报文作为判定标准）<br>（4）<strong>change_cipher_spec+encrypted_handshake_message</strong><br>服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数，计算得到协商密钥。然后解密客户端发送的报文，验证数据和密钥正确性;<br>验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;<br> encrypted_handshake_message, 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥与算法加密并发送到客户端;<br>（5）<strong>握手结束</strong><br>客户端采用协商密钥解密服务器发来的报文，验证服务器发送的数据和密钥，验证通过则握手完成，SSL连接就算建立完成 。<br>（6）<strong>加密通信</strong>，  开始使用协商密钥与算法进行加密通信。</p>
<hr>
<p>下图为wireshark中捕获的一个完整的握手过程，29为客户端，193为服务端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803085733180.png" alt="image-20210803085733180"></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803091652264.png" alt="image-20210803091652264" style="zoom:50%;" />

<h3 id="https如何验证证书"><a href="#https如何验证证书" class="headerlink" title="https如何验证证书"></a>https如何验证证书</h3><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>这就存在些问题，如何保证公钥不被篡改和信任度？</p>
<p>所以这里就需要借助第三方权威机构 <code>CA</code> （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210807221644916.png" alt="image-20210807221644916" style="zoom:43%;" />

<h3 id="https为什么要先非对称再对称"><a href="#https为什么要先非对称再对称" class="headerlink" title="https为什么要先非对称再对称"></a>https为什么要先非对称再对称</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<h3 id="客户端在使用HTTPS方式与Web服务器通信时的步骤"><a href="#客户端在使用HTTPS方式与Web服务器通信时的步骤" class="headerlink" title="客户端在使用HTTPS方式与Web服务器通信时的步骤"></a>客户端在<strong>使用HTTPS方式与Web服务器通信时</strong>的步骤</h3><p>　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>　（3）客户端的浏览器与Web服务器开始协商SSL&#x2F;TLS连接的安全等级，也就是信息加密的等级。</p>
<p>　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>　（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721104642241.png" alt="image-20210721104642241" style="zoom:33%;" />



<p>http明文传输，不安全。传输过程中被截获直接就能读取信息</p>
<p>为解决这个问题就在http的基础上加入SSL协议。SSL,安全套接字协议，它是靠证书来验证服务端的身份，并在本地机和服务端之间架起一条通道。</p>
<p>简单说，你使用https访问一个网站，这网站会给你发一个证书。过证书告诉你，这网站没问题。</p>
<p>然后网站生成一个箱子，还有二把钥匙。然后把箱子和其中一把钥匙给你，网站自己留另一把。</p>
<p>然后你把信息放箱子里加密了,再用钥匙锁上，发给网站。网站接收之后，它再用另一把钥匙打开箱子，拿到信息。困为你的信息被SSL套住了,坏人中途劫持信息，也打不开。</p>
<h3 id="HTTPS优点和缺点"><a href="#HTTPS优点和缺点" class="headerlink" title="HTTPS优点和缺点"></a>HTTPS优点和缺点</h3><p>HTTPS优点：</p>
<ul>
<li><p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
</li>
<li><p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
</li>
</ul>
<p>HTTPS缺点：</p>
<ul>
<li><p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
</li>
<li><p>HTTPS部署成本高：</p>
<ul>
<li>HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；</li>
<li>由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</li>
</ul>
</li>
</ul>
<p>HTTPS缺点：</p>
<ul>
<li>SSL证书是要收费的。而且功能越强的证书，越贵</li>
<li>SSL会延长页面的加载时间，有统计延长大概50%</li>
<li>https在缓存方面，不如http</li>
<li>https会更多占用服务器的连接资源</li>
<li>https在面对黑客攻击、Dos拒绝服务攻击等方面也没啥作用</li>
</ul>
<h3 id="SSL与TLS"><a href="#SSL与TLS" class="headerlink" title="SSL与TLS"></a>SSL与TLS</h3><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p>
<p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p>
<h2 id="HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变"><a href="#HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804141651771.png" alt="image-20210804141651771" style="zoom:40%;" />

<h3 id="HTTP-x2F-1-1-相比-HTTP-x2F-1-0-性能上的改进："><a href="#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-性能上的改进：" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进："></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</h3><ul>
<li><strong>使用 TCP 长连接</strong>的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li><strong>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去</strong>，可以减少整体的响应时间。</li>
</ul>
<p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p>
<ul>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</li>
</ul>
<h3 id="HTTP-x2F-1-1-的性能瓶颈，HTTP-x2F-2-做了什么优化？"><a href="#HTTP-x2F-1-1-的性能瓶颈，HTTP-x2F-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优化？</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<p><em>1. 头部压缩</em></p>
<p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
<p><em>2. 二进制格式</em></p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。</p>
<p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p>
<p><em>3. 数据流</em></p>
<p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流（<code>Stream</code>）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>
<p><em><strong>4. 多路复用</strong></em></p>
<p>HTTP&#x2F;2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p>
<p>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p>
<p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p><em>5. 服务器推送</em></p>
<p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，<strong>服务不再是被动地响应</strong>，也可以<strong>主动</strong>向客户端发送消息。</p>
<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
<h3 id="HTTP-x2F-2-有哪些缺陷？HTTP-x2F-3-做了哪些优化？"><a href="#HTTP-x2F-2-有哪些缺陷？HTTP-x2F-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;2 有哪些缺陷？HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;2 有哪些缺陷？HTTP&#x2F;3 做了哪些优化？</h3><p>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP&#x2F;2 多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP&#x2F;1.1 的队头阻塞 和 HTTP&#x2F;2 的一个丢包全部重传问题。</p>
<p>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<h2 id="如何利用UDP实现可靠传输（基于-UDP-的-QUIC-协议）"><a href="#如何利用UDP实现可靠传输（基于-UDP-的-QUIC-协议）" class="headerlink" title="如何利用UDP实现可靠传输（基于 UDP 的 QUIC 协议）"></a>如何利用UDP实现可靠传输（基于 UDP 的 <strong>QUIC 协议</strong>）</h2><p>QUIC : Quick UDP Internet Connection</p>
<p><strong>应用层协议</strong></p>
<p>1.自定义连接机制<br>2.解决队头阻塞<br>3.自定义流量控制<br>4.改进的拥塞控制</p>
<p>QUIC的优点</p>
<p><strong>通过减少往返次数，以缩短连接建立时间</strong>，QUIC只需要一次往返就能建立HTTPS连接</p>
<p><strong>独立的数据流避免阻塞问题</strong></p>
<p><strong>改进的拥塞控制</strong><br>TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。</p>
<p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法</p>
<p>FEC前向纠正拥塞控制<br>FEC是Forward Error Correction前向错误纠正的意思，就是通过多发一些冗余的包，当有些包丢失时，可以通过冗余的包恢复出来，而不用重传。这个算法在多媒体网关拥塞控制有重要的地位。QUIC的FEC是使用的XOR的方式，即发N + 1个包，多发一个冗余的包，在正常数据的N个包里面任意一个包丢了，可以通过这个冗余的包恢复出来，使用异或可以做到</p>
<p><strong>切换网络操持连接</strong><br>经常会有从4G切换到wifi网络或者是从wifi切换到4G网络的场景，由于网络的IP变了，导致需要重新建立连接，而QUIC使用一个ID来标志连接，即使切换网络也可以使用之前的建立连接的数据如交换的密钥，而不用再重新HTTPS握手，不过切换的过程可能会导致有些包丢了，需要利用FEC恢复或者重传。</p>
<p><strong>更安全的传输协议</strong><br>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p>
<p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p>
<p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
<p><strong>QUIC面临的挑战</strong></p>
<p>1.路由封杀UDP 443端口（ 这正是QUIC 部署的端口）</p>
<p>2.UDP包过多，由于QS限定，会被服务商误认为是攻击，UDP包被丢弃</p>
<p>3.无论是路由器还是防火墙目前对QUIC都还没有做好准备。</p>
<p><strong>应用场景</strong></p>
<p>弱网环境下也可以流畅访问</p>
<p>延时从2s降到800ms</p>
<p>真正的即时通信，网络游戏物联网</p>
<h2 id="HTTP和TCP的区别，TCP是传输层，http是应用层"><a href="#HTTP和TCP的区别，TCP是传输层，http是应用层" class="headerlink" title="HTTP和TCP的区别，TCP是传输层，http是应用层"></a>HTTP和TCP的区别，TCP是传输层，http是应用层</h2><p>TCP是传输层协议，http是应用层协议</p>
<p>http是要基于TCP连接基础上的，</p>
<p>简单的说，<strong>TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输</strong>。</p>
<p>http是用来收发数据，涉及到实际应用上来的。</p>
<p>TCP是底层通讯协议，定义的是数据传输和连接方式的规范<br>HTTP是应用层协议，定义的是传输数据的内容的规范<br>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP   </p>
<p>HTTP支持的是www服务<br>而TCP&#x2F;IP是协议<br>它是Internet国际互联网络的基础。TCP&#x2F;IP是网络中使用的基本的通信协议。<br>TCP&#x2F;IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP&#x2F;IP是Internet协议族，而不单单是TCP和IP。</p>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p>●➢HTTP是个应用层协议。<br>●➢HTTP无需操心网络通信的具体细节;它把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br>●➢只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。<br>●<strong>TCP提供了:</strong><br><strong>➢无差错的数据传输; .</strong><br><strong>➢按序传输(数据总是会按照发送的顺序到达);</strong><br><strong>➢未分段的数据流(可以在任意时刻以任意尺寸将数据发送出去)。</strong></p>
<h2 id="TCP-x2F-IP四层模型-OSI七层模型（含每一层作用分析）"><a href="#TCP-x2F-IP四层模型-OSI七层模型（含每一层作用分析）" class="headerlink" title="TCP&#x2F;IP四层模型+OSI七层模型（含每一层作用分析）"></a>TCP&#x2F;IP四层模型+OSI七层模型（含每一层作用分析）</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721005559453.png" alt="image-20210721005559453" style="zoom:67%;" />

<ul>
<li>应用层:决定向用户提供应用服务时通信的活动，<ul>
<li>FTP, DNS, http协议——对tcp 的又一层封装提供用户程序接口</li>
</ul>
</li>
<li>传输层:提供处于网络连接中的两台计算机之间的数据传输<ul>
<li>tcp udp——socket编程就是在传输层，提供传输顺序信息与响应</li>
</ul>
</li>
<li>网络层:用来处理在网络上流动的数据包，规定通过怎样的传输路线到达对方计算机并把数据包传输给<br>对方<ul>
<li>ip 提供数据通过的路由</li>
</ul>
</li>
<li>数据链路层:进行数据打包与解包，形成信息帧</li>
<li>物理层:实现计算机系统与网络间的物理连接</li>
</ul>
<hr>
<p>OSI（Open System Interconnect），即开放式系统互联。 </p>
<p>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），</p>
<p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。</p>
<p>OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720215328134.png" alt="image-20210720215328134" style="zoom:50%;" />

<p> &lt;1&gt;  应用层</p>
<p>​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>&lt;2&gt;  表示层</p>
<p>​    表示层<strong>提供各种用于应用层数据的编码和转换功能,<strong>确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。</strong>数据压缩和加密</strong>也是表示层可提供的转换功能之一。</p>
<p>表示层的基本作用就是对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p>
<p>只有在表示层将数据处理完成后，才能将转格式编译后的数据呈现在应用程序中，<strong>让用户能够看懂。</strong></p>
<p>&lt;3&gt;  会话层</p>
<p>​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 </p>
<p>&lt;4&gt;  传输层</p>
<p>​    传输层建立了主机端到端的链接，传输层的作用是<strong>为上层协议提供端到端的可靠和透明的数据传输服务</strong>，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>&lt;5&gt;  网络层</p>
<p>​    <strong>本层通过IP寻址来建立两个节点之间的连接</strong>，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>&lt;6&gt;  数据链路层 </p>
<p>​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<p>​    MAC子层处理CSMA&#x2F;CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>&lt;7&gt; 物理层   </p>
<p>​    <strong>实际最终信号的传输是通过物理层实现的</strong>。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720215800625.png" alt="image-20210720215800625" style="zoom:33%;" />



<h2 id="TCP连接是通过4个值来识别的-源IP-地址、源端口号、目的IP地址、目的端口号"><a href="#TCP连接是通过4个值来识别的-源IP-地址、源端口号、目的IP地址、目的端口号" class="headerlink" title="TCP连接是通过4个值来识别的:源IP 地址、源端口号、目的IP地址、目的端口号"></a>TCP连接是通过4个值来识别的:源IP 地址、源端口号、目的IP地址、目的端口号</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721101946252.png" alt="image-20210721101946252" style="zoom:50%;" />

<p>TCP连接是通过4个值来识别的:<br>源IP地址、源端口号、目的IP地址、目的端口号<br>➢有些连接共享了相同的目的端口号(C和D都使用目的端口号80)。<br>有些连接使用了相同的源IP地址(B和C)。<br>➢有些使用了相同的目的IP地址(A和B, C和D)。<br>➢但没有两个不同连接所有的4个值都-样。</p>
<h2 id="三次握手、四次挥手（含TCP连接状态"><a href="#三次握手、四次挥手（含TCP连接状态" class="headerlink" title="三次握手、四次挥手（含TCP连接状态"></a>三次握手、四次挥手（含TCP连接状态</h2><p><strong>三次握手</strong></p>
<p><strong>LISTENING</strong> </p>
<p>1.客户端发送syn0给服务器，<strong>SYN_SENT (客户端状态)</strong><br>2.服务器收到syn0，回复syn1,ack(syn0+1) <strong>SYN_RECEIVED (服务端状态)</strong><br>3.客户端收到syn1，回复ack(syn1+1) <strong>ESTABLISHED</strong><br><strong>四次挥手(客户端主动发起连接关闭请求)</strong><br>1.客户端发送fin，表示要关闭连接；自己进入终止等待1状态（<strong>FIN-WAIT-1</strong>）<br>2.服务端收到fin,回复ack,表示自己进入了关闭等待状态（<strong>CLOSE-WAIT</strong>）；客户端进入终止等待2状态（<strong>FIN-WAIT-2</strong>）；服务端此时还可以发送未发送的数据，客户端还可以接收数据。<br>3.待服务端发送完数据之后，回复fin，进入最后确认阶段<br>4.客户端收到之后回复ack包，进入超时等待状态（<strong>TIME-WAIT</strong>），经过超时时间后关闭连接，而服务端收到ACK包后，立即关闭连接（<strong>CLOSED</strong>）</p>
<p><strong>状态迁移过程：</strong></p>
<p>a、客户端：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</p>
<p>b、服务端：CLOSED-&gt;LISTEN-&gt;SYN_RECEIVED-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSE</p>
<p><strong>三次握手连接阶段,最后一次ACK包丢失会进入什么样的一个状态</strong></p>
<p>由于<strong>server端</strong>发送syn_ack报文后进入SYN_RCVD状态，就会启动tcp重传计时器，<strong>超时时就会重新</strong>发送syn_ack报文，总共发送 net.ipv4.tcp_synack_retries次；<strong>如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</strong></p>
<p><strong>客户端</strong>在没有收到重传的syn_ack之前，Client 向 server端发送数据，由于server端的状态为SYN_RCVD状态，而不是ESTABLISHED状态，Server端将<strong>以 RST包响应</strong>，客户端方能感知服务器未收到ack报文。</p>
<p><strong>为什么要time wait？为什么是2MSL</strong></p>
<p>（为什么客户端需要等待超时时间，这是为了保证对方已收到ACK包，因为假设客户端发送完最后一包ACK包后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态；如果客户端发送最后一包ACK包后，等待一段时间，这时服务端因为没有收到ACK包，会重发FIN包，客户端会响应这个FIN包，重发ACK包并刷新超时时间；也是为了保证在不可靠的网络链路中，进行可靠的连接断开确认。</p>
<p>最后一个ack是一个确认报文，对方收到之后就正常关闭连接。自己则等待2msl，如果对方正常关闭，则自己之后正常关闭。MSL指的是任何IP数据报能够在因特网上存活的最长时间，所以来回是2MSL。</p>
<p>MSL指的是任何IP数据报能够在因特网上存活的最长时间。假设现在一个MSL的时候，接收端需要发送一个应答，这时候，我们也必须等待这个应答的消失，这个应答的消失也是需要一个MSL，所以我们需要等待2MSL。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721114059820.png" alt="image-20210721114059820" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721114040804.png" alt="image-20210721114040804" style="zoom:33%;" />

<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</strong></p>
<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当Server端收到FIN报文时，<strong>很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”<strong>。只有</strong>等到我Server端所有的报文都发送完了，我才能发送FIN报文</strong>，因此不能一起发送。故需要四次挥手。</p>
<hr>
<p><strong>为什么用三次握手，而不是四次</strong><br>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：<br>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复ack(syn0+1)<br>3.服务器发送syn1<br>3.客户端收到syn1，回复ack(syn1+1)<br>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
<p><strong>TCP，四次挥手如果改为三次怎么样？</strong><br>答：最后的确认报文可能丢失，如果丢失了，对方无法收到确认关闭连接的报文，那么就无法关闭连接。</p>
<hr>
<p><strong>为什么不能用两次握手进行连接？</strong></p>
<p>假设采用两次握手建立连接，客户端向服务端发送了一个SYN包来请求建立连接；</p>
<p>因为某些未知的原因，并没有到达服务器，在中间某个网络节点产生了滞留；</p>
<p>为了建立连接客户端会重发SYN包，这次的数据包正常送达，服务端回复SYN+ACK之后建立起了连接；</p>
<p>但是第一包数据阻塞的网络节点突然恢复，第一包SYN包又送达到服务端，这时服务端会误认为是客户端又发起了一个新的连接，从而在两次握手之后进入等待数据状态。</p>
<p>服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致。</p>
<hr>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="TCP怎么保证可靠性"><a href="#TCP怎么保证可靠性" class="headerlink" title="TCP怎么保证可靠性"></a>TCP怎么保证可靠性</h2><p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p>（1）校验和</p>
<p>发送方：在发送数据之前计算检验和，并进行校验和的填充。<br>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，<strong>数据不一定传输成功。</strong></p>
<p>（2）确认应答、序列号、超时重传</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行<strong>确认应答。也就是发送ACK报文</strong>，表示已经收到该数据段，这个ACK报文当中带有对应的<strong>确认序列号</strong>，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p>序列号的作用不仅仅是应答的作用，<strong>有了序列号能够将接收到的数据根据序列号排序</strong>，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<p>如果发送方迟迟<strong>未收到确认应答</strong>，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行<strong>重传</strong>。</p>
<p>（3）通过三次握手与四次挥手的过程保证可靠的连接。</p>
<p>（4）流量控制</p>
<p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的接收缓冲区很快的填充满了。</p>
<p>此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。</p>
<p>而<strong>TCP会根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</strong></p>
<p><strong>如何控制：</strong>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p>（5）拥塞控制</p>
<p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
<p>所以<strong>TCP引入了慢启动的机制</strong>，<strong>在开始发送数据时，先发送少量的数据探路</strong>。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<ul>
<li><p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
</li>
<li><p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答&#x2F;每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
</li>
</ul>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<ul>
<li>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</li>
</ul>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
<h2 id="tcp和udp区别"><a href="#tcp和udp区别" class="headerlink" title="tcp和udp区别"></a>tcp和udp区别</h2><p><strong>相同点</strong><br>UDP协议和TCP协议都是传输层协议。TCP&#x2F;UDP——传输层——在程序之间传输数据</p>
<p><strong>tcp和udp区别</strong></p>
<p>1） 连接——<strong>tcp是面向连接的，而udp面向数据报，是无连接就发送数据的</strong></p>
<p>TCP是面向连接的传输层协议，即<strong>传输数据之前必须先建立好连接</strong>。</p>
<p>UDP无连接。</p>
<p>2） 服务对象，<strong>通信的双方数量不同</strong></p>
<p> TCP之间仅支持单播（一对一）。TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p>
<p> UDP支持单播，多播，广播（一对一，一对多，一对全，多对一，多对多的交互通信）。</p>
<p>3） 可靠性——<strong>tcp传输时是可靠的，udp传输时是不可靠的</strong></p>
<p>TCP： 校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制</p>
<p>TCP是可靠交付：无差错，不丢失，不重复，按序到达。tcp的确认重传机制</p>
<p>UDP是尽最大努力交付，不保证可靠交付。udp相比之下容易丢包，报文乱序。</p>
<p>4）<strong>TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。</strong></p>
<p>5）拥塞控制，流量控制——<strong>以前tcp有个拥塞控制，udp没有</strong></p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性。</p>
<p>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。<strong>（对实时应用很有用，如IP电话，实时视频会议等）</strong></p>
<p>6） 报文长度</p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p>
<ol start="7">
<li>首部开销——<strong>首部大小不一样</strong></li>
</ol>
<p>TCP首部开销大，首部20个字节。（报文头部还有序号、确认序号、窗口、标志等（除了UDP也有的）</p>
<p>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p>
<p>8）TCP的逻辑通信信道是<strong>全双工</strong>的可靠信道，UDP则是不可靠信道</p>
<p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
<p><strong>UDP（User Data Protocol，用户数据报协议）</strong>是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。</p>
<h3 id="TCP和UDP适用场景"><a href="#TCP和UDP适用场景" class="headerlink" title="TCP和UDP适用场景"></a><strong>TCP和UDP适用场景</strong></h3><p>TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。</p>
<p>因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<ul>
<li><p><strong>若要保证通信数据完整性</strong>，对准确性要求高或者要求有连接，则应该选用TCP 协议</p>
<ul>
<li>比如传输文件、发送邮件、浏览网页等</li>
<li>SMTP：电子邮件、TELNET： 远程终端接入、HTTP、HTTPs： 万维网、FTP： 文件传输</li>
</ul>
</li>
<li><p><strong>若要保证通信实时性</strong>，要求效率，则使用 UDP 协议（如等）。</p>
<ul>
<li>比如域名查询、视频传输、实时通信\语音通话、视频直播等</li>
<li>DNS：域名转换、TFTP：文件传输、SNMP：网络管理、NFS：远程文件服务器</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210807195534121.png" alt="image-20210807195534121" style="zoom:50%;" />



<h2 id="长连接与短连接的区别（HTTP-1-1相对于1-0最重要的新特性就是引入了长连接"><a href="#长连接与短连接的区别（HTTP-1-1相对于1-0最重要的新特性就是引入了长连接" class="headerlink" title="长连接与短连接的区别（HTTP 1.1相对于1.0最重要的新特性就是引入了长连接"></a>长连接与短连接的区别（<strong>HTTP 1.1相对于1.0最重要的新特性就是引入了长连接</strong></h2><p><strong>长连接，也叫持久连接，在TCP层握手成功后，不立即断开连接，并在此连接的基础上进行多次消息交互，直至连接的任意一方（客户端OR服务端）主动断开连接，此过程称为一次完整的长连接。</strong></p>
<p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>
<p>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p><strong>HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。</strong></p>
<p>短连接，顾名思义，与长连接的区别就是，客户端收到服务端的响应后，立刻发送FIN消息，主动释放连接。也有服务端主动断连的情况，凡是在一次消息交互（发请求-收响应）之后立刻断开连接的情况都称为短连接。<br>注：短连接是建立在TCP协议上的，有完整的握手挥手流程，区别于UDP协议。</p>
<p><strong>什么时候用长连接，短连接？</strong></p>
<p>1、需要频繁交互的场景使用长连接，如即时通信工具（微信&#x2F;QQ，QQ也有UDP），相反则使用短连接，比如普通的web网站，只有当浏览器发起请求时才会建立连接，服务器返回相应后，连接立即断开。<br>2、维持长连接会有一定的系统开销，用户量少不容易看出系统瓶颈，一旦用户量上去了，就很有可能把服务器资源（内存&#x2F;CPU&#x2F;网卡）耗尽，所以使用需谨慎。</p>
<h2 id="数据链路层靠什么地址寻址？"><a href="#数据链路层靠什么地址寻址？" class="headerlink" title="数据链路层靠什么地址寻址？"></a>数据链路层靠什么地址寻址？</h2><h2 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h2><p>“一切皆Socket!”话虽些许夸张，但是事实也是，现在的网络编程几乎都是用的socket。</p>
<p> Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。</p>
<p><strong>什么是套接字</strong>：socket是一套用于不同主机间通信的API，它工作在我们的TCP&#x2F;IP协议栈之上，要通过socket与不同主机建立通信，我们只需要<strong>指定主机的IP地址，和一个端口号</strong>。IP地址用于唯一标识你的网络设备，端口主要用于区分主机上的不同应用。</p>
<p>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的<strong>主机</strong>，而传输层的“<strong>协议+端口</strong>”可以唯一标识<strong>主机中的应用程序（进程）</strong>。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>和大多数语言一样,Python支持面向连接和无连接，实现接口功能与步骤也大致相同。</p>
<ul>
<li><strong>面向连接</strong>即需要先连接然后通讯，面向连接主要协议就是<strong>传输控制协议(tcp)</strong>,要创建tcp套 接字时需要<br>指定套接字类型为SOCK _STRAM,表达了他作为流套接字的特点。</li>
<li><strong>无连接</strong>，顾名思义无需建立连接就可以进行通讯，这时数据到达顺序、可靠性就无法保证了。实现这种<br>连接的协议就是<strong>用户数据包协议(udp)</strong> 。创建UDP时需要指定套接字类型为SOCK _DGRAM。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于TCP</span></span><br><span class="line"><span class="comment">#服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用socket中的socket()来创建一个socket s</span></span><br><span class="line"><span class="comment"># with是python中的一个语法糖,代表当代码离开with块的时候,自动调用s.close()来销毁这个socket.</span></span><br><span class="line"><span class="comment"># 指定两个参数，第一个参数AF_INET代表我们使用的是IPv4的地址家族(address family)</span></span><br><span class="line"><span class="comment"># 第二个参数，SOCK_ STREAM代表我们使用的是TCP协议,这里的STREAM也正是代表TCP是个“流式”协议</span></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">1234</span>))  <span class="comment"># 绑定IP地址、端口等信息到socket上</span></span><br><span class="line">    <span class="comment"># 网卡我们可以通过IP地址指定,设置为&quot;0.0.0.0&quot;代表你主机上的任意网卡都可以使用这个socket进行通信</span></span><br><span class="line"></span><br><span class="line">    s.listen()  <span class="comment"># 对端口进行监听(listen)</span></span><br><span class="line">    c, addr = s.accept()  <span class="comment"># 接收客户端上来的连接，用函数accept(),并返回一个新的socket c,以及客户端的IP地址</span></span><br><span class="line">    <span class="comment"># 注意这个c是一个与之前s不同的socket,socket s主要用于监听,而socket c则用于与连接的客户端进行通信</span></span><br><span class="line">    <span class="keyword">with</span> c:</span><br><span class="line">        <span class="built_in">print</span>(addr, <span class="string">&quot;connected.&quot;</span>)  <span class="comment"># 打印客户端的IP地址</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 这个循环会一直调用recv() 接收客户端传来的信息</span></span><br><span class="line">            data = c.recv(<span class="number">1024</span>)  <span class="comment"># 这里的1024代表一次性接受数据的最大长度,1024个字节</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            c.sendall(data)  <span class="comment"># 只要数据不为空，就回传给客户端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#创建一个socket, 用函数socket()</span></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET,socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1234</span>))<span class="comment">#传入服务器的IP地址和端口号,连接服务器，用函数connect()</span></span><br><span class="line">    s.sendall(<span class="string">b&quot;Hello,Ross&quot;</span>)<span class="comment">#调用sendall()发送一条消息给服务器,参数是一个字节序列,并不是字符串，不要忘记b</span></span><br><span class="line">    data=s.recv(<span class="number">1024</span>)<span class="comment">#调用recv()接受服务器的消息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received:&quot;</span>,<span class="built_in">repr</span>(data))</span><br><span class="line">    </span><br><span class="line">多线程解决：</span><br><span class="line">selectors高级I/O复用库</span><br><span class="line"><span class="keyword">async</span>异步I/O</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721102802215.png" alt="image-20210721102802215" style="zoom:60%;" />

<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721110949854.png" alt="image-20210721110949854" style="zoom:67%;" />



<h2 id="什么是HttpOnly-amp-跨站脚本攻击XSS"><a href="#什么是HttpOnly-amp-跨站脚本攻击XSS" class="headerlink" title="什么是HttpOnly &amp; 跨站脚本攻击XSS"></a>什么是HttpOnly &amp; 跨站脚本攻击XSS</h2><p>**<code>HttpOnly</code>**是加在cookies上的一个标识，用于告诉浏览器不要向客户端脚本（document.cookie或其他）暴露cookie。</p>
<p><strong>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击来窃取cookie内容，这样就增加了cookie的安全性。</strong></p>
<p><code>HttpOnly</code>背后的相关议题是：当网站存在<code>跨站脚本攻击（XSS）</code>漏洞时,黑客通过执行脚本获得cookie时被阻止，从而在根本上杜绝这种类型的攻击。</p>
<p>当你在cookie上设置<code>HttpOnly</code>标识后，浏览器就会知会到这是特殊的cookie,只能由服务器检索到，所有来自客户端脚本的访问都会被禁止。当然也有前提：使用新版的浏览器。</p>
<p>语法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: Name=Value; expires=Wednesday, <span class="number">01</span>-May<span class="number">-2014</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">10</span> GMT; HttpOnly</span><br></pre></td></tr></table></figure>

<p>在上面的HTTP请求头中，<code>HttpOnly</code>知会浏览器在保存cookie，但不要向客户端脚本开放访问权限。</p>
<p>另外还有一个安全标识可以强制浏览器发送cookie的时候采用安全通道，比如<code>HTTPS</code>,可以防止被监听。尤其是在HTTPS连接被一些工具（比如SSLStrip等）降级到HTTP。<br>语法为：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: Name=Value; expires=Wednesday, <span class="number">01</span>-May<span class="number">-2014</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">10</span> GMT; Secure</span><br></pre></td></tr></table></figure>

<p>在这个HTTP头信息中，<code>Secure</code>标识知会浏览器使用安全的加密通道发送cookie。</p>
<hr>
<p>**XSS是跨站脚本攻击(Cross Site Scripting)**。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站(流量劫持)等。</p>
<p>举个例子：窃取网页浏览中的cookie值</p>
<p><strong>在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。</strong></p>
<p>如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。</p>
<p>试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用）</p>
<p>Web 安全性测试之跨站脚本攻击测试<a href="https://zhuanlan.zhihu.com/p/62725624">https://zhuanlan.zhihu.com/p/62725624</a></p>
<hr>
<h2 id="iPv6-的-128-位地址通常写成-8-组，每组由4个十六进制数组成"><a href="#iPv6-的-128-位地址通常写成-8-组，每组由4个十六进制数组成" class="headerlink" title="iPv6 的 128 位地址通常写成 8 组，每组由4个十六进制数组成"></a>iPv6 的 128 位地址通常写成 8 组，每组由4个十六进制数组成</h2><p>ipv4是32位，分四组，每组由3个十进制数组成，[0-255]</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>为了避免单机性能瓶颈与解决单点故障的隐患，部署多个服务器，如何选择？选择哪台机器来连接的工作最好放在 server 中，具体怎么做呢，在架构设计中有个经典的共识：没有什么是加一层解决不了的，如果有那就再加一层，所以我们在 server 端再加一层，将其命名为（Load Balance，负载均衡） </p>
<p>由 LB统一接收 client 的请求，然后再由它来决定具体与哪一个 server 通信，一般业界普遍使用 Nginx 作为 LB</p>
<p><strong>Nginx 是七层（即应用 层）负载均衡器</strong> ，这意味着如果它要转发流量<strong>首先得和 client 建立一个 TCP 连接</strong>，并且转发的时候也要与转发到的上游 server 建立一个 TCP 连接，而我们知道建立 <strong>TCP 连接其实是需要耗费内存</strong>（TCP Socket，接收&#x2F;发送缓存区等需要占用内存）的，客户端和上游服务器要发送数据都需要先发送暂存到到 Nginx 再经由另一端的 TCP 连接传给对方。</p>
<p>所以 Nginx 的负载能力受限于机器I&#x2F;O，CPU内存等一系列配置，一旦连接很多（比如达到百万）的话，Nginx 抗负载能力就会急遽下降。</p>
<p>经过分析可知 Nginx 的负载能力较差主要是因为它是七层负载均衡器必须要在上下游分别建立两个 TCP 所致，那么是否能设计一个类似路由器那样的只负载转发包但不需要建立连接的负载均衡器呢，这样由于不需要建立连接，只负责转发包，不需要维护额外的 TCP 连接，它的负载能力必然大大提升，于是<strong>四层（传输层）负载均衡器 LVS</strong> 就诞生了，简单对比下两者的区别</p>
<p> LVS 只是<strong>单纯地转发包</strong>，不需要和上下游建立连接即可转发包，相比于 Nginx 它的抗负载能力强、性能高，能达到 F5 硬件的 60%；对内存和cpu资源消耗比较低</p>
<p>四层负载均衡器是如何工作的呢<br>负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过负载均衡算法选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器 IP ），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，<strong>负载均衡设备只是起到一个类似路由器的转发动作</strong>。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(2)——操作系统</title>
    <url>/2022/02/02/QA_os/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-2-——操作系统"><a href="#面试QA整理-2-——操作系统" class="headerlink" title="面试QA整理(2)——操作系统"></a>面试QA整理(2)——操作系统</h1><h2 id="进程、线程的区别"><a href="#进程、线程的区别" class="headerlink" title="进程、线程的区别"></a>进程、线程的区别</h2><p>区别：</p>
<p>1.<strong>一个线程只能属于一个进程，而一个进程可以有多个线程</strong>，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2.<strong>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</strong>（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是<strong>每个线程拥有自己的栈</strong>段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p><strong>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></p>
<p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。</p>
<p>而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，<strong>进程切换的开销也远大于线程切换的开销。</strong></p>
<p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
<p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p><strong>7.进程间相互独立，不会相互影响；线程一个线程挂掉可能会导致整个进程挂掉</strong></p>
<p>​    问题：浏览器是多进程还是多线程？——<strong>浏览器是多进程</strong>，一个页面挂掉不会整个挂掉</p>
<p>8.进程适应于多核、多机分布；线程适用于多核</p>
<hr>
<p><strong>1. 何为进程?</strong></p>
<p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</strong></p>
<p>在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p>
<p><strong>2. 何为线程?</strong></p>
<p>线程是一个比进程更小的执行单位。<strong>一个进程在其执行的过程中可以产生多个线程</strong>。</p>
<p>与进程不同的是同类的多个线程<strong>共享进程的堆和方法区资源</strong>，但<strong>每个线程有自己的程序计数器、虚拟机栈和本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h2 id="为什么要有线程"><a href="#为什么要有线程" class="headerlink" title="为什么要有线程"></a>为什么要有线程</h2><p>在多任务环境中，不可能说让所有任务排队，前面的处理完了才处理后面的任务。如果要让用户感觉到任务都是一起执行的，那么就必须在进程之间频繁切换。</p>
<p>问题在于如果要进行进程的切换需要做很多的工作，必须要保存好当前CPU的上下文，好让CPU下次被分配到当前进程时可以继续往前执行，然后还需要设置新的进程的CPU上下文，在这个过程中会花费很多时间。由于这个原因就限制了系统中进程数目不能多。<br>　　<br>为了解决这个限制，后来提出将进程的两个属性分开，由操作系统分开处理，即对于作为调度和分派的基本单位，但不同时作为拥有资源的单位；而对于拥有资源的基本单位，又不对其进行频繁的切换。正是在这种思想的指导下，形成了线程的概念。</p>
<h2 id="多线程会出现那些问题"><a href="#多线程会出现那些问题" class="headerlink" title="多线程会出现那些问题"></a>多线程会出现那些问题</h2><p>各个线程执行的顺序不同，会导致执行的结果不一致。</p>
<p>并发访问的安全性问题</p>
<p>当多个线程无序的访问同一个共享资源时,可能会导致共享资源的最后结果不是我们期望的结果。</p>
<p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题<br>　　1.原子性:即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>例如,如果i&#x3D;32;不具备原子性的话,当给它的低16赋值完时,突然中断,其他线程在去读这个值时,就是错误的值.</p>
<p>　　2.可见性:指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p>　　3.有序性:即程序执行的顺序按照代码的先后顺序执行，首先什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，<br>它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。处理器在进行重排序时也是会考虑指令之间的数据依赖性<br>　　指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<h2 id="线程通信的方法、线程的五种状态"><a href="#线程通信的方法、线程的五种状态" class="headerlink" title="线程通信的方法、线程的五种状态"></a>线程通信的方法、线程的五种状态</h2><p><strong>python线程通信的方法</strong></p>
<p><strong>java线程通信的方法：</strong></p>
<p>①同步：多个线程通过synchronized关键字这种方式来实现线程间的通信。</p>
<p>②while轮询的方式</p>
<p>③wait&#x2F;notify机制</p>
<p>④管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p>
<p><strong>线程的五种状态：</strong></p>
<ol>
<li><p>新建(NEW)：新创建了一个线程对象。</p>
</li>
<li><p>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：</p>
<p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
<p>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
<p>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</p>
</li>
<li><p>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
<h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ol>
<li><p><strong>管道</strong>：单向的传输，这样的管道我们叫做”匿名管道”。速度慢，容量有限，只有<strong>父子进程</strong>能通讯。</p>
<p><code>netstat -nlp | grep XXX </code></p>
<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>FIFO <strong>命名式管道</strong>：<strong>任何进程间</strong>都能通讯，但速度慢；半双工的通信方式，但是它允许无亲缘关系进程间的通信。<code>mkfifo test</code></p>
<p><strong>简单，但效率低下。</strong>因为假设现在有AB两个进程，A进程将数据写入管道，B进程需要等待A进程将信息写完以后才能读出来，所以这种方案不适合频繁的通信。</p>
</li>
<li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</p>
<p>用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，<strong>b 进程需要的时候再去对应的消息队列里取出来</strong>。</p>
<p>如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。</p>
</li>
<li><p>共享内存：我们知道每个进程都有自己的虚拟内存空间，不同的进程映射到不同的物理内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，不同进程通过这块虚拟地址空间<strong>映射到相同的物理地址空间</strong>。这就完成了内存共享机制了。</p>
<p>能够很容易控制容量，速度快，<strong>但要保持同步</strong>，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要， 线程间本来就已经共享了同一进程内的一块内存</p>
</li>
<li><p>信号量：<strong>线程安全问题，如何解决</strong>，我们得有个约束或者说一种保护机制。<strong>使得同一份共享的资源只能一个进程使用</strong>，这里就出现了信号量机制。<strong>信号量主要实现进程之间的同步和互斥，而不是存储通信内容。不能传递复杂消息，只能用来同步。</strong></p>
<p>信号量是一个计数器，可以用来<strong>控制多个进程对共享资源的访问</strong>。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>信号：在操作系统中，不同信号用不同的值表示，每个信号设置相应的函数，一旦进程发送某一个信号给另一个进程，另一进程将执行相应的函数进行处理。也就是说先把可能出现的异常等问题准备好，一旦信号产生就执行相应的逻辑即可。<code>kill -l</code></p>
</li>
<li><p>socket通信：(包括同一主机上的socket通信和不在同一主机上的远程 socket 通信)  可用于不同及其间的进程通信。</p>
<p>上面的几种方式都是单机情况下多个进程的通信方式（多个进程在一台主机之间的通信），那两个相隔几千里的进程能够进行通信吗？这就需要套接字socket了。其实这玩意随处可见，我们平时的聊天，我们天天请求浏览器给予的响应等</p>
</li>
</ol>
<h2 id="消息队列的作用，应用耦合，异步消息，流量削锋"><a href="#消息队列的作用，应用耦合，异步消息，流量削锋" class="headerlink" title="消息队列的作用，应用耦合，异步消息，流量削锋"></a>消息队列的作用，应用耦合，异步消息，流量削锋</h2><ul>
<li><p>解耦，将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统不需要做任何修改。</p>
<ul>
<li><p>用户下单后，订单系统需要通知库存系统。<strong>传统的做法</strong>是，订单系统调用库存系统的接口。假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。订单系统与库存系统耦合</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815224202718.png" alt="image-20210815224202718" style="zoom:67%;" />
</li>
<li><p><strong>引入消息队列</strong></p>
<p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p>
<p>库存系统：订阅下单的消息，获取下单信息，库存系统根据下单信息，进行库存操作</p>
<p>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815224302288.png" alt="image-20210815224302288" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p>
<ul>
<li><p>用户注册后，需要发注册邮件和注册短信。<strong>传统的做法</strong>有两种 1.串行的方式；2.并行方式</p>
<p>串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815223958365.png" alt="image-20210815223958365" style="zoom:67%;" />

<p>并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815224016034.png" alt="image-20210815224016034" style="zoom:67%;" />

<p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p>
</li>
<li><p><strong>引入消息队列</strong>，将不是必须的业务逻辑，异步处理。</p>
</li>
<li><img src="http://images2015.cnblogs.com/blog/820332/201601/820332-20160124211131625-1083908699.png" alt="img" style="zoom:67%;" />

<p>用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍</p>
</li>
</ul>
</li>
<li><p>削峰，系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的</p>
<p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛</p>
<p>秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端<strong>加入消息队列</strong>。可以控制活动的人数、可以缓解短时间内高流量压垮应用</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815224429376.png" alt="image-20210815224429376" style="zoom:67%;" />

<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</p>
<p>秒杀业务根据消息队列中的请求信息，再做后续处理</p>
</li>
</ul>
<h2 id="复制粘贴-操作系统做了什么"><a href="#复制粘贴-操作系统做了什么" class="headerlink" title="复制粘贴 操作系统做了什么"></a>复制粘贴 操作系统做了什么</h2><p>这涉及到进程之间的通信，通过消息队列实现通信过程，是间接通信（在Windows中如果复制之后没有执行粘贴操作，会一直存在，就相当于放在了存储空间中，当关机的时候就消失了）</p>
<p>消息的发送不需要接收方准备好，随时可发送。</p>
<p>消息缓冲：在内存中开设缓冲区，发送进程将消息送入缓冲区，接收进程接收传递来的缓冲区<br>间接方式：发送进程发消息时不指定接收进程的名字，而是指定一个中间媒介，即信箱。进程间通过信箱实现通信     发送原语：send(MB,Message)   接收原语：receive(MB,Message)</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(4)——数据结构</title>
    <url>/2022/02/04/QA_datastructure/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-4-——数据结构"><a href="#面试QA整理-4-——数据结构" class="headerlink" title="面试QA整理(4)——数据结构"></a>面试QA整理(4)——数据结构</h1><h2 id="数组和链表的区别，优缺点"><a href="#数组和链表的区别，优缺点" class="headerlink" title="数组和链表的区别，优缺点"></a>数组和链表的区别，优缺点</h2><p><strong>数组的特点：</strong>元素<strong>增删慢，查找快</strong></p>
<ul>
<li><p>数组将元素在<strong>内存中连续存放</strong>，由于每个元素占用内存相同，可以<strong>通过下标迅速访问数组中任何元素</strong>。  </p>
</li>
<li><p>数组的<strong>插入数据和删除数据效率低</strong>，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。</p>
</li>
<li><p>数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到相应数据。  </p>
</li>
<li><p>如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p>
</li>
<li><p><strong>数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间</strong>。</p>
</li>
<li><p>并且数组<strong>不利于扩展</strong>，<strong>数组定义的空间不够时</strong>要<strong>重新定义数组</strong>。</p>
</li>
</ul>
<p><strong>链表的特点：</strong> 元素<strong>增删快，查找慢</strong></p>
<ul>
<li>链表中的元素<strong>在内存中不是顺序存储</strong>的，而是通过存在元素中的<strong>指针</strong>联系到一起。 </li>
<li>如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。</li>
<li>增加和删除一个元素对于链表数据结构非常简单，<strong>只要修改元素中的指针</strong>就可以了。</li>
<li>如果应用需要经常插入和删除元素你就需要用链表数据结构了。</li>
<li><strong>不指定大小，扩展方便。链表大小不用定义，数据随意增删</strong>。</li>
</ul>
<p><strong>数组的优点：</strong></p>
<ol>
<li><p>随机访问性强</p>
</li>
<li><p>查找速度快</p>
</li>
</ol>
<p><strong>数组的缺点:</strong></p>
<ol>
<li><p>插入和删除效率低</p>
</li>
<li><p>可能浪费内存</p>
</li>
<li><p>内存空间要求高，必须有足够的连续内存空间。</p>
</li>
<li><p>数组大小固定，不能动态拓展</p>
</li>
</ol>
<p><strong>链表的优点:</strong></p>
<ol>
<li><p>插入删除速度快</p>
</li>
<li><p>内存利用率高，不会浪费内存</p>
</li>
<li><p>大小没有固定，拓展很灵活。</p>
</li>
</ol>
<p><strong>链表的缺点：</strong>不能随机查找，必须从第一个开始遍历，查找效率低</p>
<h2 id="队列和栈有什么区别"><a href="#队列和栈有什么区别" class="headerlink" title="队列和栈有什么区别"></a>队列和栈有什么区别</h2><p>队列是在队尾入队，队头出队，<strong>即两边都可操作</strong>。</p>
<p>而<strong>栈的进栈和出栈都是在栈顶进行的</strong>，无法对栈底直接进行操作。</p>
<p>队列是<strong>先进先出（FIFO）</strong>，即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。</p>
<p>而栈为<strong>先进后出</strong>,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</p>
<h2 id="二分法的原理阐述，时间复杂度与空间复杂度"><a href="#二分法的原理阐述，时间复杂度与空间复杂度" class="headerlink" title="二分法的原理阐述，时间复杂度与空间复杂度"></a>二分法的原理阐述，时间复杂度与空间复杂度</h2><h2 id="排序算法（复杂度"><a href="#排序算法（复杂度" class="headerlink" title="排序算法（复杂度"></a>排序算法（复杂度</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726003125050.png" alt="image-20210726003125050" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726200155081.png" alt="image-20210726200155081" style="zoom: 50%;" />

<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</li>
</ul>
<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><p>冒泡排序(Bubble Sort)一种交换排序，它的基本思想是:两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
</ul>
<p>冒泡排序对n个数据操作n-1轮，每轮找出一个最大（小）值。</p>
<p>**最好时间复杂度：O(n)**。当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作。</p>
<p>**最坏时间复杂度：O(n^2)**。当数组刚好是完全逆序的时候，每轮排序都需要挨个比较 n 次，并且重复 n 次。</p>
<p>**平均时间复杂度：O(n^2)**。当输入数组杂乱无章时，每轮排序都需要挨个比较 n 次，并且重复 n 次。</p>
<p>**空间复杂度：O(1)**。使用了交换法，不需要开辟额外的空间。</p>
<p>稳定性：元素相同时不做交换，是稳定的排序算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BubbleSort</span>(<span class="params">array</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">if</span> (lens&lt;<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>): <span class="comment">#注意range左闭右开 只需要排前n-1个数，排好了，最后一个数也就排好了</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]:</span><br><span class="line">                array[j+<span class="number">1</span>],array[j]=array[j],array[j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">12</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">73</span>]</span><br><span class="line">    <span class="built_in">print</span>(BubbleSort(array_test)) <span class="comment">#[5, 11, 12, 23, 32, 54, 73]</span></span><br></pre></td></tr></table></figure>

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img" style="zoom:50%;" />

<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的<strong>两部分</strong>，其中<strong>一部分记录的关键字</strong>均比<strong>另一部分的关键字小</strong>，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，<strong>所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面</strong>（相同的数可以到任一边）。在这个分区退出之后，<strong>该基准就处于数列的中间位置</strong>。这个称为分区（partition）操作；</li>
<li><strong>递归地（recursive）</strong>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p>**最好时间复杂度：O(nlogn)**。每次选取分区点时，都能选中中位数，把数组等分成两个。</p>
<p>【基准值若能把数据分为平均的两块，划分次数O(logn)，每次划分遍历比较一遍O(n)，时间复杂度O(nlogn)。】</p>
<p><strong>最坏时间复杂度：O(n^2)。</strong>每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要 n 次的分区操作。</p>
<p><strong>平均时间复杂度：O(nlogn)。</strong>在大部分情况下，统计上是很难选到极端情况的，因为大多数时候都不是选中最大或最小值。</p>
<p>空间复杂度：额外空间开销出在暂存基准值，O(logn)次划分需要O(logn)个，**空间复杂度O(logn)**。</p>
<p>稳定性：快速排序的分区过程涉及交换操作，是不稳定的排序算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">Partion</span><span class="params">(array, l, r)</span>:</span><br><span class="line">    pivot = array[l]</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r):</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r and array[r] &gt;= pivot):</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        array[l] = array[r]</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r and array[l] &lt;= pivot):</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        array[r] = array[l]</span><br><span class="line"></span><br><span class="line">    array[l] = pivot</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">               </span><br><span class="line">def <span class="title function_">QuickSort</span><span class="params">(array, l, r)</span>:</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r): #不能忘记！！！！！！！！！</span><br><span class="line">        p = Partion(array, l, r)</span><br><span class="line">        QuickSort(array, l, p - <span class="number">1</span>)</span><br><span class="line">        QuickSort(array, p + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> array                </span><br><span class="line"></span><br><span class="line"><span class="type">if</span> <span class="variable">__name__</span> <span class="operator">=</span>= <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">19</span>, <span class="number">97</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">    print(QuickSort(array_test, <span class="number">0</span>, len(array_test) - <span class="number">1</span>))  # [<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">97</span>]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726203848623.png" alt="image-20210726203848623" style="zoom: 33%;" />

<h3 id="简单插入排序-Insertion-Sort）"><a href="#简单插入排序-Insertion-Sort）" class="headerlink" title="简单插入排序(Insertion Sort）"></a>简单插入排序(Insertion Sort）</h3><p>插入排序（Insertion-Sort）是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<p>简单插入排序同样操作n-1轮，每轮将一个未排序数插入排好序列。</p>
<p><strong>最好时间复杂度：O(n)。</strong>当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置；这个过程重复 n-1次，就可以清空未排序区间。</p>
<p><strong>最坏时间复杂度：O(n^2)。</strong>当数组刚好是完全逆序时，要比较1+2+3+….+n-1 次才能找到正确位置；这个过程重复 n-1次，就可以清空未排序区间。</p>
<p><strong>平均时间复杂度：O(n^2)。</strong>开始时默认第一个数有序，将剩余n-1个数逐个插入。插入操作具体包括：比较确定插入位置，数据移位腾出合适空位。每轮操作O(n)次，共O(n)轮，时间复杂度O(n^2)。</p>
<p><strong>空间复杂度：O(1)。</strong>额外空间开销出在数据移位时那一个过渡空间，空间复杂度O(1)。</p>
<p>稳定性：元素相同时不做交换，是稳定的排序算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertSort</span>(<span class="params">array</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">if</span> lens &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lens):</span><br><span class="line">        target = array[i]  <span class="comment"># 每次循环的一个待插入的数</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># 从等待插入的前一个数开始比较，一直往左移动比较</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> target &lt; array[j]:</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]  <span class="comment"># 待插入的小，交换</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        array[j + <span class="number">1</span>] = target</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">19</span>, <span class="number">97</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="built_in">print</span>(InsertSort(array_test)) <span class="comment">#[1, 8, 9, 17, 19, 97]</span></span><br></pre></td></tr></table></figure>

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img" style="zoom:50%;" />

<h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h3><p>1959年Shell发明，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。</p>
<p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序。</p>
<p>若序列基本有序，简单插入排序不必做很多移动操作，效率很高。</p>
<p>希尔排序将序列按固定间隔划分为多个子序列，在子序列中简单插入排序，先做远距离移动使序列基本有序；逐渐缩小间隔重复操作，最后间隔为1时即简单插入排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ShellSort</span>(<span class="params">array</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">if</span> lens &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    step = lens // <span class="number">2</span>  <span class="comment"># 设定初始步长,注意整除</span></span><br><span class="line">    <span class="keyword">while</span> step &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step, lens):</span><br><span class="line">            <span class="comment"># 类似插入排序, 当前值与指定步长之前的值比较, 符合条件则交换位置</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= step <span class="keyword">and</span> array[i] &lt; array[i - step]:</span><br><span class="line">                array[i], array[i - step] = array[i - step], array[i]</span><br><span class="line">                i -= step</span><br><span class="line">        step = step // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">19</span>, <span class="number">97</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="built_in">print</span>(ShellSort(array_test))  <span class="comment"># [1, 8, 9, 17, 19, 97]</span></span><br></pre></td></tr></table></figure>

<img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt="img" style="zoom:50%;" />

<h3 id="简单选择排序-Select-Sort"><a href="#简单选择排序-Select-Sort" class="headerlink" title="简单选择排序(Select Sort)"></a>简单选择排序(Select Sort)</h3><p>选择排序(Selection-sort)：简单选择排序同样对数据操作n-1轮，每轮找出一个最小（大）值。以此类推，直到所有元素均排序完毕。 </p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。</p>
<p>时间复杂度O(n^2)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SelectSort</span>(<span class="params">array</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">if</span> lens &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens - <span class="number">1</span>):</span><br><span class="line">        minIndex = i  <span class="comment"># 将当前下标定义为最小值下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, lens):  <span class="comment"># 循环i后面的数据</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]):  <span class="comment"># 把数据小的下边赋给minIndex</span></span><br><span class="line">                minIndex = j</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i):  <span class="comment"># 找到了一个最小值</span></span><br><span class="line">            array[i], array[minIndex] = array[minIndex], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">19</span>, <span class="number">97</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="built_in">print</span>(SelectSort(array_test))  <span class="comment"># [1, 8, 9, 17, 19, 97]</span></span><br></pre></td></tr></table></figure>

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" style="zoom:50%;" />

<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序过程</p>
<ul>
<li><p>1.构造一个大顶堆，取堆顶数字R[1] (也就是最大值)与最后一个元素R[n]交换  </p>
</li>
<li><p>2.新的无序区(R1,R2,……Rn-1)和新的有序区(Rn)。再将剩下的数字构建一个大顶堆，取堆顶数字(也就是剩下值当中的最大值)R[1]与无序区最后一个元素交换 </p>
</li>
<li><p>3.得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。 </p>
</li>
<li><p>4.重复以上操作，直到取完堆中的数字，最终得到一个从大到小排列的序列</p>
</li>
</ul>
<p>堆排序的初始建堆过程比价复杂，对O(n)级别个非叶子节点进行堆调整操作O(logn)，时间复杂度O(nlogn)；</p>
<p>之后每一次堆调整操作确定一个数的次序，时间复杂度O(nlogn)。</p>
<p>合起来时间复杂度O(nlogn)</p>
<p>额外空间开销出在调整堆过程，根节点下移交换时一个暂存空间，空间复杂度O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建大顶堆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HeadAdjust</span>(<span class="params">array, i, n</span>):  <span class="comment"># 以i为根节点进行堆调整为大顶堆</span></span><br><span class="line">    largest = i  <span class="comment"># 创建一个索引，后面用于交换</span></span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 左孩子</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> array[i] &lt; array[l]:  <span class="comment"># 左孩子比根节点大</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> array[largest] &lt; array[r]:  <span class="comment"># 右孩子更大</span></span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        array[i], array[largest] = array[largest], array[i]</span><br><span class="line">        HeadAdjust(array, largest, n)  <span class="comment"># 堆顶排好了，但是子堆又混乱了，需要重新排</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HeapSort</span>(<span class="params">array</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建第一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 从有子节点的节点开始判断就行</span></span><br><span class="line">        HeadAdjust(array, i, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个个交换元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 循环i从n-1开始;下一次创建堆i=n-2，不会带上已经排好的元素，排好n-1个，所以左闭右开，右不需要写-1，写0就行</span></span><br><span class="line">        array[i], array[<span class="number">0</span>] = array[<span class="number">0</span>], array[i]  <span class="comment"># 将堆顶元素和末尾元素做交换</span></span><br><span class="line">        HeadAdjust(array, <span class="number">0</span>, i)  <span class="comment"># 再构建新的大顶堆，从被换上去的那个数开始判断就行，也就是索引0处，因为除了它，其它已经构建好</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="built_in">print</span>(HeapSort(array_test))  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210727130213126.png" alt="image-20210727130213126" style="zoom:33%;" />

<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序的原理其实就是分治法。它首先将数组不断地二分，直到最后每个部分只包含 1 个数据。然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。</p>
<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<p>1.将序列中带排序数字分为若干组，每个数字分为一组<br>2.将若干个组两两合并，保证合并后的组是有序的<br>3.重复第二步操作直到只剩下一组，排序完成</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>性能</strong></p>
<p>最好、最坏、平均时间复杂度：O(nlogn)。采用了二分的迭代方式，复杂度是 O(logn)。每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n) 的时间复杂度下就可以完成。同时，它的执行频次与输入序列无关。</p>
<p>空间复杂度：O(n)。每次合并的操作都需要开辟基于数组的临时内存空间。</p>
<p>稳定性：合并的时候，相同元素的前后顺序不变，是稳定的排序算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">array, left, mid, right</span>):</span><br><span class="line">    temp = []  <span class="comment"># 临时数组</span></span><br><span class="line">    i = left  <span class="comment"># 左段子序列起始</span></span><br><span class="line">    j = mid + <span class="number">1</span>  <span class="comment"># 右段子序列起始</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt;= array[j]:</span><br><span class="line">            temp.append(array[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp.append(array[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># while循环结束后，有一部分会没有数了</span></span><br><span class="line">    <span class="comment"># 如果是左部分没数了</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        temp.append(array[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果是右部分没数了</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        temp.append(array[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 把临时数组赋给原数组,注意下标</span></span><br><span class="line">    array[left:right + <span class="number">1</span>] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MergeSort</span>(<span class="params">array, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right):  <span class="comment"># 判断列表有至少有两个数字，如果left=right,说明只有一个元素，不用排序</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        MergeSort(array, left, mid)</span><br><span class="line">        MergeSort(array, mid + <span class="number">1</span>, right)</span><br><span class="line">        Merge(array, left, mid, right)</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array_test = [<span class="number">19</span>, <span class="number">97</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="built_in">print</span>(MergeSort(array_test, <span class="number">0</span>, <span class="built_in">len</span>(array_test) - <span class="number">1</span>))  <span class="comment"># [1, 8, 9, 17, 19, 97]</span></span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726215822860.png" alt="image-20210726215822860" style="zoom:50%;" />

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img" style="zoom:50%;" />

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210727120810350.png" alt="image-20210727120810350" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210727120843574.png" alt="image-20210727120843574" style="zoom:40%;" />

<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="递归（前序、中序、后序"><a href="#递归（前序、中序、后序" class="headerlink" title="递归（前序、中序、后序"></a>递归（前序、中序、后序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先(前)序遍历：根——左——右</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PreOrder</span>(<span class="params">root, array=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    array.append(root.val)</span><br><span class="line">    PreOrder(root.left, array)</span><br><span class="line">    PreOrder(root.right, array)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历：左——根——右</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InOrder</span>(<span class="params">root, array=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    InOrder(root.left, array)</span><br><span class="line">    array.append(root.val)</span><br><span class="line">    InOrder(root.right, array)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历：左——右——根</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PostOrder</span>(<span class="params">root, array=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    PostOrder(root.left, array)</span><br><span class="line">    PostOrder(root.right, array)</span><br><span class="line">    array.append(root.val)</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="非递归（前序、中序、后序"><a href="#非递归（前序、中序、后序" class="headerlink" title="非递归（前序、中序、后序"></a>非递归（前序、中序、后序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 深度优先遍历DFS (非递归——前序：根，左，右)</span></span><br><span class="line"><span class="comment"># 思想：利用栈，先将根入栈，再将根出栈；并将根的右子树，左子树存入栈，按照栈的先进后出规则来实现深度优先遍历。</span></span><br><span class="line"><span class="comment"># 有右节点先压右节点，再压左节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [root]  <span class="comment"># 栈用来保存未访问节点</span></span><br><span class="line">    array = []  <span class="comment"># 保存节点值，作为结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        s = stack.pop()  <span class="comment"># 拿出栈顶节点</span></span><br><span class="line">        array.append(s.val)</span><br><span class="line">        <span class="keyword">if</span> s.right:</span><br><span class="line">            stack.append(s.right)  <span class="comment"># 先存右子树</span></span><br><span class="line">        <span class="keyword">if</span> s.left:</span><br><span class="line">            stack.append(s.left)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归——中序遍历：左——根——右</span></span><br><span class="line"><span class="comment"># 思想：按照栈的先进后出规则来实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InOrder2</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = []  <span class="comment"># 栈用来保存未访问节点</span></span><br><span class="line">    array = []  <span class="comment"># 保存节点值，作为结果</span></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="comment"># 从根节点开始，一直找它的左子树</span></span><br><span class="line">            <span class="comment"># 依次压入栈中</span></span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left  <span class="comment"># 一直往下找左子树</span></span><br><span class="line">        <span class="comment"># while结束表示当前节点root为空，即当前节点没有左子树了</span></span><br><span class="line"></span><br><span class="line">        root = stack.pop()  <span class="comment"># 从最左开始弹出</span></span><br><span class="line">        array.append(root.val)</span><br><span class="line">        <span class="comment"># 如果当前根节点有右子树</span></span><br><span class="line">        root = root.right</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归——后序遍历：左——右——根</span></span><br><span class="line"><span class="comment"># 思想：按照栈的先进后出规则来实现</span></span><br><span class="line"><span class="comment"># (ye是根右左的逆序)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PostOrder2</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = []</span><br><span class="line">    array = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br><span class="line"></span><br><span class="line">        root = stack.pop()</span><br><span class="line">        array.append(root.val)</span><br><span class="line">        <span class="comment"># 栈不空且刚刚弹出的是左子节点，那么应当继续去访问当前栈顶（前面左子节点弹出去了，现在就是栈顶）的右子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>].left == root:</span><br><span class="line">            root = stack[-<span class="number">1</span>].right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 没有右子树或右子树遍历完毕，强迫退栈,不然的话会一直输出右子树的值，死循环</span></span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历——队列"><a href="#层序遍历——队列" class="headerlink" title="层序遍历——队列"></a>层序遍历——队列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 层序遍历（宽度优先遍历BFS）</span></span><br><span class="line"><span class="comment"># 思想：利用队列，依次将根，左子树，右子树存入队列，按照队列的先进先出规则来实现层次遍历。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = [root]  <span class="comment"># 创建queue队列，保存节点</span></span><br><span class="line">    array = []  <span class="comment"># 保存节点值，作为结果</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        q = queue.pop(<span class="number">0</span>)  <span class="comment"># 拿出队首节点</span></span><br><span class="line">        array.append(q.val)  <span class="comment"># 注意是值！</span></span><br><span class="line">        <span class="keyword">if</span> q.left:  <span class="comment"># 若左节点存在</span></span><br><span class="line">            queue.append(q.left)  <span class="comment"># 放进队列</span></span><br><span class="line">        <span class="keyword">if</span> q.right:  <span class="comment"># 若右节点存在</span></span><br><span class="line">            queue.append(q.right)  <span class="comment"># 放进队列</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = TreeNode(<span class="number">10</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">15</span>)</span><br><span class="line">root.left.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">root.left.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.right.right = TreeNode(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PreOrder:&quot;</span>, PreOrder(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DFS:&quot;</span>, DFS(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;InOrder:&quot;</span>, InOrder(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;InOrder2:&quot;</span>, InOrder2(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PostOrder:&quot;</span>, PostOrder(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PostOrder2:&quot;</span>, PostOrder2(root))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;BFS:&quot;</span>, BFS(root))</span><br></pre></td></tr></table></figure>



<h3 id="☆层序遍历，牛客or力扣的输出不同"><a href="#☆层序遍历，牛客or力扣的输出不同" class="headerlink" title="☆层序遍历，牛客or力扣的输出不同"></a>☆层序遍历，牛客or力扣的输出不同</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="comment">#,#,5&#125;</span></span><br><span class="line">返回值：[[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self , root </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#先进先出</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue=[root]</span><br><span class="line">        array=[]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            array.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue])<span class="comment">#不要忘了加括号！！！</span></span><br><span class="line">            temp=[]<span class="comment">#存储当前层的孩子节点列表</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span>(node.left):</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span>(node.right):</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">            <span class="comment">#把queue更新成下一层的结点，继续遍历下一层</span></span><br><span class="line">            queue=temp</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="按之字形顺序打印二叉树-牛客"><a href="#按之字形顺序打印二叉树-牛客" class="headerlink" title="按之字形顺序打印二叉树(牛客)"></a>按之字形顺序打印二叉树(牛客)</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;1,2,3,#,#,4,5&#125;</span><br><span class="line">返回值：[[1],[3,2],[4,5]]</span><br></pre></td></tr></table></figure>

<p>加一个索引count判断是奇数还是偶数层，判断先左还是右，每一层都要倒序遍历上一层node</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Print</span>(<span class="params">self, pRoot</span>):</span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = [pRoot]</span><br><span class="line">    result = []</span><br><span class="line">    count = <span class="number">1</span>  <span class="comment"># 判断奇偶</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        result.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue])</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        temp = []  <span class="comment"># 存当前层</span></span><br><span class="line">        <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue[::-<span class="number">1</span>]:  <span class="comment"># 逆序遍历queue</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue[::-<span class="number">1</span>]:  <span class="comment"># 逆序遍历queue</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">        queue = temp</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210729205908092.png" alt="image-20210729205908092" style="zoom:33%;" />]]></content>
      <categories>
        <category>面试</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(6)——java</title>
    <url>/2022/02/06/QA_java/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-6-——java"><a href="#面试QA整理-6-——java" class="headerlink" title="面试QA整理(6)——java"></a>面试QA整理(6)——java</h1><p>面试官会问你熟悉的语言，我一般都说python，有些面试还会问些java，这里整理的比较少。</p>
<h2 id="面向对象的三大特征：封装性、继承性、多态性。"><a href="#面向对象的三大特征：封装性、继承性、多态性。" class="headerlink" title="面向对象的三大特征：封装性、继承性、多态性。"></a>面向对象的三大特征：封装性、继承性、多态性。</h2><p>封装性在Java当中的体现:</p>
<ul>
<li>1.方法就是一种封装</li>
<li>2.关键字private也是一 种封装</li>
</ul>
<p>封装就是将一 些细节信息隐藏起来，对于外界不可见。</p>
<p>继承是多态的前提，如果没有继承，就没有多态。<br>继承主要解决的问题就是：共性抽取。</p>
<p>多态</p>
<p>一个<strong>对象</strong>拥有多种形态，这就是:<strong>对象的多态性</strong>。<br><strong>多态</strong>： 是指同一行为，具有多个不同表现形式</p>
<p>小明是一个对象,<br>这个对象既有学生形态，也有人类形态。<br>一个对象拥有多种形态，这就是:<br>对象的多态性。</p>
<h2 id="对象的内存分配方式"><a href="#对象的内存分配方式" class="headerlink" title="对象的内存分配方式"></a>对象的内存分配方式</h2><p>Java堆这块内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在堆上分配。</p>
<p>创建对象内存分配</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804124648795.png" alt="image-20210804124648795" style="zoom:33%;" />

<p>Ⅰ、将内存进行了划分，一部分是年轻代（Young区），还有一部分是老年代（Old区）<br>Ⅱ、年轻代也进行了划分，分别是1个Eden区和2个Survivor区；Old区就是整个的一块<br>Ⅲ、new的对象产生在Eden区，当Eden区快满的时候，就会触发GC，这个GC是在Young区的，所以也叫Young GC,Young GC采用的是复制算法，把在Eden区需要删除的打上一个标记，不需要删除的复制到Survivor区（S0或者S1均可，内存大小 S0:S1:E区&#x3D;1：1：8）。<br>为什么要2块Survivor区？因为这两个S区是交替工作的，在E区打完标记后，不需要删除的被放到S0区，然后把E区+S1区一起删除，等下一次E区快满的时候，将不需要删除的被放到S1区，然后把E区+S0区一起删除…如此往复的工作，比将内存一分为二的效率要高一些的（主要是针对 对象的朝生夕死的特点去设计的）<br>Ⅳ、Old区：在每一次的Young GC的时候，存活下来的对象的年龄都会加1，直到年龄到达了？岁，它就不在Survivor区里面进行复制了，而是直接将不需要删除的对象放到Old区里面，因为之前的Young GC都没去掉，说明可能要过很久才能去掉；<br>除了存了年龄大于等于？岁的，还存了大的对象（如：1个1千万大小的int数组），Old区满的时候也会触发GC，Old GC一般也会伴随着Young GC,所以也叫做Full GC,Full GC会引起Stop-The-World,整个Java程序直接暂停，来全力的进行垃圾回收，</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804124511423.png" alt="image-20210804124511423" style="zoom:50%;" />

<h2 id="堆与栈区别"><a href="#堆与栈区别" class="headerlink" title="堆与栈区别"></a>堆与栈区别</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804123956413.png" alt="image-20210804123956413" style="zoom:55%;" />

<p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p>
<p>（2）空间大小不同。<strong>每个进程拥有的栈的大小要远远小于堆的大小</strong>。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，<strong>内存地址由低到高</strong>；栈的生长方向向下，<strong>内存地址由高到低</strong>。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p>
<p>（6）<strong>存放内容不同</strong>。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
<p>从以上可以看到，堆和栈相比，由于大量malloc()&#x2F;free()或new&#x2F;delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p>
<p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池</strong>：其实就是一个容纳多个线程的容器，其中的线程可以<u>反复使用</u>，【执行完一个任务，并不被销毁，而是可以继续执行其他的任务】。<u>省去了频繁创建线程对象的操作</u>，<u>无需反复创建线程而消耗过多资源</u>。</p>
<p><strong>合理利用线程池能够带来三个好处</strong>：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。使用线程池可以进行统一分配、调优和监控。可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下</li>
<li>(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>有三种方式可以用来创建线程：<br>继承Thread类<br>实现Runnable接口<br>应用程序可以使用Executor框架来创建线程池<br><strong>实现Runnable接口这种方式更受欢迎</strong>，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<hr>
<p>方式一、<strong>创建Thread类的子类</strong></p>
<p>实现步骤:</p>
<ul>
<li>1.创建一个Thread类的<strong>子类</strong></li>
<li>2.在Thread类的子类中<strong>重写Thread类中的run方法</strong>,设置线程任务(开启线程要做什么?)</li>
<li>3.创建Thread类的子类<strong>对象</strong></li>
<li>4.调用Thread类中的方法<strong>start方法</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726115133590.png" alt="image-20210726115133590" style="zoom:33%;" />

<p>方式二、<strong>实现Runnable接口</strong></p>
<p>实现步骤:</p>
<p>  1.创建<strong>一个Runnable接口的实现类</strong></p>
<p>  2.在实现类中<strong>重写Runnable接口的run方法</strong>,设置线程任务</p>
<p>  3.<strong>创建一个Runnable接口的实现类对象</strong></p>
<p>  4**.创建Thread类对象**,构造方法中<strong>传递Runnable接口的实现类对象</strong></p>
<p>  5.<strong>调用Thread类中的start方法,开启新的线程</strong>执行run方法</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726115244664.png" alt="image-20210726115244664" style="zoom:33%;" />

<h2 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h2><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p>
<ol>
<li><p>都是上层的抽象层。</p>
</li>
<li><p>都不能被实例化</p>
</li>
<li><p>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。<br>他们的区别如下：</p>
</li>
<li><p><strong>在抽象类中可以写非抽象的方法</strong>，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；<strong>接口中只能有抽象的方法</strong>。</p>
</li>
<li><p><strong>一个类只能继承一个直接父类</strong>，这个父类可以是具体的类也可是抽象类；<strong>但是一个类可以实现多个接口</strong>。</p>
</li>
</ol>
<h2 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h2><p>类是描述，对象是实例。</p>
<p>类与对象的关系<br>●<strong>类是</strong>对一类事物的<strong>描述</strong>,是<strong>抽象</strong>的。<br>●<strong>对象</strong>是一类事物的<strong>实例</strong>，是<strong>具体</strong>的。<br>●类是对象的模板，对象是类的实体。</p>
<p>类:是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</p>
<p>对象:是一类事物的具体体现。<strong>对象是类的一个实例</strong>，必然具备该类事物的属性和行为。</p>
<h2 id="object类中有哪些方法"><a href="#object类中有哪些方法" class="headerlink" title="object类中有哪些方法"></a>object类中有哪些方法</h2><p>boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”</p>
<p>public String toString(): 返回该对象的字符串表示。</p>
<p>void wait()<br>          在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</p>
<p>void notify()<br>          唤醒在此对象监视器上等待的单个线程。<br>          会继续执行wait方法之后的代码</p>
<p> Object类中wait带参方法</p>
<p>​            使用<strong>wait(long     m)<strong>方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒</strong>,就会自动醒来</strong>,线程睡醒进入到Runnable&#x2F;Blocked状态</p>
<p>唤醒的方法:</p>
<p>​    void notify() 唤醒在此对象监视器上等待的<strong>单个线程</strong>。</p>
<p>​    void notifyAll() 唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726114846192.png" alt="image-20210726114846192" style="zoom:50%;" />

<h2 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection<br>    List<br>        ArrayList<br>        LinkedList<br>        Vector</p>
<p>​    Set<br>​        HashSet<br>​            LinkedHashSet<br>​        TreeSet</p>
<p>Map<br>    HashMap<br>        LinkedHashMap</p>
<p>​    TreeMap<br>​    ConcurrentHashMap<br>​    Hashtable<br>数据容器主要分为了两类：</p>
<p>​    Collection: 存放独立元素的序列。</p>
<p>​    Map：存放key-value型的元素对。（这对于需要利用key查找value的程序十分的重要！）</p>
<h2 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h2><h3 id="HashMap的get方法能否判断某个元素是否在map中"><a href="#HashMap的get方法能否判断某个元素是否在map中" class="headerlink" title="HashMap的get方法能否判断某个元素是否在map中?"></a>HashMap的get方法能否判断某个元素是否在map中?</h3><p>HashMap 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，<strong>并允许使用 null 值和 null 键。</strong></p>
<p>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。<br>    • 返回值:V<br>        ○ key存在,返回对应的value值<br>        ○ <strong>key不存在,返回null</strong></p>
<p>boolean containsKey(Object key) 判断集合中是否包含指定的键。<br>    • 包含返回true,不包含返回false</p>
<h2 id="list-相关"><a href="#list-相关" class="headerlink" title="list 相关"></a>list 相关</h2><h3 id="arraylist和linkedlist区别"><a href="#arraylist和linkedlist区别" class="headerlink" title="arraylist和linkedlist区别"></a>arraylist和linkedlist区别</h3><p><strong>ArrayList集合</strong> </p>
<p>java.util.ArrayList 集合数据存储的结构是<strong>数组结构</strong>。元素<strong>增删慢，查找快</strong>，由于日常开发中使用最多的功能为</p>
<p>查询数据、遍历数据，所以 ArrayList 是最常用的集合。 </p>
<p><strong>LinkedList集合</strong> </p>
<p>java.util.LinkedList 集合数据存储的结构是<strong>链表结构</strong>。元素<strong>增删快，查找慢</strong>。 </p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法</p>
<h2 id="数组-Array-和列表-ArrayList-的区别"><a href="#数组-Array-和列表-ArrayList-的区别" class="headerlink" title="数组(Array)和列表(ArrayList)的区别"></a>数组(Array)和列表(ArrayList)的区别</h2><p>Array和ArrayList的不同点：<br>Array可以<strong>包含基本类型和对象类型</strong>，ArrayList<strong>只能包含对象类型</strong>。<br><strong>Array大小是固定的</strong>，<strong>ArrayList的大小是动态变化的。</strong><br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>Java提供了final 关键字,用于修饰不可改变内容。</p>
<p>final:不可改变。可以用于修饰类、方法和变量。</p>
<ul>
<li>类:被修饰的类，不能被继承。</li>
<li>方法:被修饰的方法，不能被重写。</li>
<li>变量:被修饰的变量，不能被重新赋值。</li>
</ul>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>关于static 关键字的使用，它可以用来修饰的成员变量和成员方法，</p>
<p>被修饰的成员是属于类的，而不是单单是属于某个对象的。</p>
<p>也就是说，既然属于类,就可以不靠创建对象来调用了。</p>
<p>凡是本类的对象，都共享同一份。</p>
<p> static关键字最基本的用法是：</p>
<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来</p>
<p>被static修饰的变量、被static修饰的方法统一属于类的<strong>静态资源，是类实例之间共享的，换言之，一处变、处处变</strong>。JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处：</p>
<p>1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了</p>
<p>2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。</p>
<p>3、避免静态资源类无限膨胀，这很好理解。</p>
<h2 id="简述一下servlet的生命周期"><a href="#简述一下servlet的生命周期" class="headerlink" title="简述一下servlet的生命周期"></a>简述一下servlet的生命周期</h2><p>Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段</p>
<p>servlet的生命周期就是从servlet出现到销毁的全过程。主要分为以下几个阶段:<br>加载类- -&gt;实例化(为对象分配空间)- -&gt; 初始化(为对象的属性赋值)一&gt; 请求处理(服务阶段)- &gt; 销毁</p>
<p>（1）加载和实例化</p>
<p>当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接读取该实例响应请求；如果不存在，就创建一个Servlet实例。</p>
<p>（2） 初始化</p>
<p>实例化后，Servlet容器将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）。</p>
<p>（3）服务</p>
<p>初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法。</p>
<p>（4）销毁</p>
<p>当Servlet容器关闭时，Servlet实例也随时销毁。其间，Servlet容器会调用Servlet 的destroy()方法去判断该Servlet是否应当被释放（或回收资源）。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726121132764.png" alt="image-20210726121132764" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726122315229.png" alt="image-20210726122315229" style="zoom:50%;" />

<p>servlet是干什么的</p>
<p>浏览器发送一个HTTP请求，HTTP请求由Web容器分配给特定的Servlet进行处理，Servlet的本质是一个Java对象，这个对象拥有一系列的方法来处理HTTP请求。常见的方法有doGet()，doPost()等。Web容器中包含了多个Servlet，特定的HTTP请求该由哪一个Servlet来处理是由Web容器中的web.xml来决定的。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210726122132556.png" alt="image-20210726122132556" style="zoom:50%;" />]]></content>
      <categories>
        <category>面试</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(7)——linux</title>
    <url>/2022/02/07/QA_linux/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-7-——linux"><a href="#面试QA整理-7-——linux" class="headerlink" title="面试QA整理(7)——linux"></a>面试QA整理(7)——linux</h1><h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720191224771.png" alt="image-20210720191224771" style="zoom:50%;" />

<p><strong>1、环境部署</strong><br><strong>①远程连接服务器操作(客户端连接服务器)</strong></p>
<p>ssh <a href="mailto:&#x72;&#111;&#x6f;&#116;&#64;&#x33;&#x39;&#x2e;&#49;&#50;&#x33;&#46;&#49;&#50;&#x34;&#x2e;&#x39;&#57;">&#x72;&#111;&#x6f;&#116;&#64;&#x33;&#x39;&#x2e;&#49;&#50;&#x33;&#46;&#49;&#50;&#x34;&#x2e;&#x39;&#57;</a></p>
<p>Xshell、VScode</p>
<p><strong>②常用命令(查看目录内容Is命令、当前工作目录pwd、切换工作目录cd、创建目录mkdir、</strong><br><strong>③文件操作(创建文件touch 、复制cp、移动mv重命名、删除rm  )</strong><br><strong>④压缩操作(解压)</strong></p>
<p><strong>文件压缩解压： zip、 unzip</strong>  </p>
<p><strong>压缩解压： gzip</strong>    .gz后缀，解压-d </p>
<p>打包 tar -cvf<br>解包 tar -xvf<br>查看包 tar -tvf </p>
<p><strong>tar只负责打包文件， 但不压缩</strong>，<br>在tar命令中增加一个选项**(-z)**可以调用gzip实现了一个压缩的功能， 实行一个先打包后压缩的过程</p>
<p>用gzip压缩tar打包后的文件， 其扩展名一般用xxxx.tar.gz  </p>
<p>解压到指定目录： -C （大写字母“C”）  </p>
<p><strong>⑤权限操作(切换账户、文件授权)</strong></p>
<p>切换用户:su  </p>
<p>exit退出当前登录用户</p>
<p>useradd添加用户</p>
<p>userdel删除用户</p>
<p>设置修改用户密码： passwd  用户名</p>
<p>whoami</p>
<p>修改文件权限： chmod  </p>
<p>字母法： <strong>chmod u&#x2F;g&#x2F;o&#x2F;a +&#x2F;-&#x2F;&#x3D; rwx 文件</strong>  </p>
<p><strong>⑥系统命令操作(进程相关、重启、关机)</strong> </p>
<p>df查看磁盘空间</p>
<p>ps显示系统进程，-aux查看所有进程详细信息（静态的看）<code>ps -aux</code></p>
<p>top动态查看进程信息（动态的看）</p>
<p>kill -9 pid 彻底终止进程</p>
<p>关机重启： reboot、 shutdown  </p>
<p><strong>⑦网络相关命令</strong></p>
<p>ping测试目标主机是否网络连通</p>
<p>ifconfig查看网卡信息</p>
<p><strong>2、日志查看</strong><br><strong>①文件查看(全部查看、从头查看、从尾查看、过滤)</strong></p>
<p><strong>cat</strong>一次显示所有</p>
<p>分屏显示： <strong>more</strong>  </p>
<p>查看或者合并文件内容： cat  </p>
<p>cat test1.txt test2.txt  </p>
<p><strong>文本搜索： grep</strong>  </p>
<p>grep ‘a’ 1.txt  </p>
<p>grep搜索内容串可以是正则表达式  </p>
<p>正则表达式是对字符串操作的一种逻辑公式， 就是用事先定义好的一些特定字符、 及这些特定字符的组合， 组成一个“规则字符串”， 这个“规则字符串”用来表达对字符串的一种过滤逻辑。 </p>
<p><strong>②文件编辑(编辑器命令)</strong></p>
<p>Vi有三种基本工作模式：</p>
<ul>
<li>命令模式</li>
<li>文本输入模式</li>
<li>末行模式</li>
</ul>
<p>进入插入模式  ：</p>
<p>i: 插入光标前一个字符<br>I: 插入行首<br>a: 插入光标后一个字符<br>A: 插入行未<br>o: 向下新开一行,插入行首<br>O: 向上新开一行,插入行首  </p>
<p>ESC:从插入模式或末行模式进入命令模式  </p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720203810405.png" alt="image-20210720203810405" style="zoom:50%;" />

<p><strong>输出重定向命令： &gt;</strong>  </p>
<p>ls &gt; test.txt ( test.txt 如果不存在， 则创建， 存在则覆盖其内容 )  </p>
<p>注意： &gt;输出重定向会覆盖原来的内容， &gt;&gt;输出重定向则会追加到文件的尾部。  </p>
<p>**建立链接文件： ln  **</p>
<p>查找文件： find  </p>
<p>查看命令位置： which  </p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720193209929.png" alt="image-20210720193209929" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720193432623.png" alt="image-20210720193432623" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720192600417.png" alt="image-20210720192600417" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720193343475.png" alt="image-20210720193343475" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720193756947.png" alt="image-20210720193756947" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720193853229.png" alt="image-20210720193853229" style="zoom:33%;" />

<h2 id="查看Linux端口占用-lsof-i-端口号-x2F-netstat-tunlp-grep-端口号"><a href="#查看Linux端口占用-lsof-i-端口号-x2F-netstat-tunlp-grep-端口号" class="headerlink" title="查看Linux端口占用(lsof -i: 端口号&#x2F;netstat -tunlp|grep 端口号)"></a>查看Linux端口占用(lsof -i: 端口号&#x2F;netstat -tunlp|grep 端口号)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i: 端口号</span><br><span class="line">netstat -tunlp|grep 端口号</span><br><span class="line"></span><br><span class="line">-t (tcp) 仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-1 仅列出有在Listen (监听)的服務状态</span><br><span class="line">-P 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure>

<h2 id="kill-15-和-kill-9-的区别"><a href="#kill-15-和-kill-9-的区别" class="headerlink" title="kill -15 和 kill -9 的区别"></a>kill -15 和 kill -9 的区别</h2><p>kill -9 PID 是操作系统从内核级别<strong>强制杀死一个进程.</strong> killed</p>
<p>kill -15 PID 可以理解为操作系统<strong>发送一个通知告诉应用主动关闭</strong>. terminated</p>
<p>SIGTERM（15） 的效果是正常退出进程，退出前可以被阻塞或回调处理。并且它是Linux缺省的程序中断信号。</p>
<p>当使用<code>kill -15</code>时，系<strong>统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</strong></p>
<p>这时候，应用程序可以选择：</p>
<ul>
<li>1、立即停止程序</li>
<li>2、释放响应资源后停止程序</li>
<li>3、忽略该信号，继续执行程序</li>
</ul>
<p>因为<code>kill -15</code>信号只是通知对应的进程要进行”安全、干净的退出”，程序接到信号之后，退出前一般会进行一些”准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。但是，如果在”准备工作”进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。这也就是为什么我们有的时候使用kill命令是没办法”杀死”应用的原因，因为<strong>默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。</strong>和<code>kill -15</code>相比，<code>kill -9</code>就相对强硬一点，系统会发出<strong>SIGKILL信号，</strong>他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。所以，<strong>相比于kill -15命令，kill -9在执行时，应用程序是没有时间进行”准备工作”的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。</strong></p>
<h2 id="Linux前台进程和后台进程区别"><a href="#Linux前台进程和后台进程区别" class="headerlink" title="Linux前台进程和后台进程区别"></a>Linux前台进程和后台进程区别</h2><p><strong>前台进程：</strong>是<strong>在终端中运行</strong>的命令，那么该终端就为进程的控制终端<strong>，一旦这个终端关闭，这个进程也随之消失</strong>。</p>
<p><strong>后台进程：</strong>也叫守护进程(Daemon)，是运行在后台的一种特殊进程，<strong>不受终端控制，它不需要终端的交互</strong>；Linux的大多数服务器就是使用守护进程实现的。比如Web服务器的httpd等。</p>
<h2 id="修改文件权限chmod"><a href="#修改文件权限chmod" class="headerlink" title="修改文件权限chmod"></a>修改文件权限chmod</h2><p>字母法： <strong>chmod u&#x2F;g&#x2F;o&#x2F;a +&#x2F;-&#x2F;&#x3D; rwx 文件</strong> </p>
<p>读，写，执行。对应字母为 r、w、x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ugoa...]</span><br><span class="line">u表示该档案的拥有者user，g表示与该档案的拥有者属于同一个群体group者，o表示其他other以外的人，a表示所有all（包含上面三者）。</span><br><span class="line">[+-=]</span><br><span class="line">+ 表示增加权限，- 表示取消权限，= 表示唯一设定权限。</span><br><span class="line">[rwxX]</span><br><span class="line">r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行</span><br></pre></td></tr></table></figure>

<p>规定数字 4 、2 和 1表示读、写、执行权限，即r&#x3D;4，w&#x3D;2，x&#x3D;1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如：</span><br><span class="line">rwx = 4 + 2 + 1 = 7</span><br><span class="line">rw = 4 + 2 = 6</span><br><span class="line">rx = 4 +1 = 5</span><br><span class="line">即</span><br><span class="line">若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7</span><br><span class="line">若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6</span><br><span class="line">若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5</span><br></pre></td></tr></table></figure>

<p>每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。即我们可以用用三个8进制数字分别表示 拥有者 、群组 、其它组( u、 g 、o)的权限详情，并用chmod直接加三个8进制数字的方式直接改变文件权限</p>
<h2 id="递归地创建目录-mkdir-p-a-x2F-b-x2F-c"><a href="#递归地创建目录-mkdir-p-a-x2F-b-x2F-c" class="headerlink" title="递归地创建目录 mkdir -p a&#x2F;b&#x2F;c"></a>递归地创建目录 mkdir -p a&#x2F;b&#x2F;c</h2><p>当你要创建的目录包含子目录时，你需要使用 -p 参数。如果 mkdir 找不到父目录，那么这个参数会首先帮助创建父目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p a/b/c</span><br></pre></td></tr></table></figure>

<h2 id="查看CPU的使用效率-top"><a href="#查看CPU的使用效率-top" class="headerlink" title="查看CPU的使用效率 top"></a>查看CPU的使用效率 top</h2><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><p>AWK， 数据过滤工具  (类似于grep，比grep强大)，属数据处理引擎，<strong>基于模式匹配检查输入文本，逐行处理并输出</strong>。通常用在Shell脚本中，获取指定的数据，单独使用时，可对文本数据做统计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk是行处理器</span><br><span class="line">awk处理过程: 依次对每一行进行处理，然后输出</span><br><span class="line">格式1：前置命令 | awk [选项] ‘条件&#123;编辑指令&#125;&#x27;</span><br><span class="line">格式2：awk [选项] ‘条件&#123;编辑指令&#125;&#x27;  文件...</span><br><span class="line"></span><br><span class="line">编辑指令如果包含多条语句时，可以用分号分隔，处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。print是最常见的指令。</span><br><span class="line">FS保存或设置字段分隔符，如FS=&#x27;:&#x27;</span><br><span class="line">$n指定分隔的第n个字段，如$1、$3分别表示第1、第3列</span><br><span class="line">$0当前读入的整行文本内容</span><br><span class="line">NF记录当前处理行的字段个数（列数），输出最后一列$NF，输出倒数第二列：$(NF-1)</span><br><span class="line">NR记录当前已读入行的数量（行数），awk &#x27;&#123;print NR&#125;&#x27; test.txt</span><br><span class="line">FNR当前行在源文件中的行号。awk &#x27;&#123;print &quot;第&quot; FNR &quot;行&quot;,&quot;有&quot; NF &quot;列&quot;&#125;&#x27; test.txt</span><br><span class="line"></span><br><span class="line">-F参数：指定分隔符，可指定一个或多个，可省略（默认空格或Tab位）</span><br><span class="line">	   若未指定分隔符，则默认将 空格、制表符 作为分隔符。(若指定了，则不默认)</span><br><span class="line">	   指定多个分隔符，要加中括号[]。</span><br><span class="line">	   [ :]+这个是正则表达式，+表示一个或多个，这里就表示一个或多个空格或冒号</span><br><span class="line">print 后面做字符串的拼接</span><br><span class="line">	  $1表示输出第一列</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[ :]+这个是正则表达式，+表示一个或多个，这里就表示一个或多个空格或冒号</span></span><br><span class="line"><span class="comment">#格式1写法</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;1:2::3:::4::::5&quot;</span> | awk -F <span class="string">&#x27;[:]+&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">结果为4</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;1:2::3:::4::::5&quot;</span> | awk -F <span class="string">&#x27;[:]&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">去掉+号，结果为3</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;1:2::3:::4::::5&quot;</span> | awk -F <span class="string">&#x27;[:]&#x27;</span> <span class="string">&#x27;&#123;print $7&#125;&#x27;</span></span><br><span class="line">去掉+号，这时候第7列才为4</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">test.txt内容：(一个制表符，一个空格)</span><br><span class="line">123,456\t789:<span class="built_in">test</span>/abcd efg</span><br><span class="line"><span class="comment">#指定多个分隔符，要加中括号[]</span></span><br><span class="line"><span class="comment">#表示以空格、冒号和tab作为分隔符</span></span><br><span class="line"><span class="comment">#print 后面做字符串的拼接,$1表示输出第一列,$1表示输出第二列.....</span></span><br><span class="line">awk -F <span class="string">&#x27;[ :\t]&#x27;</span> <span class="string">&#x27;&#123;print &quot;第一列&quot;$1&quot;第二列&quot;$2&quot;第三列&quot;$3&#125;&#x27;</span> test.txt</span><br><span class="line">第一列123,456第二列第三列789</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">test.txt内容：(两行，每行都有一个制表符，一个空格)</span><br><span class="line">123,456\t789:<span class="built_in">test</span>/abcd efg</span><br><span class="line">123,456\t789:<span class="built_in">test</span>/abcd efg</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> test.txt</span><br><span class="line">123,456  789:<span class="built_in">test</span>/abcd efg</span><br><span class="line">123,456  789:<span class="built_in">test</span>/abcd efg</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print &quot;$0&quot;&#125;&#x27;</span> test.txt <span class="comment">#加了双引号就是字符串了！！</span></span><br><span class="line"><span class="variable">$0</span></span><br><span class="line"><span class="variable">$0</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print NF&#125;&#x27;</span> test.txt</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出最后一列$NF，输出倒数第二列：$(NF-1)</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> test.txt <span class="comment">#默认空格或Tab位分隔</span></span><br><span class="line">efg</span><br><span class="line">efg</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print $(NF-1)&#125;&#x27;</span> test.txt <span class="comment">#默认空格或Tab位分隔</span></span><br><span class="line">789:<span class="built_in">test</span>/abcd</span><br><span class="line">789:<span class="built_in">test</span>/abcd</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print NR&#125;&#x27;</span> test.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;print &quot;第&quot; FNR &quot;行&quot;,&quot;有&quot; NF &quot;列&quot;&#125;&#x27;</span> test.txt <span class="comment">#默认空格或Tab位分隔</span></span><br><span class="line">第1行 有3列</span><br><span class="line">第2行 有3列</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [选项] <span class="string">&#x27;BEGIN&#123;编辑指令&#125;&#123;编辑指令&#125;END&#123;编辑指令&#125;&#x27;</span> 文件</span><br><span class="line">---------------------------------------------</span><br><span class="line">RS：Record Separator，记录行分隔符</span><br><span class="line">找到某某标志，让每个某某后的内容重新变成一行</span><br><span class="line">test.txt</span><br><span class="line">a|b|c</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123; RS=&quot;|&quot;&#125;&#123; print $0 &#125;&#x27;</span> test.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">---------------------------------------------</span><br><span class="line">ORS：Output Record Separate，输出当前记录行分隔符</span><br><span class="line">ORS：可以看成RS的逆向过程。</span><br><span class="line">观察每一行的“换行符号”，然后将“换行符号”替换成你想要的符号。</span><br><span class="line">test.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;ORS=&quot;----&quot;&#125;&#123;print $0&#125;&#x27;</span> test.txt</span><br><span class="line">a----b----c----</span><br><span class="line">---------------------------------------------</span><br><span class="line">FS：Field Separator，字段分隔符</span><br><span class="line">FS默认值为“（空格）”</span><br><span class="line">test.txt</span><br><span class="line">a----b----c----</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;----&quot;&#125;&#123;print $1,$2,$3 &#125;&#x27;</span> test.txt</span><br><span class="line">a b c</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;----&quot;&#125;&#123;print $1 $2 $3 &#125;&#x27;</span> test.txt</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">注意BEGIN用法</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;&#125;&#123;print $1 $2 $3 &#125;&#x27;</span> test.txt</span><br><span class="line">a----b----c----</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print $1 $2 $3 &#125;&#x27;</span> test.txt</span><br><span class="line">无输出！！！！</span><br><span class="line">awk <span class="string">&#x27;&#123;print $1 $2 $3 &#125;&#x27;</span> test.txt</span><br><span class="line">a----b----c----</span><br><span class="line">---------------------------------------------</span><br><span class="line">OFS：Out of Field Separator，输出字段分隔符</span><br><span class="line">如上例中“a----b----c----”，“----”为分隔符(FS)，如果我们想改为用其他符号显示可以这样</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;----&quot;;OFS=&quot;*****&quot; &#125;&#123;print $1,$2,$3 &#125;&#x27;</span> test.txt</span><br><span class="line">a*****b*****c</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;----&quot;;OFS=&quot;*****&quot; &#125;&#123;print $1,$2,$3,$4 &#125;&#x27;</span> test.txt</span><br><span class="line">a*****b*****c*****</span><br><span class="line"></span><br><span class="line">OFS还有一个例子</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | awk <span class="string">&#x27;&#123;OFS=&quot;.&quot;&#125;&#123;NF=NF;print NF,$0&#125;&#x27;</span></span><br><span class="line">1.abc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | awk <span class="string">&#x27;&#123;OFS=&quot;、&quot;&#125;&#123;NF=NF;print NF,$0&#125;&#x27;</span></span><br><span class="line">1、abc</span><br><span class="line"></span><br><span class="line">test.txt</span><br><span class="line">abc</span><br><span class="line">def</span><br><span class="line">awk <span class="string">&#x27;&#123;OFS=&quot;.&quot;&#125;&#123;NF=NF;print NF,$0&#125;&#x27;</span> test.txt</span><br><span class="line">1.abc</span><br><span class="line">1.def</span><br><span class="line">awk <span class="string">&#x27;&#123;OFS=&quot;.&quot;&#125;&#123;print NF,$0&#125;&#x27;</span> test.txt</span><br><span class="line">1.abc</span><br><span class="line">1.def</span><br><span class="line">awk <span class="string">&#x27;&#123;OFS=&quot;.&quot;&#125;&#123;NR=NR;print NR,$0&#125;&#x27;</span> test.txt</span><br><span class="line">1.abc</span><br><span class="line">2.def</span><br><span class="line">awk <span class="string">&#x27;&#123;OFS=&quot;.&quot;&#125;&#123;print NR,$0&#125;&#x27;</span> test.txt</span><br><span class="line">1.abc</span><br><span class="line">2.def</span><br></pre></td></tr></table></figure>

<p>【例一】只查看test.txt文件（100行）内第20到第30行的内容（企业面试）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NR&gt;=20 &amp;&amp; NR&lt;=30) print $0&#125;&#x27;</span> test.txt</span><br></pre></td></tr></table></figure>

<p>【例二】已知test.txt文件内容为：I am Poe,, my qq is 33794712 （Poe后面是逗号逗号空格）</p>
<p>请从该文件中过滤出’Poe’字符串与33794712，最后输出的结果为：Poe 33794712</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;[ ,]+&#x27;</span> <span class="string">&#x27;&#123;print $3&quot; &quot;$7&#125;&#x27;</span> test.txt</span><br><span class="line">Poe 33794712</span><br><span class="line"></span><br><span class="line"><span class="comment">#不加+号就有问题</span></span><br><span class="line">awk -F <span class="string">&#x27;[ ,]&#x27;</span> <span class="string">&#x27;&#123;print $3&quot; &quot;$7&#125;&#x27;</span> test.txt</span><br><span class="line">Poe qq</span><br></pre></td></tr></table></figure>

<p>【例三】已知test.txt文件，内容用\t分隔，请输出第二列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aaa	bbb	ccc</span><br><span class="line">111	222	333</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;[\t]&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> test.txt</span><br><span class="line">bbb</span><br><span class="line">222</span><br></pre></td></tr></table></figure>

<p>【例四】linux中一test.txt文件，共有4列，每列之间用tab隔开。现想把第二列复制一次，插入到第二列后。生成5列用tab分割的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1     132     T     G</span><br><span class="line">1     245     T     C</span><br><span class="line">转换成</span><br><span class="line">1       132     132     T       G</span><br><span class="line">1       245     245     T       C</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;\t&quot;;OFS=&quot;\t&quot;&#125; $2=$2&quot;\t&quot;$2&#x27;</span> test.txt &gt; result.txt</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">其他输出看一下：</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;\t&quot;;OFS=&quot;\t&quot;&#125; $2=$2&quot;\t&quot;$2&#x27;</span> test.txt</span><br><span class="line">1       132     132     T       G</span><br><span class="line">1       245     245     T       C</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;\t&quot;&#125; $2=$2&quot;\t&quot;$2&#x27;</span> test.txt</span><br><span class="line">1 132   132 T G</span><br><span class="line">1 245   245 T C</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;FS=&quot;\t&quot;;OFS=&quot;,&quot;&#125; $2=$2&quot;\t&quot;$2&#x27;</span> test.txt</span><br><span class="line">1,132   132,T,G</span><br><span class="line">1,245   245,T,C</span><br></pre></td></tr></table></figure>

<p>【例五】计算在200以内，能同时被3和13整除的整数个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 200 |awk <span class="string">&#x27;BEGIN&#123;i=0&#125; ($0%3==0)&amp;&amp;($0%13==0) &#123;i++&#125;END&#123;print i&#125;&#x27;</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">注意中间条件判断是不加&#123;&#125;的。</span><br><span class="line">其中：</span><br><span class="line"><span class="built_in">seq</span> 200</span><br><span class="line">输出为：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">...</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line"></span><br><span class="line"><span class="built_in">seq</span> 200 |awk <span class="string">&#x27;BEGIN&#123;i=0&#125; ($0%3==0)&amp;&amp;($0%13==0) &#123;print $0;i++&#125;&#x27;</span></span><br><span class="line">39</span><br><span class="line">78</span><br><span class="line">117</span><br><span class="line">156</span><br><span class="line">195</span><br></pre></td></tr></table></figure>

<p>【例六】输出偶数行文本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;i=0&#125; FNR%2==0 &#123;print FNR,$0;i++&#125;END&#123;print &quot;偶数行有&quot; i &quot;行&quot;&#125;&#x27;</span> test.txt</span><br><span class="line">2 bbb</span><br><span class="line">4 ddd</span><br><span class="line">偶数行有2行</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;i=0&#125; FNR%2==0 &#123;print FNR,$0;i++&#125;&#x27;</span> test.txt</span><br><span class="line">2 bbb</span><br><span class="line">4 ddd</span><br></pre></td></tr></table></figure>

<h2 id="linux中awk下-gsub、sub函数用法"><a href="#linux中awk下-gsub、sub函数用法" class="headerlink" title="linux中awk下 gsub、sub函数用法"></a>linux中awk下 gsub、sub函数用法</h2><p>gsub函数则使得在所有正则表达式被匹配的时候都发生替换</p>
<p>gsub匹配所有的符合模式的字符串</p>
<p><strong>gsub</strong>(regular expression, subsitution string, target string);简称 gsub（r,s,t)</p>
<p>sub和gsub的区别：</p>
<p>sub匹配<strong>第一次</strong>出现的符合模式的字符串。<br>gsub匹配<strong>所有的</strong>符合模式的字符串</p>
<p>gsub返回的是替换的次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.txt内容：</span><br><span class="line">0001|20081223efskjfdj|EREADFASDLKJCV</span><br><span class="line">0002|20081208djfksdaa|JDKFJALSDJFsddf</span><br><span class="line">0003|20081208efskjfdj|EREADFASDLKJCV</span><br><span class="line">0004|20081211djfksdaa1234|JDKFJALSDJFsddf</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span>  <span class="string">&#x27;&#123;sub(/[0-9]+/,&quot;&quot;,$2);print $0&#125;&#x27;</span> test.txt</span><br><span class="line">0001 efskjfdj EREADFASDLKJCV</span><br><span class="line">0002 djfksdaa JDKFJALSDJFsddf</span><br><span class="line">0003 efskjfdj EREADFASDLKJCV</span><br><span class="line">0004 djfksdaa1234 JDKFJALSDJFsddf</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span>  <span class="string">&#x27;&#123;gsub(/[0-9]+/,&quot;&quot;,$2);print $0&#125;&#x27;</span> test.txt</span><br><span class="line">0001 efskjfdj EREADFASDLKJCV</span><br><span class="line">0002 djfksdaa JDKFJALSDJFsddf</span><br><span class="line">0003 efskjfdj EREADFASDLKJCV</span><br><span class="line">0004 djfksdaa JDKFJALSDJFsddf 看这里会发现后面1234页被替换了</span><br></pre></td></tr></table></figure>

<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p><strong>tail -f filename</strong> 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p>
<ul>
<li>-f 循环读取</li>
<li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li>
<li><code>tail -n +5 1.log</code>显示文件1.log<strong>从第 5行至文件末尾</strong> 的内容</li>
<li><code>tail -n -5 1.log</code>    or    <code>tail -n 5 1.log</code>显示的结果相同，均是文件末尾<strong>最后 5 行</strong>内容。</li>
</ul>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><p>对linux命令的输出结果进行再次处理，就可以使用管道符+管道命令</p>
<p>ps命令可以查看系统中的进程，但如果需要查看指定进程，就需要在ps命令返回的结果中进行筛选，如查看java进程：<code>ps -aux |grep java</code></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721154500795.png" alt="image-20210721154500795" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721154517235.png" alt="image-20210721154517235" style="zoom:33%;" />

<h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>在linux 下scp 命令主要<strong>用来在不同主机之间做数据的安全拷贝</strong>的。</p>
<p>scp 命令可以将文件从本地的计算机中拷贝到远程的主机中，或者从远程计算机中拷贝文件到本地主机，</p>
<p>scp命令使用的安全加密的协议，所以在远程拷贝数据的时候会比较安全，不会被黑客截取。</p>
<h3 id="linux实例"><a href="#linux实例" class="headerlink" title="linux实例"></a>linux实例</h3><h3 id="一个文件夹下有多个文件夹，如何删除该目录下的所有txt文件？"><a href="#一个文件夹下有多个文件夹，如何删除该目录下的所有txt文件？" class="headerlink" title="一个文件夹下有多个文件夹，如何删除该目录下的所有txt文件？"></a>一个文件夹下有多个文件夹，如何删除该目录下的所有txt文件？</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">find .<span class="operator">/</span> <span class="operator">-</span>name &quot;*.txt&quot; <span class="operator">|</span> xargs rm <span class="operator">-</span>rf</span><br></pre></td></tr></table></figure>

<h3 id="查找当前目录以及子目录下以-c结尾的，且包含”hello”的文件——-find-grep-xargs"><a href="#查找当前目录以及子目录下以-c结尾的，且包含”hello”的文件——-find-grep-xargs" class="headerlink" title="查找当前目录以及子目录下以.c结尾的，且包含”hello”的文件—— find grep xargs"></a>查找当前目录以及子目录下以.c结尾的，且包含”hello”的文件—— find grep xargs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.c&quot;| xargs grep &quot;hello&quot; -on</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190824215205478.png" alt="img"></p>
<p>可以看到结果中显示了符合要求的文件，及该文件包含hello的行数</p>
<ul>
<li><p>find命令</p>
<p>-type f 表示文件要寻找的是文件</p>
<p>-name “*.txt” 表示文件名为 .txt结尾的 所有文件。 *表示所有</p>
</li>
<li><p>参数代换命令：xargs。xargs表示展开find获得的结果，使其作为grep的参数</p>
</li>
<li><p>grep的-o参数只显示匹配的内容，-n参数是显示匹配的行数（如果不写o，会把匹配的那一行所有都显示出来</p>
</li>
</ul>
<h3 id="linux查找目录下包含字符串aaa的文件"><a href="#linux查找目录下包含字符串aaa的文件" class="headerlink" title="linux查找目录下包含字符串aaa的文件"></a>linux查找目录下包含字符串aaa的文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -rn &quot;aaa&quot; ./</span><br><span class="line">find ./ -name &quot;*.*&quot; | xargs grep &quot;aaa&quot;</span><br><span class="line">find . | xargs grep -r &quot;aaa&quot;</span><br></pre></td></tr></table></figure>



<h3 id="统计一个文件中某个-x2F-多个字符串出现次数——grep或awk"><a href="#统计一个文件中某个-x2F-多个字符串出现次数——grep或awk" class="headerlink" title="统计一个文件中某个&#x2F;多个字符串出现次数——grep或awk"></a>统计一个文件中某个&#x2F;多个字符串出现次数——grep或awk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单个字符串可以不加引号</span><br><span class="line">grep -o str filename|<span class="built_in">wc</span> -l</span><br><span class="line">多个字符串,必须加引号（单、双都可以）</span><br><span class="line">grep -o <span class="string">&quot;Str_1\|Str_2\|Str_3… filename | wc -l</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">最佳：awk &#x27;&#123;s+=gsub(/000/,&quot;</span>@<span class="string">&quot;)&#125;END&#123;print s&#125;&#x27; test.txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">awk -v RS=&quot;</span>@<span class="comment">#$%%^&amp;**&quot; &#x27;&#123;print gsub(/000/,&quot;%&quot;)&#125;&#x27; test.txt</span></span><br><span class="line">RS里写什么？这个看具体情况把，只要你指定的RS没有在整段文本中出现过就行</span><br><span class="line">%写啥都行，gsub函数是把前面的targetstr替换成后后面的%，替换成啥不重要，重要的是替换成功了多少次，所以都行的</span><br><span class="line">awk -v RS=<span class="string">&quot;@#<span class="variable">$j</span>&quot;</span> <span class="string">&#x27;&#123;print gsub(/targetStr/,&quot;&amp;&quot;)&#125;&#x27;</span> filename</span><br><span class="line">awk  <span class="string">&#x27;&#123;s+=gsub(/targetStr/,&quot;&amp;&quot;)&#125;END&#123;print s&#125;&#x27;</span> filename</span><br><span class="line"></span><br><span class="line">RS：Record Separator，记录行分隔符；找到某某标志，让每个某某后的内容重新变成一行！！</span><br><span class="line">-v定义变量 var=value</span><br><span class="line"></span><br><span class="line">文件1.txt内容：abc@def<span class="comment">#ghi,jkl</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;RS=&quot;[@#]&quot;&#125;&#123;print $0&#125;&#x27;</span> 1.txt</span><br><span class="line">abc</span><br><span class="line">def</span><br><span class="line">ghi,jkl</span><br><span class="line"></span><br><span class="line">awk -v RS=<span class="string">&quot;[@#]&quot;</span> <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> 1.txt</span><br><span class="line">abc</span><br><span class="line">def</span><br><span class="line">ghi,jkl</span><br></pre></td></tr></table></figure>

<p><code>grep -o</code> 一条数据里面有多个相同，会统计相同的次数<br><code>grep</code> 一条数据里面有多个相同，会统计一次次数</p>
<p>对linux命令的输出结果进行再次处理，就可以使用管道符</p>
<p><code>wc</code> 命令使用 <code>-l</code> 命令选项来打印文件中的新行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.txt 文件内容：</span><br><span class="line">123	456	789</span><br><span class="line">aaa	bbb	ccc</span><br><span class="line"></span><br><span class="line">grep -o <span class="string">&#x27;a\|1&#x27;</span> test.txt</span><br><span class="line">1</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">grep <span class="string">&#x27;a&#x27;</span> test.txt</span><br><span class="line">aaa     bbb     ccc</span><br><span class="line"></span><br><span class="line">grep -n <span class="string">&#x27;a&#x27;</span> test.txt</span><br><span class="line">2:aaa   bbb     ccc</span><br><span class="line"></span><br><span class="line">grep -o <span class="string">&#x27;a&#x27;</span> test.txt</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">grep -on <span class="string">&#x27;a&#x27;</span> test.txt</span><br><span class="line">2:a</span><br><span class="line">2:a</span><br><span class="line">2:a</span><br><span class="line"></span><br><span class="line">grep -n <span class="string">&#x27;a&#x27;</span> test.txt|<span class="built_in">wc</span> -l</span><br><span class="line">1</span><br><span class="line">grep <span class="string">&#x27;a&#x27;</span> test.txt|<span class="built_in">wc</span> -l</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">grep -on <span class="string">&#x27;a&#x27;</span> test.txt|<span class="built_in">wc</span> -l</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="一段linux上统计平均响应时间的awk脚本"><a href="#一段linux上统计平均响应时间的awk脚本" class="headerlink" title="一段linux上统计平均响应时间的awk脚本"></a>一段linux上统计平均响应时间的awk脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;15:10:00&#x27;</span> daily-2015-12-20.log| grep <span class="string">&#x27;RESPONSE&#x27;</span>|awk <span class="string">&#x27;BEGIN &#123;t = 0;&#125; &#123;split($10,a,&quot;=&quot;);t+=a[2];&#125; END &#123;print t/NR;&#125;&#x27;</span></span><br><span class="line">NR	已经读出的记录数，就是行号</span><br></pre></td></tr></table></figure>

<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>test.sh中第一行一定是 “#! &#x2F;bin&#x2F;bash” 它代表的意思是，该文件使用的是bash语法。如果不设置该行，那么你的shell脚本就不能被执行。</p>
<p>Shell脚本的执行很简单，直接”sh test.sh“ 即可，另外你还可以这样执行：<code>chmod +x test.sh</code> <code>./test.sh</code></p>
<p>默认我们用vim编辑的文档是不带有执行权限的，所以需要加一个执行权限，那样就可以直接使用’.&#x2F;filename’ 执行这个脚本了。</p>
<p>另外使用sh命令去执行一个shell脚本的时候是可以加-x选项，”sh -x test.sh“来查看这个脚本执行过程的</p>
<p>定义变量的格式为 “变量名&#x3D;变量的值”。当在脚本中引用变量时需要加上’$’符号</p>
<p>数学计算要用’[ ]’括起来并且外头要带一个’$’</p>
<p>read命令，它可以从标准输入获得变量的值，后跟变量名。”read x”表示x变量的值需要用户通过键盘输入得到</p>
<p>read -p 选项类似echo的作用。</p>
<p>shell脚本的预设变量。shell脚本在执行的时候后边是可以跟变量的，而且还可以跟多个。</p>
<p>$1和$2，这其实就是shell脚本的预设变量，其中$1和$2的值就是在执行的时候输入的。另外还有一个$0，不过它代表的是脚本本身的名字。</p>
<h3 id="写一个shell脚本，在一个文件夹中有多个日志，每个日志里面记录了一些访问信息，统计该文件夹下所有日志文件中，带有toutiao的字段出现了多少次"><a href="#写一个shell脚本，在一个文件夹中有多个日志，每个日志里面记录了一些访问信息，统计该文件夹下所有日志文件中，带有toutiao的字段出现了多少次" class="headerlink" title="写一个shell脚本，在一个文件夹中有多个日志，每个日志里面记录了一些访问信息，统计该文件夹下所有日志文件中，带有toutiao的字段出现了多少次"></a>写一个shell脚本，在一个文件夹中有多个日志，每个日志里面记录了一些访问信息，统计该文件夹下所有日志文件中，带有toutiao的字段出现了多少次</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">grep -r <span class="string">&quot;toutiao&quot;</span> xpt/abc |<span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line">xpt/abc：文件夹xpt下的abc文件夹中有多个日志</span><br><span class="line">运行sh test.sh</span><br></pre></td></tr></table></figure>



<h2 id="linux的用户态和内核态有什么区别"><a href="#linux的用户态和内核态有什么区别" class="headerlink" title="linux的用户态和内核态有什么区别"></a>linux的用户态和内核态有什么区别</h2><p>通过<strong>系统调用</strong>将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。</p>
<p>那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种<strong>特殊的软件程序</strong>，特殊在哪儿呢？<strong>控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行</strong>。</p>
<p><strong>用户态就是提供应用程序运行的空间</strong>，为了使应用程序访问到内核管理的资源例如CPU，内存，I&#x2F;O。内核必须提供一组通用的访问接口，这些接口就叫<strong>系统调用。</strong></p>
<p>从用户态到内核态切换可以通过三种方式：</p>
<ol>
<li>系统调用，其实系统调用本身就是中断，但是软件中断，跟硬中断不同。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。</li>
<li>外设中断：当外设完成用户的请求时，会向CPU发送中断信号。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(8)——常考编程题</title>
    <url>/2022/02/08/QA_code/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-8-——常考编程题"><a href="#面试QA整理-8-——常考编程题" class="headerlink" title="面试QA整理(8)——常考编程题"></a>面试QA整理(8)——常考编程题</h1><h2 id="大文件-多路归并-排序"><a href="#大文件-多路归并-排序" class="headerlink" title="大文件 多路归并 排序"></a>大文件 多路归并 排序</h2><p>分割为小文件+多路归并排序</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210816131843573.png" alt="image-20210816131843573" style="zoom:50%;" />

<p>基本思路：</p>
<p><strong>step1：分割+排序</strong><br>从头开始将大文件FileFile的一个小部分读入内存中，将这一小部分进行排序，然后将排序后的这一小部分写入到一个独立的小文件file_1file1中。循环前面的步骤，生成了<strong>一堆内部有序的小文件</strong>file_1file1、file_2file2、file_3file3、… 、file_NfileN。<br><strong>step2：多路归并</strong><br>将每一个小文件的第一个数取出，即每一个小文件里的最小数，对这些数进行归并排序，将这些数里的最小数字num_inumi（来自file_ifilei ）写入大文件的第一行，此即整个大文件里的最小数字。<br>将文件file_ifilei的行数指针+1，取出文件file_ifilei行数指针当前所指的数字，放入内存中，将大文件的行数指针+1。<br>继续前面的循环，直到所有小文件都遍历完成。</p>
<h2 id="一千万个整数，分布在-1000万到-1000万之间，应该怎么排序"><a href="#一千万个整数，分布在-1000万到-1000万之间，应该怎么排序" class="headerlink" title="一千万个整数，分布在-1000万到+1000万之间，应该怎么排序"></a>一千万个整数，分布在-1000万到+1000万之间，应该怎么排序</h2><p>1 兆(mb)&#x3D;1024 (kb)</p>
<p>1 兆&#x3D;1048576 字节 （1024*1024）</p>
<p>2000万bit&#x3D;250万（字节）&#x3D;2.38 兆(mb)</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808225419928.png" alt="image-20210808225419928" style="zoom:67%;" />

<h2 id="【全排列】"><a href="#【全排列】" class="headerlink" title="【全排列】"></a>【全排列】</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210806210307344.png" alt="image-20210806210307344" style="zoom:60%;" />

<p>每次交换元素并回溯寻找后，都要将元素交换回来，保持没有交换前的状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">first, n</span>):</span><br><span class="line">        <span class="comment"># 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> first == n:</span><br><span class="line">            res.append(nums[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(first, n):</span><br><span class="line">            <span class="comment"># 动态维护数组</span></span><br><span class="line">            nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">            <span class="comment"># 继续递归填下一个数</span></span><br><span class="line">            backtrack(first + <span class="number">1</span>, n)</span><br><span class="line">            <span class="comment"># 撤销操作</span></span><br><span class="line">            nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(permute(nums))</span><br></pre></td></tr></table></figure>

<h2 id="【LRU】哈希表dict-双向链表"><a href="#【LRU】哈希表dict-双向链表" class="headerlink" title="【LRU】哈希表dict+双向链表"></a>【LRU】哈希表dict+双向链表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="literal">None</span>, value=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125; <span class="comment">#一个字典存节点</span></span><br><span class="line">        <span class="comment"># 新建两个节点 head 和 tail</span></span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.tail = ListNode()</span><br><span class="line">        <span class="comment"># 初始化链表为 head &lt;-&gt; tail #双向链表</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_node_to_tail</span>(<span class="params">self, key</span>):</span><br><span class="line">            <span class="comment"># 先将哈希表key指向的节点拎出来，为了简洁起名node</span></span><br><span class="line">            <span class="comment">#      hashmap[key]                               hashmap[key]</span></span><br><span class="line">            <span class="comment">#           |                                          |</span></span><br><span class="line">            <span class="comment">#           V              --&gt;                         V</span></span><br><span class="line">            <span class="comment"># prev &lt;-&gt; node &lt;-&gt; next         pre &lt;-&gt; next   ...   node</span></span><br><span class="line">            node = self.hashmap[key]</span><br><span class="line">            node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">            <span class="comment"># 之后将node插入到尾节点前</span></span><br><span class="line">            <span class="comment">#                 hashmap[key]                 hashmap[key]</span></span><br><span class="line">            <span class="comment">#                      |                            |</span></span><br><span class="line">            <span class="comment">#                      V        --&gt;                 V</span></span><br><span class="line">            <span class="comment"># prev &lt;-&gt; tail  ...  node                prev &lt;-&gt; node &lt;-&gt; tail</span></span><br><span class="line">            node.prev = self.tail.prev</span><br><span class="line">            node.<span class="built_in">next</span> = self.tail</span><br><span class="line">            self.tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">            self.tail.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果已经在链表中了，把它移到末尾（变成最新访问的）</span></span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        res = self.hashmap.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> res == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res <span class="comment">#返回 -1 (未找到)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res.value <span class="comment">#返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果key本身已经在哈希表中了就不需要在链表中加入新的节点</span></span><br><span class="line">            <span class="comment"># 但是需要更新字典该值对应节点的value</span></span><br><span class="line">            self.hashmap[key].value = value</span><br><span class="line">            <span class="comment"># 之后将该节点移到末尾</span></span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#插入之前要判断容量够不够</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.hashmap) == self.capacity: <span class="comment">#容量不够了，删！</span></span><br><span class="line">                <span class="comment"># 去掉哈希表对应项</span></span><br><span class="line">                self.hashmap.pop(self.head.<span class="built_in">next</span>.key)</span><br><span class="line">                <span class="comment"># 去掉最久没有被访问过的节点，即头节点之后的节点</span></span><br><span class="line">                self.head.<span class="built_in">next</span> = self.head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                self.head.<span class="built_in">next</span>.prev = self.head</span><br><span class="line">            <span class="comment">#容量够的情况下：</span></span><br><span class="line">            <span class="comment"># 如果不在的话就插入new节点到尾节点前</span></span><br><span class="line">            new = ListNode(key, value)</span><br><span class="line">            self.hashmap[key] = new</span><br><span class="line">            new.prev = self.tail.prev</span><br><span class="line">            new.<span class="built_in">next</span> = self.tail</span><br><span class="line">            self.tail.prev.<span class="built_in">next</span> = new</span><br><span class="line">            self.tail.prev = new</span><br></pre></td></tr></table></figure>



<h2 id="【反转链表】"><a href="#【反转链表】" class="headerlink" title="【反转链表】"></a>【反转链表】</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        temp = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = temp</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment">#!!!!!!!!!return的是pre，头节点！！！！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p = reverseList(head)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210729205839131.png" alt="image-20210729205839131" style="zoom:33%;" />

<h2 id="【判断链表中是否有环】快慢指针，追及问题"><a href="#【判断链表中是否有环】快慢指针，追及问题" class="headerlink" title="【判断链表中是否有环】快慢指针，追及问题"></a>【判断链表中是否有环】快慢指针，追及问题</h2><p>力扣141题</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p><strong>如果一个链表存在环，那么快慢指针必然会相遇</strong></p>
<p>同时出发，如果没有环，那么快的会扬长而去。。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="comment"># 定义快慢指针</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:  <span class="comment"># 如果无环fast.next会报错</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line"><span class="built_in">print</span>(hasCycle(head))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="【合并两个有序链表】"><a href="#【合并两个有序链表】" class="headerlink" title="【合并两个有序链表】"></a>【合并两个有序链表】</h2><p>力扣21题——将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的，且合并后新链表依然有序。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="comment"># 终止条件，直到链表都空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val):</span><br><span class="line">        l1.<span class="built_in">next</span> = mergeTwoLists(l1.<span class="built_in">next</span>, l2)  <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.<span class="built_in">next</span> = mergeTwoLists(l1, l2.<span class="built_in">next</span>)  <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：l1 = [1,2,4], l2 = [1,3,4]</span></span><br><span class="line"><span class="comment"># 输出：[1,1,2,3,4,4]</span></span><br><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">p = mergeTwoLists(l1, l2)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="【两个链表生成相加链表-两数相加-】"><a href="#【两个链表生成相加链表-两数相加-】" class="headerlink" title="【两个链表生成相加链表(两数相加)】"></a>【两个链表生成相加链表(两数相加)】</h2><p>第一种——力扣445题</p>
<p>第二种——力扣第2题</p>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。</p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。</p>
<h3 id="第一种：数字最高位位于链表【开始】"><a href="#第一种：数字最高位位于链表【开始】" class="headerlink" title="第一种：数字最高位位于链表【开始】"></a>第一种：数字最高位位于链表【开始】</h3><p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0</p>
<p>（937+63&#x3D;1000）</p>
<p><strong>方法一：用栈存储每个链表的每一位，出栈的顺序是低位到高位</strong></p>
<p><strong>方法二：反转链表</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：用栈存储每个链表的每一位，出栈的顺序是低位到高位</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    stack1 = []</span><br><span class="line">    stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l1:</span><br><span class="line">        stack1.append(l1.val)</span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> l2:</span><br><span class="line">        stack2.append(l2.val)</span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 当前轮结果</span></span><br><span class="line">    add_num = <span class="number">0</span>  <span class="comment"># 向前进位</span></span><br><span class="line">    mod_num = <span class="number">0</span>  <span class="comment"># 余数——&gt;存进链表的数字</span></span><br><span class="line">    head = <span class="literal">None</span>  <span class="comment"># 初始空链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2 <span class="keyword">or</span> add_num:  <span class="comment"># 存在两个栈空了，但还有进位没加进链表里</span></span><br><span class="line">        <span class="keyword">if</span> stack1:</span><br><span class="line">            a = stack1.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> stack2:</span><br><span class="line">            b = stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">        ans = (a + b) + add_num  <span class="comment"># 需要加上,上一轮进位</span></span><br><span class="line">        add_num = ans // <span class="number">10</span>  <span class="comment"># 向前进位</span></span><br><span class="line">        mod_num = ans % <span class="number">10</span>  <span class="comment"># 余数——&gt;存进链表的数字</span></span><br><span class="line">        node = ListNode(mod_num)</span><br><span class="line">        node.<span class="built_in">next</span> = head</span><br><span class="line">        head = node</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">l1 = ListNode(<span class="number">7</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line">l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">p = addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法二：反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">head</span>):</span><br><span class="line">        <span class="comment"># 反转链表</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    l1 = trans(l1)</span><br><span class="line">    l2 = trans(l2)</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 当前轮结果</span></span><br><span class="line">    add_num = <span class="number">0</span>  <span class="comment"># 向前进位</span></span><br><span class="line">    mod_num = <span class="number">0</span>  <span class="comment"># 余数，需要存进链表里</span></span><br><span class="line">    head = <span class="literal">None</span>  <span class="comment"># 初始空链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> add_num:</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            a = l1.val</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            b = l2.val</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">        ans = (a + b) + add_num</span><br><span class="line">        add_num = ans // <span class="number">10</span></span><br><span class="line">        mod_num = ans % <span class="number">10</span></span><br><span class="line">        node = ListNode(mod_num)</span><br><span class="line">        node.<span class="built_in">next</span> = head</span><br><span class="line">        head = node</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">l1 = ListNode(<span class="number">7</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line">l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">p = addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="第二种：数字最高位位于链表【尾部】"><a href="#第二种：数字最高位位于链表【尾部】" class="headerlink" title="第二种：数字最高位位于链表【尾部】"></a>第二种：数字最高位位于链表【尾部】</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p>那就不用反转链表了，直接可以加</p>
<p>从个位数字开始加，也就是链表首部开始加</p>
<p>需要初始一个空的头节点，返回的时候要去掉，新建一个指针指向头节点，用于添加节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 当前轮结果</span></span><br><span class="line">    add_num = <span class="number">0</span>  <span class="comment"># 进位</span></span><br><span class="line">    mod_num = <span class="number">0</span>  <span class="comment"># 余数，也是要保存进链表里的数</span></span><br><span class="line">    head = ListNode(<span class="literal">None</span>)</span><br><span class="line">    p = head  <span class="comment"># 指针</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> add_num:</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            a = l1.val</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            b = l2.val</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">        ans = (a + b) + add_num  <span class="comment"># 进位也要加</span></span><br><span class="line">        add_num = ans // <span class="number">10</span></span><br><span class="line">        mod_num = ans % <span class="number">10</span></span><br><span class="line">        node = ListNode(mod_num)</span><br><span class="line">        p.<span class="built_in">next</span> = node</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    head = head.<span class="built_in">next</span>  <span class="comment"># 去除首部None</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">l2.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line">l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">p = addTwoNumbers(l1, l2)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="【链表中倒数第k个节点】快慢指针，先走k步"><a href="#【链表中倒数第k个节点】快慢指针，先走k步" class="headerlink" title="【链表中倒数第k个节点】快慢指针，先走k步"></a>【链表中倒数第k个节点】快慢指针，先走k步</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>采用快慢指针，定义一个计数器，fast指针先开始移动，当计数器走过K个数后，slow指针开始移动。</p>
<p>当fast指针结束，slow指针指向的即是倒数第k个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">head, k</span>):</span><br><span class="line">    slow = fast = head</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">5</span>)</span><br><span class="line">k=<span class="number">2</span></span><br><span class="line">p = getKthFromEnd(head,k)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="☆【删除链表的倒数第n个节点】"><a href="#☆【删除链表的倒数第n个节点】" class="headerlink" title="☆【删除链表的倒数第n个节点】"></a>☆【删除链表的倒数第n个节点】</h2><p>给定一个链表，删除链表的倒数第 个节点并返回链表的头指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self , head , n </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#快慢指针找到倒数第n个</span></span><br><span class="line">        fast=head</span><br><span class="line">        slow=head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):<span class="comment">#快指针先走n步</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#特殊情况，要删除的是头节点，则此时fast已经指向尾部的下一个：None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span>: <span class="comment">#使得slow刚好为倒数第n个之前的数字</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span></span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>=slow.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment">#删除倒数第n个</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="——测试用例"><a href="#——测试用例" class="headerlink" title="——测试用例"></a>——测试用例</h3><p>正确的测试用例</p>
<p>空链表，抛异常</p>
<p> n是不是有效的</p>
<p>{1},1，{1,2},2 特殊情况，要删除的是头节点 </p>
<p>{1,2},1 </p>
<h2 id="【链表中的节点每k个一组翻转】"><a href="#【链表中的节点每k个一组翻转】" class="headerlink" title="【链表中的节点每k个一组翻转】"></a>【链表中的节点每k个一组翻转】</h2><p>将给出的链表中的节点每k个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是k的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。<br>要求空间复杂度O(1)<br><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210730203808003.png" alt="image-20210730203808003" style="zoom:67%;" /><br>用栈，我们把 k 个数压入栈中，然后弹出来的顺序就是翻转的！<br>这里要注意几个问题：<br>第一，剩下的链表个数够不够 k 个（因为不够 k 个不用翻转）；<br>第二，已经翻转的部分要与剩下链表连接起来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>):</span><br><span class="line">    root = ListNode(<span class="literal">None</span>)</span><br><span class="line">    p = root</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count = k</span><br><span class="line">        stack = []</span><br><span class="line">        temp = head</span><br><span class="line">        <span class="keyword">while</span> count <span class="keyword">and</span> temp:</span><br><span class="line">            stack.append(temp)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果count没能减完，temp就空了，说明不够k个，就不翻转了跳出去</span></span><br><span class="line">        <span class="keyword">if</span> count:</span><br><span class="line">            p.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果够k个，这时候temp已经指向第k+1个节点</span></span><br><span class="line">        <span class="comment"># 翻转</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p.<span class="built_in">next</span> = stack.pop()</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = temp  <span class="comment"># 跟剩下的链表temp连接起来</span></span><br><span class="line">        head = temp  <span class="comment"># 把剩下的链表temp给head,继续下一轮翻转</span></span><br><span class="line">    <span class="keyword">return</span> root.<span class="built_in">next</span>  <span class="comment"># 因为首个是None,所以返回root.next</span></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">5</span>)</span><br><span class="line">p = reverseKGroup(head, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树转双向链表"><a href="#二叉树转双向链表" class="headerlink" title="二叉树转双向链表"></a>二叉树转双向链表</h2><p>二叉搜索树将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p>
<ul>
<li>排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。</li>
<li>双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right &#x3D; cur ，也应构建 cur.left &#x3D; pre 。</li>
<li>循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left &#x3D; tail 和 tail.right &#x3D; head 。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210814203228602.png" alt="image-20210814203228602" style="zoom:40%;" />

<p>使用中序遍历访问树的各节点 <code>cur</code> ；并在访问每个节点时构建 <code>cur</code> 和前驱节点 <code>pre</code> 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line">head = <span class="literal">None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">treeToDoublyList</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">        <span class="keyword">global</span> pre, head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(cur.left)  <span class="comment"># 递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> pre:</span><br><span class="line">            <span class="comment"># 当pre不为空时:修改双向节点引用，即 pre.right = cur ,cur.left = pre</span></span><br><span class="line">            pre.right, cur.left = cur, pre</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = cur  <span class="comment"># 当pre为空时:代表正在访问链表头节点，记为 head</span></span><br><span class="line">        <span class="comment"># 保存cur:更新 pre = cur ,即节点 cur 是后继节点的 pre</span></span><br><span class="line">        pre = cur</span><br><span class="line">        dfs(cur.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(node)</span><br><span class="line">    <span class="comment"># 头尾连接</span></span><br><span class="line">    head.left = pre</span><br><span class="line">    pre.right = head</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">root = TreeNode(<span class="number">4</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">root.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">p = treeToDoublyList(root)</span><br><span class="line"><span class="comment"># print是停不下来的</span></span><br><span class="line"><span class="comment"># print(&quot;双向链表正序:&quot;)</span></span><br><span class="line"><span class="comment"># while p:</span></span><br><span class="line"><span class="comment">#     print(p.val)</span></span><br><span class="line"><span class="comment">#     p = p.right</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;双向链表倒序:&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    p = p.left</span><br><span class="line">    <span class="built_in">print</span>(p.val)</span><br></pre></td></tr></table></figure>

<h2 id="☆【无重复字符的最长子串】（不含有重复字符的-最长子串-的长度）-滑动窗口"><a href="#☆【无重复字符的最长子串】（不含有重复字符的-最长子串-的长度）-滑动窗口" class="headerlink" title="☆【无重复字符的最长子串】（不含有重复字符的 最长子串 的长度）(滑动窗口)"></a>☆【无重复字符的最长子串】（不含有重复字符的 <strong>最长子串</strong> 的长度）(滑动窗口)</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubsting</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    max_len = <span class="number">0</span>  <span class="comment"># 记录最大长度</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;  <span class="comment"># 键值对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 把窗口末端元素加入哈希表，使其出现次数+1</span></span><br><span class="line">        <span class="built_in">dict</span>[s[end]] = <span class="built_in">dict</span>.get(s[end], <span class="number">0</span>) + <span class="number">1</span>  <span class="comment"># dict.get(字典中要查找的键,如果指定键的值不存在时返回该默认值)</span></span><br><span class="line">        <span class="comment"># 如果dict的长度，和end-start+1相同，则说明还没有重复字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">dict</span>) == end - start + <span class="number">1</span>:</span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, end - start + <span class="number">1</span>)  <span class="comment"># 更新最大长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法</span></span><br><span class="line">        <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (dict)</span></span><br><span class="line">        <span class="keyword">while</span> end - start + <span class="number">1</span> &gt; <span class="built_in">len</span>(<span class="built_in">dict</span>):</span><br><span class="line">            head = s[start]</span><br><span class="line">            <span class="built_in">dict</span>[head] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">dict</span>[head] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> <span class="built_in">dict</span>[head]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_len</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">    maxlen=lengthOfLongestSubsting(s)</span><br><span class="line">    <span class="built_in">print</span>(maxlen)</span><br></pre></td></tr></table></figure>
<h3 id="——测试用例-1"><a href="#——测试用例-1" class="headerlink" title="——测试用例"></a>——测试用例</h3><p>要求是</p>
<p><code>0 &lt;= s.length &lt;= 5 * 104``s</code> </p>
<p>由英文字母、数字、符号和空格组成</p>
<p><strong>可以这么测：</strong></p>
<ul>
<li>首先是一些边界值和特殊值 如“”（返回0），“ ”（空格，返回1），“abcdef”（无重复的），“bbb”（全部重复的）这种；</li>
<li>正确的测试用例</li>
<li>输入的不是字符串，抛异常</li>
<li>输入中文字符串，抛异常</li>
<li>（等价类划分法将测试数据中具有某种共同特征的数据集合，进行划分）</li>
<li>考虑数据类型范围，抛异常<ul>
<li>考虑代码内存限制，或者是电脑性能</li>
<li>stackoverflow上有一个测试结果：在使用了116G内存后报内存错误。 <ul>
<li>结论：python本身对string长度无强制性限制。使用过程中主要需要考虑电脑性能和程序效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#滑动窗口类题目模板</span><br><span class="line">def problemName(str):</span><br><span class="line">    # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br><span class="line">    start=0</span><br><span class="line">    for end in range(len(str)):</span><br><span class="line">        # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span><br><span class="line">        ...       </span><br><span class="line">        # Step 4 - 情况2</span><br><span class="line">        # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span><br><span class="line">        # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span><br><span class="line">        # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span><br><span class="line">        while 不合法:</span><br><span class="line">        # 更新 (部分或所有) 维护变量 </span><br><span class="line">        # 不断移动窗口左指针直到窗口再次合法</span><br><span class="line"></span><br><span class="line">    # Step 5: 返回答案</span><br><span class="line">    return ...</span><br></pre></td></tr></table></figure>

<h2 id="☆【最大数】（给非负整数数组，数字拼接，使得最后结果最大）"><a href="#☆【最大数】（给非负整数数组，数字拼接，使得最后结果最大）" class="headerlink" title="☆【最大数】（给非负整数数组，数字拼接，使得最后结果最大）"></a>☆【最大数】（给非负整数数组，数字拼接，使得最后结果最大）</h2><p>给定一个数组由一些非负整数组成，现需要将他们进行排列并拼接，使得最后的结果最大，返回值需要是string类型 否则可能会溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">largestNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 先把 nums 中的所有数字转字符串，形成字符串数组 nums_str</span></span><br><span class="line">    <span class="comment"># 用map函数</span></span><br><span class="line">    nums_str = <span class="built_in">map</span>(<span class="built_in">str</span>, nums)</span><br><span class="line">    <span class="comment"># 自定义比较</span></span><br><span class="line">    cmp = <span class="keyword">lambda</span> x, y: -<span class="number">1</span> <span class="keyword">if</span> x + y &gt; y + x <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    nums_str = <span class="built_in">sorted</span>(nums_str, key=functools.cmp_to_key(cmp))</span><br><span class="line">    res = <span class="string">&quot;&quot;</span>.join(nums_str)</span><br><span class="line">    <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        res = <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(largestNumber(nums)) <span class="comment">#9534330</span></span><br></pre></td></tr></table></figure>

<h3 id="——测试用例-2"><a href="#——测试用例-2" class="headerlink" title="——测试用例"></a>——测试用例</h3><ul>
<li><p>首先是一些边界值和特殊值 如[0,0]（输出应该为“0”）；</p>
</li>
<li><p>正确的测试用例； </p>
</li>
<li><p>输入为空，抛异常</p>
</li>
<li><p>输入的不是非负整数，抛异常</p>
</li>
<li><p>输入的数字超过了数据类型范围，抛异常</p>
<ul>
<li>考虑代码内存限制，或者是电脑性能</li>
<li>stackoverflow上有一个测试结果：在使用了116G内存后报内存错误。 <ul>
<li>结论：python本身对string长度无强制性限制。使用过程中主要需要考虑电脑性能和程序效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>利用Python3自定义<code>cmp_to_key</code>函数，传入两个参数<code>(x,y)</code>对应于<code>(self,other)</code>,也就是<code>(当前数,前面比较过的数)</code>，或者说<code>y</code>为数组前面的数，<code>x</code>为数组后面的数。</p>
<p>sorted()函数默认升序</p>
<p>默认的时候compare(x,y)会在<code>当前x</code>&lt;y时返回-1，说明<code>当前x</code>比前面数小，应该放到前面去；</p>
<p>在<code>当前x</code>&gt;y时返回1，说明<code>当前x</code>比前面数字大。</p>
<p>我现在想要：x与y拼接&gt;y与x拼接时，把x放到前面去，用[x,y]的顺序，也就是我想要它返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp = lambda x, y: -1 if x + y &gt; y + x else 1</span><br></pre></td></tr></table></figure>

<p>要使得构造的数更大，需要满足条件：<code>前面的数</code>+<code>后面的数</code>&gt;<code>后面的数</code>+<code>前面的数</code>，即<code>y+x&gt;x+y</code>返回<code>1</code>成立</p>
<h2 id="【长度最小的子数组】（找出该数组中满足其和-≥-target-的长度最小的-连续子数组-（滑动窗口）"><a href="#【长度最小的子数组】（找出该数组中满足其和-≥-target-的长度最小的-连续子数组-（滑动窗口）" class="headerlink" title="【长度最小的子数组】（找出该数组中满足其和 ≥ target 的长度最小的 连续子数组)（滑动窗口）"></a>【长度最小的子数组】（找出该数组中满足其和 ≥ target 的长度最小的 连续子数组)（滑动窗口）</h2><p>力扣209题</p>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组[numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">target, nums</span>):</span><br><span class="line">    <span class="comment"># 满足其和 ≥ target 的长度最小的 连续子数组</span></span><br><span class="line">    <span class="comment"># 并返回其长度。如果不存在符合条件的子数组，返回 0。</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    inf = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">    min_len = inf</span><br><span class="line">    sum_ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        sum_ans += nums[end]</span><br><span class="line">        <span class="keyword">if</span> sum_ans &gt;= target:</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当sum_的值大于target时候，窗口不合法</span></span><br><span class="line">        <span class="comment"># 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (min_len， sum_ans)</span></span><br><span class="line">        <span class="keyword">while</span> sum_ans &gt;= target:</span><br><span class="line">            <span class="comment"># 需要再判断一下，不然end=n-1结束的时候会出问题</span></span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            sum_ans -= nums[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> min_len == inf:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> min_len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">7</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(minSubArrayLen(target, nums))</span><br></pre></td></tr></table></figure>

<p>inf也可以用math.inf</p>
<p>import math就行</p>
<h2 id="连续子数组最大和"><a href="#连续子数组最大和" class="headerlink" title="连续子数组最大和"></a>连续子数组最大和</h2><h2 id="【合并两个有序数组】"><a href="#【合并两个有序数组】" class="headerlink" title="【合并两个有序数组】"></a>【合并两个有序数组】</h2><p>力扣第88题</p>
<p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从后向前数组遍历</span></span><br><span class="line"><span class="comment"># 两个指针指向A,B末尾，比较两个数组末尾元素</span></span><br><span class="line"><span class="comment"># 哪个大哪个存到A数组最后，并把指针前移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">A, m, B, n</span>):</span><br><span class="line">    p1 = m - <span class="number">1</span></span><br><span class="line">    p2 = n - <span class="number">1</span></span><br><span class="line">    p = m + n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:  <span class="comment"># 两个指针都要&gt;=0</span></span><br><span class="line">        <span class="keyword">if</span> A[p1] &gt;= B[p2]:</span><br><span class="line">            A[p] = A[p1]</span><br><span class="line">            p1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[p] = B[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">        p -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果A遍历完了，B里还有数，就把B的前面复制到A前面</span></span><br><span class="line">    <span class="comment"># 没有数了，也可以复制，就是p2=-1了，啥也复制不进去</span></span><br><span class="line">    A[:p2 + <span class="number">1</span>] = B[:p2 + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">A = [<span class="number">1</span>]</span><br><span class="line">m = <span class="number">1</span></span><br><span class="line">B = []</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(merge(A, m, B, n))</span><br></pre></td></tr></table></figure>

<h3 id="——测试用例-3"><a href="#——测试用例-3" class="headerlink" title="——测试用例"></a>——测试用例</h3><p>正确用例：[1,2,3,0,0,0]，3；[2,5,6]，3</p>
<p>[1]，1；[]，0 ——B空</p>
<p>[0]，0，[1]，1——A空，B不空</p>
<p>m,n范围限制</p>
<p>数组里数字，数字类型范围限制</p>
<h2 id="【买卖股票的最佳时机】"><a href="#【买卖股票的最佳时机】" class="headerlink" title="【买卖股票的最佳时机】"></a>【买卖股票的最佳时机】</h2><p>力扣121题</p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    <span class="comment"># 记录一个历史最低价格 minprice</span></span><br><span class="line">    <span class="comment"># 一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</span></span><br><span class="line">    inf = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">    minprice = inf</span><br><span class="line"></span><br><span class="line">    maxprofit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice)</span><br><span class="line">        minprice = <span class="built_in">min</span>(minprice, price)</span><br><span class="line">    <span class="keyword">return</span> maxprofit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prices = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(maxProfit(prices))</span><br></pre></td></tr></table></figure>



<h2 id="【只出现一次的数字】（其余每个元素均出现两次，找出那个只出现了一次的元素）"><a href="#【只出现一次的数字】（其余每个元素均出现两次，找出那个只出现了一次的元素）" class="headerlink" title="【只出现一次的数字】（其余每个元素均出现两次，找出那个只出现了一次的元素）"></a>【只出现一次的数字】（其余每个元素均出现两次，找出那个只出现了一次的元素）</h2><p>力扣136题 </p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>按位异或运算符：当两对应的二进位相异时，结果为1，否则为0。</p>
<p>a ^ a &#x3D; 0<br>0 ^ a &#x3D; a</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">        nums[<span class="number">0</span>]=nums[<span class="number">0</span>]^nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">nums=[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(singleNumber(nums))</span><br></pre></td></tr></table></figure>

<h2 id="【32位有符号整数进行反转】（java写）"><a href="#【32位有符号整数进行反转】（java写）" class="headerlink" title="【32位有符号整数进行反转】（java写）"></a>【32位有符号整数进行反转】（java写）</h2><p>力扣第7题</p>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans&gt;Integer.MAX_VALUE/<span class="number">10</span> || (ans==Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; pop&gt;<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans&lt;Integer.MIN_VALUE/<span class="number">10</span> || (ans==Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; pop&lt;-<span class="number">8</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">120</span>;</span><br><span class="line">        System.out.println(reverse(x));<span class="comment">//-21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过循环将数字x的每一位拆开，在计算新值时每一步都判断是否溢出。</span></span><br><span class="line"><span class="comment">溢出条件有两个，一个是大于整数最大值MAX_VALUE，另一个是小于整数最小值MIN_VALUE</span></span><br><span class="line"><span class="comment">设当前计算结果为ans，下一位为pop。</span></span><br><span class="line"><span class="comment">    从ans * 10 + pop &gt; MAX_VALUE这个溢出条件来看</span></span><br><span class="line"><span class="comment">        当出现 ans &gt; MAX_VALUE / 10 时，则一定溢出</span></span><br><span class="line"><span class="comment">        当出现 ans == MAX_VALUE / 10 且 pop &gt; 7 时，则一定溢出，7是2^31 - 1的个位数</span></span><br><span class="line"><span class="comment">    从ans * 10 + pop &lt; MIN_VALUE这个溢出条件来看</span></span><br><span class="line"><span class="comment">        当出现 ans &lt; MIN_VALUE / 10 时，则一定溢出</span></span><br><span class="line"><span class="comment">        当出现 ans == MIN_VALUE / 10 且 pop &lt; -8 时，则一定溢出，8是-2^31的个位数</span></span><br><span class="line"><span class="comment"> 315%10=5     315/10=31</span></span><br><span class="line"><span class="comment"> 31%10=1      31/10=3</span></span><br><span class="line"><span class="comment"> 3%10=3       3/10=0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210728093557741.png" alt="image-20210728093557741"></p>
<h2 id="【字符串变形】（字符串中由空格隔开的单词反序，同时反转每个字符的大小写"><a href="#【字符串变形】（字符串中由空格隔开的单词反序，同时反转每个字符的大小写" class="headerlink" title="【字符串变形】（字符串中由空格隔开的单词反序，同时反转每个字符的大小写"></a>【字符串变形】（字符串中由空格隔开的单词反序，同时反转每个字符的大小写</h2><p>对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如”Hello World”变形后就变成了”wORLD hELLO”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str.swapcase()方法用于对字符串的大小写字母进行转换。</span></span><br><span class="line"><span class="comment"># 字符串分割str.split(),输出的是一个列表list</span></span><br><span class="line"><span class="comment"># s[::-1]步长为1，反向输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个字符串s以及它的长度n</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">s, n</span>):</span><br><span class="line">    a = s.swapcase().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    b = a[::-<span class="number">1</span>]  <span class="comment"># 步长为1，反向输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_str = <span class="string">&quot;This is a sample&quot;</span></span><br><span class="line">n = <span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(trans(test_str, n))</span><br></pre></td></tr></table></figure>

<p>如果<strong>不让用</strong><code>swapcase()</code>函数的话，用ASCII判断如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ACSII码 ：A(65)-Z(90)，a(97)-z(122),空格32</span></span><br><span class="line"><span class="comment"># 字符转ASCII：ord()</span></span><br><span class="line"><span class="comment"># ASCII转字符：chr()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">s, n</span>):</span><br><span class="line">    <span class="comment"># 大小写转换</span></span><br><span class="line">    str_list = <span class="built_in">list</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        asc = <span class="built_in">ord</span>(str_list[i])</span><br><span class="line">        <span class="keyword">if</span> asc == <span class="number">32</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> asc &gt;= <span class="number">65</span> <span class="keyword">and</span> asc &lt;= <span class="number">90</span>:</span><br><span class="line">            asc += <span class="number">32</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># asc &gt;= 97 and asc &lt;= 122</span></span><br><span class="line">            asc -= <span class="number">32</span></span><br><span class="line">        str_list[i] = <span class="built_in">chr</span>(asc)  <span class="comment"># 字符串不可更改，所以转为list改</span></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>.join(str_list)  <span class="comment"># 转回字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单词反序</span></span><br><span class="line">    s2 = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s3 = s2[::-<span class="number">1</span>]</span><br><span class="line">    ans = <span class="string">&quot; &quot;</span>.join(s3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">test_str = <span class="string">&quot;This is a sample&quot;</span></span><br><span class="line">n = <span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(trans(test_str, n))</span><br></pre></td></tr></table></figure>



<h2 id="【将字符串转化为整数】"><a href="#【将字符串转化为整数】" class="headerlink" title="【将字符串转化为整数】"></a>【将字符串转化为整数】</h2><p>实现函数 atoi 。函数的功能为将字符串转化为整数</p>
<p>提示：仔细思考所有可能的输入情况。这个问题没有给出输入的限制，你需要自己考虑所有可能的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码要解决三个主要问题：</span><br><span class="line">    字符串前有空白字符；</span><br><span class="line">    ‘+’，‘-’ 处理问题；</span><br><span class="line">    浮点数问题</span><br><span class="line">    数据类型范围</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字字符转数字: “此数字的 ASCII 码” 与 “ 00 的 ASCII 码” 相减即可</span></span><br><span class="line"><span class="comment"># 字符转ASCII：ord()</span></span><br><span class="line"><span class="comment"># ASCII转字符：chr()</span></span><br><span class="line"><span class="comment"># str.strip()移除字符串头尾指定的字符（默认为空格或换行符）或字符序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strToInt</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">str</span>.strip()  <span class="comment"># 删除首尾空格</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>: <span class="comment">#！！！！！！！！！！记得判空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    int_max = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">    int_min = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>  <span class="comment"># 数字读取初始索引设为1</span></span><br><span class="line">    sign = <span class="number">1</span>  <span class="comment"># 符号位初始化为正</span></span><br><span class="line">    res = <span class="number">0</span>  <span class="comment"># 存结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        sign = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>: <span class="comment">#elif！！！！！！</span></span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 若没有符号位，则数字读取从0开始</span></span><br><span class="line">    <span class="comment"># 数字拼接边界bndry</span></span><br><span class="line">    <span class="comment"># 如果sign=1时，res&gt;bndry 或者 res==bndry时,等待拼接的数字x&gt;7，则越界</span></span><br><span class="line">    <span class="comment"># 如果sign=-1时，（res不带符号位）res&gt;bndry 或者 res==bndry时，等待拼接的数字x&gt;8</span></span><br><span class="line">    bndry = int_max // <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>[i:]: <span class="comment">#！！！！！！不能写错，[]里还有冒号呢！！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>: <span class="keyword">break</span>  <span class="comment"># 遇到非数字则跳出！！！！！！！！！！！！</span></span><br><span class="line">        <span class="comment"># 如果读数字，需要判断是否越界，每拼接一位都要考虑是否越界</span></span><br><span class="line">        <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> (res &gt; bndry <span class="keyword">or</span> (res == bndry <span class="keyword">and</span> c &gt; <span class="string">&#x27;7&#x27;</span>)):</span><br><span class="line">            <span class="keyword">return</span> int_max</span><br><span class="line">        <span class="keyword">if</span> sign == -<span class="number">1</span> <span class="keyword">and</span> (res &gt; bndry <span class="keyword">or</span> (res == bndry <span class="keyword">and</span> c &gt; <span class="string">&#x27;8&#x27;</span>)):</span><br><span class="line">            <span class="keyword">return</span> int_min</span><br><span class="line">        res = res * <span class="number">10</span> + <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># 数字拼接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign * res  <span class="comment"># 不要忘记乘上符号</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210728195148668.png" alt="image-20210728195148668" style="zoom:50%;" />

<h2 id="【字符串反转】"><a href="#【字符串反转】" class="headerlink" title="【字符串反转】"></a>【字符串反转】</h2><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>
<p>解法一:开辟一个和str长度大小相同的一个字符串ans，把传入的str倒序赋值到ans字符串上</p>
<p>解法二:原地交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , <span class="built_in">str</span> </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        str_list=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">        n=<span class="built_in">len</span>(<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):<span class="comment">#注意这里！！！！！！！</span></span><br><span class="line">            str_list[i],str_list[n-i-<span class="number">1</span>]=str_list[n-i-<span class="number">1</span>],str_list[i]<span class="comment">#交换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(str_list)<span class="comment">#转为字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="【字符串匹配，实现-strStr-】"><a href="#【字符串匹配，实现-strStr-】" class="headerlink" title="【字符串匹配，实现 strStr()】"></a>【字符串匹配，实现 strStr()】</h2><p>实现 strStr() 函数。</p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> needle <span class="keyword">not</span> <span class="keyword">in</span> haystack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> needle == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i:<span class="built_in">len</span>(needle)+i] == needle[:]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">详细写法：</span><br><span class="line">// 方法一</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a=<span class="built_in">len</span>(needle)</span><br><span class="line">        b=<span class="built_in">len</span>(haystack)</span><br><span class="line">        <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span>=self.getnext(a,needle)</span><br><span class="line">        p=-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">            <span class="keyword">while</span> p&gt;=<span class="number">0</span> <span class="keyword">and</span> needle[p+<span class="number">1</span>]!=haystack[j]:</span><br><span class="line">                p=<span class="built_in">next</span>[p]</span><br><span class="line">            <span class="keyword">if</span> needle[p+<span class="number">1</span>]==haystack[j]:</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p==a-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j-a+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getnext</span>(<span class="params">self,a,needle</span>):</span><br><span class="line">        <span class="built_in">next</span>=[<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line">        k=-<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>]=k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> (k&gt;-<span class="number">1</span> <span class="keyword">and</span> needle[k+<span class="number">1</span>]!=needle[i]):</span><br><span class="line">                k=<span class="built_in">next</span>[k]</span><br><span class="line">            <span class="keyword">if</span> needle[k+<span class="number">1</span>]==needle[i]:</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i]=k</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="【栈push-pop-top-getMin】"><a href="#【栈push-pop-top-getMin】" class="headerlink" title="【栈push pop top getMin】"></a>【栈push pop top getMin】</h2><p>力扣<a href="https://leetcode-cn.com/problems/min-stack-lcci/">面试题 03.02. 栈的最小值</a></p>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<ul>
<li>push(x) – 压一个数到栈顶</li>
<li>pop() – 移除栈顶的元素，不返回任何对象</li>
<li>top() – 返回栈顶端的元素</li>
<li>getMin() – 检索栈中的最小值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []  <span class="comment"># 存放所有元素</span></span><br><span class="line">        self.minStack = []  <span class="comment"># 引入minStack列表存放最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minStack:  <span class="comment"># 判断minStack是否空</span></span><br><span class="line">            self.minStack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minStack.append(<span class="built_in">min</span>(x, self.minStack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.minStack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.minStack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">obj = MinStack()</span><br><span class="line">obj.push(<span class="number">6</span>)</span><br><span class="line">obj.push(<span class="number">1</span>)</span><br><span class="line">obj.push(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.getMin())</span><br><span class="line">obj.pop()</span><br><span class="line"><span class="built_in">print</span>(obj.top())</span><br></pre></td></tr></table></figure>

<h2 id="【用两个栈实现队列】"><a href="#【用两个栈实现队列】" class="headerlink" title="【用两个栈实现队列】"></a>【用两个栈实现队列】</h2><p>用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只使用一个栈 stack1 当作队列，另一个栈 stack2 用来辅助操作。</span></span><br><span class="line"><span class="comment"># 想要先进先出，就要将新加入的元素放在栈底</span></span><br><span class="line"><span class="comment"># 需要先将stack1的元素转移到stack2将元素入栈stack1最后将stack2的元素全部回到stack1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">while</span> self.stack1:  <span class="comment"># stack1不为空，就不能新加元素，需要转移到stack2</span></span><br><span class="line">            self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="comment"># 转移完了，添加新元素</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.stack2:  <span class="comment"># 再把所有元素转移回stack1</span></span><br><span class="line">            self.stack1.append(self.stack2.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack1:<span class="comment">#保证pop操作时队列内已有元素，就不会出现这个。</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> self.stack1.pop()</span><br></pre></td></tr></table></figure>



<h2 id="【单调递增的数字】"><a href="#【单调递增的数字】" class="headerlink" title="【单调递增的数字】"></a>【单调递增的数字】</h2><p>力扣第738题</p>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是<strong>单调递增</strong>。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: N = 332</span><br><span class="line">输出: 299</span><br><span class="line">说明: N 是在 [0, 10^9] 范围内的一个整数。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从左遍历，找到第一个：左数&gt;右数，的位置，</span></span><br><span class="line"><span class="comment"># 把左数-1，并且把右边及后都变为9</span></span><br><span class="line"><span class="comment"># 42432</span></span><br><span class="line"><span class="comment"># 42429</span></span><br><span class="line"><span class="comment"># 一直往前遍历</span></span><br><span class="line"><span class="comment"># 42399</span></span><br><span class="line"><span class="comment"># 39999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increasingDigits</span>(<span class="params">n</span>):</span><br><span class="line">    digits_str = <span class="built_in">list</span>(<span class="built_in">str</span>(n)) <span class="comment">#整数整形int转list,要先转成str</span></span><br><span class="line">    lens = <span class="built_in">len</span>(digits_str)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> digits_str[i] &gt; digits_str[i + <span class="number">1</span>]:  <span class="comment"># 左数&gt;右数</span></span><br><span class="line">            digits_str[i] = <span class="built_in">str</span>(<span class="built_in">int</span>(digits_str[i]) - <span class="number">1</span>)</span><br><span class="line">            digits_str[i + <span class="number">1</span>:] = <span class="string">&#x27;9&#x27;</span> * (lens - i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(digits_str))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="built_in">print</span>(increasingDigits(<span class="number">42432</span>))</span><br></pre></td></tr></table></figure>

<h2 id="【两数之和】找出两个加起来等于目标值的数"><a href="#【两数之和】找出两个加起来等于目标值的数" class="headerlink" title="【两数之和】找出两个加起来等于目标值的数"></a>【两数之和】找出两个加起来等于目标值的数</h2><p>给出一个整数数组，请在数组中找出两个加起来等于目标值的数，</p>
<p>你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），<strong>需要满足 index1 小于index2</strong>。<strong>注意：下标是从1开始的。</strong>假设给出的数组中只存在唯一解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给出的数组为 &#123;20, 70, 110, 150&#125;,目标值为90</span><br><span class="line">输出 index1=1, index2=2</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="comment"># dict存(num值，索引)</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="built_in">dict</span>[num] = i  <span class="comment"># 给字典增加项</span></span><br><span class="line">    <span class="comment"># 在整个numdict中去查找num2</span></span><br><span class="line">    <span class="keyword">for</span> i, num1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="comment"># i是num1索引</span></span><br><span class="line">        num2 = target - num1</span><br><span class="line">        <span class="keyword">if</span> num2 <span class="keyword">in</span> <span class="built_in">dict</span> <span class="keyword">and</span> <span class="built_in">dict</span>[num2] != i:  <span class="comment"># 不能用本身</span></span><br><span class="line">            <span class="comment"># 注意输出的是第几个，而不是索引，且要求左index&lt;右index</span></span><br><span class="line">            <span class="keyword">return</span> [i + <span class="number">1</span>, <span class="built_in">dict</span>[num2] + <span class="number">1</span>] <span class="keyword">if</span> i &lt; <span class="built_in">dict</span>[num2] <span class="keyword">else</span> [<span class="built_in">dict</span>[num2] + <span class="number">1</span>, i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">target = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(twoSum(nums, target))  <span class="comment"># [2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="【三数之和】找出三个加起来等于目标值的数"><a href="#【三数之和】找出三个加起来等于目标值的数" class="headerlink" title="【三数之和】找出三个加起来等于目标值的数"></a>【三数之和】找出三个加起来等于目标值的数</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> lens &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    nums.sort()  <span class="comment"># 排序</span></span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        l = i + <span class="number">1</span></span><br><span class="line">        r = lens - <span class="number">1</span></span><br><span class="line">        target = <span class="number">0</span> - nums[i]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                <span class="comment"># 还要往继续往中间找</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]):</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]):</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(threeSum(nums))</span><br></pre></td></tr></table></figure>

<h2 id="【找出数组中重复的数字】"><a href="#【找出数组中重复的数字】" class="headerlink" title="【找出数组中重复的数字】"></a>【找出数组中重复的数字】</h2><p>剑指 Offer 03. 数组中重复的数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        num_dict=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> num_dict:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            num_dict.add(num)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="☆【TopK问题，数组中第K大的数】快排partition思想"><a href="#☆【TopK问题，数组中第K大的数】快排partition思想" class="headerlink" title="☆【TopK问题，数组中第K大的数】快排partition思想"></a>☆【TopK问题，数组中第K大的数】快排partition思想</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。(包括重复的元素，不用去重)</p>
<p>借助快排的 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素</p>
<p>partition总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次partition就能缩小搜索的范围</p>
<p>第一种：目标是第k大，但由于是升序找partition,所以目标是倒数第K个<br>第二种：降序找partition，目标是k-1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种：目标是第k大，但由于是升序找partition,所以目标是倒数第K个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findKth</span>(<span class="params">nums, k</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    target = <span class="built_in">len</span>(nums) - k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = partition(nums, l, r)</span><br><span class="line">        <span class="keyword">if</span> p == target:</span><br><span class="line">            <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">elif</span> p &lt; target:</span><br><span class="line">            l = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># p &gt; target:</span></span><br><span class="line">            r = p - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, l, r</span>):</span><br><span class="line">    pivot = nums[l]</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] &gt;= pivot:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        nums[l] = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] &lt;= pivot:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        nums[r] = nums[l]</span><br><span class="line">    nums[l] = pivot</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">k = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(findKth(nums, k))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二种：降序找partition，目标是k-1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findKth</span>(<span class="params">nums, k</span>):</span><br><span class="line">    lens = <span class="built_in">len</span>(nums)</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = lens - <span class="number">1</span></span><br><span class="line">    target = k - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = partition(nums, l, r)</span><br><span class="line">        <span class="keyword">if</span> p == target:</span><br><span class="line">            <span class="keyword">return</span> nums[p]</span><br><span class="line">        <span class="keyword">elif</span> p &lt; target:</span><br><span class="line">            l = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = p - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, l, r</span>):  <span class="comment"># 降序排partition</span></span><br><span class="line">    pivot = nums[l]</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] &lt;= pivot:  <span class="comment"># 注意这里</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        nums[l] = nums[r]  <span class="comment"># 大的换到左边</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] &gt;= pivot:  <span class="comment"># 注意这里</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        nums[r] = nums[l]  <span class="comment"># 小的换到右边</span></span><br><span class="line">    nums[l] = pivot</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">k = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(findKth(nums, k))</span><br></pre></td></tr></table></figure>

<h2 id="【最小的K个数】快排partition-或-大顶堆"><a href="#【最小的K个数】快排partition-或-大顶堆" class="headerlink" title="【最小的K个数】快排partition 或 大顶堆"></a>【最小的K个数】快排partition 或 大顶堆</h2><p>求给定数组的topK小问题。找出数组中最小的k个数。以任意顺序返回这k个数均可</p>
<p>法一：直接排序，然后取前k小数据。</p>
<p>法二：借助快排partition，找第K，则返回左边序列即可</p>
<p>法三：借助大顶堆，仅维护K个长度的堆，遍历数组，当新元素小于堆顶元素时，更新堆顶元素,调整堆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法二：借助快排partition，找第K，则返回左边序列即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smallestK</span>(<span class="params">arr, k</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    target = k - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = partition(arr, l, r)</span><br><span class="line">        <span class="keyword">if</span> p == target:</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>:k]</span><br><span class="line">        <span class="keyword">elif</span> p &lt; target:</span><br><span class="line">            l = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = p - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, l, r</span>):</span><br><span class="line">    pivot = nums[l]</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] &gt;= pivot:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        nums[l] = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] &lt;= pivot:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        nums[r] = nums[l]</span><br><span class="line">    nums[l] = pivot</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">s = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(smallestK(s, k)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法三：借助大顶堆，仅维护K个长度的堆，遍历数组，当新元素小于堆顶元素时，更新堆顶元素,调整堆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HeadAdjust</span>(<span class="params">arr, i, n</span>):  <span class="comment"># 以i为根节点进行堆调整</span></span><br><span class="line">    largest = i</span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[l] &gt; arr[largest]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[r] &gt; arr[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        HeadAdjust(arr, largest, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smallestK</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 构建一个只有k个数的大顶堆</span></span><br><span class="line">    hp = arr[:k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 从有子节点的节点开始判断就行</span></span><br><span class="line">        HeadAdjust(hp, i, k)</span><br><span class="line">    <span class="comment"># 遍历数组，当新元素小于堆顶元素时，更新堆顶元素,调整堆</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr[k:]:</span><br><span class="line">        <span class="keyword">if</span> num &lt; hp[<span class="number">0</span>]:</span><br><span class="line">            hp[<span class="number">0</span>] = num</span><br><span class="line">            HeadAdjust(hp, <span class="number">0</span>, k)</span><br><span class="line">    <span class="keyword">return</span> hp</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">s = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(smallestK(s, k))</span><br></pre></td></tr></table></figure>

<h2 id="【二叉搜索树的第k大节点】求此树中序遍历倒序的第k个节点"><a href="#【二叉搜索树的第k大节点】求此树中序遍历倒序的第k个节点" class="headerlink" title="【二叉搜索树的第k大节点】求此树中序遍历倒序的第k个节点"></a>【二叉搜索树的第k大节点】求此树中序遍历倒序的第k个节点</h2><p>二叉搜索树，二叉查找树，二叉排序树，</p>
<p>左子树小于根结点； 右子树大于根结点，中序遍历，会有序输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthLargest</span>(<span class="params">self, root, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">InOrderReverse</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            InOrderReverse(node.right)</span><br><span class="line">            <span class="keyword">if</span> self.k==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k=self.k-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k==<span class="number">0</span>:self.res=node.val</span><br><span class="line">            InOrderReverse(node.left)</span><br><span class="line"></span><br><span class="line">        self.k=k</span><br><span class="line">        InOrderReverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<h2 id="【二叉树的最近公共祖先】"><a href="#【二叉树的最近公共祖先】" class="headerlink" title="【二叉树的最近公共祖先】"></a>【二叉树的最近公共祖先】</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#牛客上，o1,o2都是int,且要求返回也是int</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 超过叶子节点，或者root为o1、o2中的一个直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == o1 <span class="keyword">or</span> root.val == o2: <span class="keyword">return</span> root.val</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, o1, o2) <span class="comment">#返回左侧的o1/o1节点</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, o1, o2)<span class="comment">#返回右侧的o1/o1节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right <span class="comment">#都在右侧</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left <span class="comment">#都在左侧</span></span><br><span class="line">        <span class="keyword">return</span> root.val <span class="comment">#在左右两侧</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="comment">#力扣上，o1,o1都是TreeNode，返回也是TreeNode</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == o1 <span class="keyword">or</span> root == o2: <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, o1, o2)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, o1, o2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/</a></p>
<h2 id="【最长公共前缀】多个字符串"><a href="#【最长公共前缀】多个字符串" class="headerlink" title="【最长公共前缀】多个字符串"></a>【最长公共前缀】多个字符串</h2><p>力扣14题</p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先判空</span></span><br><span class="line"><span class="comment"># 令最长公共前缀 ans 的值为第一个字符串，进行初始化</span></span><br><span class="line"><span class="comment"># 遍历后面的字符串，依次与ans比较，找出公共前缀</span></span><br><span class="line"><span class="comment"># 如果不为空则返回，为空则return &quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    ans = strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">len</span>(ans):</span><br><span class="line">            ans = ans[:<span class="built_in">len</span>(s)]  <span class="comment"># 会有字符串比初始小的情况</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(ans) <span class="keyword">and</span> s[i] != ans[i]:  <span class="comment"># 注意这里i可能会超出ans索引</span></span><br><span class="line">                ans = ans[:i]  <span class="comment"># 和公共前缀字符不匹配,截断ans</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">strs = [<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(longestCommonPrefix(strs))</span><br></pre></td></tr></table></figure>

<h2 id="【最长公共子串】牛客"><a href="#【最长公共子串】牛客" class="headerlink" title="【最长公共子串】牛客"></a>【最长公共子串】牛客</h2><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p>
<p>题目保证str1和str2的最长公共子串存在且唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1AB2345CD&quot;,&quot;12345EF&quot;</span><br><span class="line">返回值：&quot;2345&quot;</span><br><span class="line">注意这题求的是最长公共子串，不是最长公共子序列，子序列可以是不连续的，但子串一定是连续的。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1 , str2 </span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l1, l2 = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">        dp = [[<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l1 + <span class="number">1</span>)]</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l2):</span><br><span class="line">                <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + str1[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) &gt; <span class="built_in">len</span>(ans):</span><br><span class="line">                        ans = dp[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>最长公共子序列&amp;最长公共子串，题解：<a href="https://blog.csdn.net/weixin_42462804/article/details/104813182">https://blog.csdn.net/weixin_42462804/article/details/104813182</a></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210730142509564.png" alt="image-20210730142509564" style="zoom:50%;" />

<h2 id="【字符串前缀和后缀搜索】"><a href="#【字符串前缀和后缀搜索】" class="headerlink" title="【字符串前缀和后缀搜索】"></a>【字符串前缀和后缀搜索】</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.a=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(i)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(i)+<span class="number">1</span>):</span><br><span class="line">                    now=i[:j]+<span class="string">&#x27;$&#x27;</span>+i[k:]</span><br><span class="line">                    self.a[now]=ind</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, prefix, suffix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prefix: str</span></span><br><span class="line"><span class="string">        :type suffix: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k=prefix+<span class="string">&#x27;$&#x27;</span>+suffix</span><br><span class="line">        <span class="keyword">return</span> self.a.get(k,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordFilter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordFilter(words)</span></span><br><span class="line"><span class="comment"># param_1 = obj.f(prefix,suffix)</span></span><br></pre></td></tr></table></figure>

<h2 id="【模拟键盘，只有a-z-26个英文字母的输入键-有两个按键坏了】"><a href="#【模拟键盘，只有a-z-26个英文字母的输入键-有两个按键坏了】" class="headerlink" title="【模拟键盘，只有a-z 26个英文字母的输入键,有两个按键坏了】"></a>【模拟键盘，只有a-z 26个英文字母的输入键,有两个按键坏了】</h2><p>题目：有一个键盘，只有a-z 26个英文字母的输入键， 现在发现有两个按键坏了，按下会发生特定的结果<br><strong>按下i键&#x3D;退格</strong>，会消除掉上一个输入字母<br><strong>按下o键&#x3D;撤回</strong>，会撤销掉上一步的操作<br>要求实现一个方法，模拟键盘的输出逻辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">words</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    result = []  <span class="comment"># 存最终输入</span></span><br><span class="line">    temp_copy = []  <span class="comment"># 拷贝一份数据，防止要撤回操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">if</span> ch[<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span>:  <span class="comment"># 按下i键=退格，会消除掉上一个输入字母</span></span><br><span class="line">            temp_copy = result.copy()  <span class="comment"># 拷贝数组</span></span><br><span class="line">            result.pop()</span><br><span class="line">        <span class="keyword">elif</span> ch[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>:  <span class="comment"># 按下o键=撤回，会撤销掉上一步的操作</span></span><br><span class="line">            result, temp_copy = temp_copy, result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_copy = result.copy()</span><br><span class="line">            result.append(ch[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(words(<span class="string">&#x27;asddiio&#x27;</span>))</span><br><span class="line"><span class="comment"># (0, &#x27;a&#x27;)——ch[0]指的是0，ch[1]指的是&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># (1, &#x27;s&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;d&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;d&#x27;)</span></span><br><span class="line"><span class="comment"># (4, &#x27;i&#x27;)</span></span><br><span class="line"><span class="comment"># (5, &#x27;i&#x27;)</span></span><br><span class="line"><span class="comment"># (6, &#x27;o&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="飞书-【下一个排列】输出给定数字下一个比它大的数字排列"><a href="#飞书-【下一个排列】输出给定数字下一个比它大的数字排列" class="headerlink" title="飞书-【下一个排列】输出给定数字下一个比它大的数字排列"></a>飞书-【下一个排列】输出给定数字下一个比它大的数字排列</h2><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中<strong>下一个更大</strong>的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>比如数字：1234， 输出 1243；比如 1243，则输出 1324</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从右向左遍历，第一次出现左数&lt;右数的情况，说明包含右数在内后面是降序排列，把这个降序里的比左数大的最小数字和左数交换</span></span><br><span class="line"><span class="comment"># 特例：找不到左数&lt;右数的情况，如4321，即倒序排一下变成1234</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:  <span class="comment"># 注意特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    temp = -<span class="number">1</span>  <span class="comment"># 记录能不能找到左数&lt;右数的情况</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 从倒数第二个数开始判断（一是特例已经判断过，二是防止i+1越界</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:  <span class="comment"># 第一次出现左数&lt;右数的情况</span></span><br><span class="line">            temp = i</span><br><span class="line">            <span class="comment"># 包含右数在内后面是降序排列，把这个降序里的比左数大的最小数字和左数交换</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, i, -<span class="number">1</span>):  <span class="comment"># 从最后往前找第一个比nums[i]大的数</span></span><br><span class="line">                <span class="keyword">if</span> nums[k] &gt; nums[i]:</span><br><span class="line">                    nums[k], nums[i] = nums[i], nums[k]  <span class="comment"># 交换</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了！立即跳出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># temp还是=-1，特例,找不到左数&lt;右数的情况,倒序排；也就是从temp+1开始倒序排</span></span><br><span class="line">    <span class="comment"># temp=i，交换之后，需要把索引从i+1开始逆序；也就是从temp+1开始倒序排</span></span><br><span class="line">    <span class="comment"># 合二为一，都是从索引：temp+1开始倒序排</span></span><br><span class="line">    reverse_nums(nums, temp + <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_nums</span>(<span class="params">nums, l, r</span>):<span class="comment">#力扣里写的时候要把函数写在def函数体里，并且先写在上方</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="comment">#       i i+1 k                     temp+1</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]  <span class="comment"># 交换之后为[3, 4, 2, 2, 1] 然后需要把索引从i+1开始逆序</span></span><br><span class="line"><span class="built_in">print</span>(nextPermutation(nums))  <span class="comment"># [3, 1, 2, 2, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="【有效的括号】，括号匹配"><a href="#【有效的括号】，括号匹配" class="headerlink" title="【有效的括号】，括号匹配"></a>【有效的括号】，括号匹配</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p>栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；<br>建立哈希表 dic 构建左右括号对应关系：key左括号，value右括号；这样查询 22 个括号是否对应只需O(1) 时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。</p>
<ul>
<li>如果 c 是左括号，则入栈append；</li>
<li>否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 false。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic = &#123;<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,  <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != c: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804131739836.png" alt="image-20210804131739836" style="zoom:67%;" />]]></content>
      <categories>
        <category>面试</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(5)——python</title>
    <url>/2022/02/05/QA_python/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-5-——python"><a href="#面试QA整理-5-——python" class="headerlink" title="面试QA整理(5)——python"></a>面试QA整理(5)——python</h1><h2 id="python常使用的方法或模块"><a href="#python常使用的方法或模块" class="headerlink" title="python常使用的方法或模块"></a>python常使用的方法或模块</h2><p>因为我研究生研究方向是深度学习，所以问了下常使用的方法或模块。</p>
<p><strong>os常用方法：</strong></p>
<p>os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。</p>
<p>os.path.join(path,name):连接目录与文件名或目录;使用“\”连接  </p>
<p>os.listdir(path)返回指定目录下的所有文件和目录名</p>
<p>import <strong>numpy</strong> as np  </p>
<p>对于矩阵（matrix）而言，multiply是对应元素相乘，而 * 、np.matmul() 函数 与 np.dot()函数 相当于矩阵乘法（矢量积），对应的列数和行数必须满足乘法规则；如果希望以数量积的方式进行，则必须使用 np.multiply 函数</p>
<p><strong>torch</strong></p>
<ol>
<li>点乘——<code>torch.mul(a, b)</code></li>
<li>矩阵乘</li>
</ol>
<p>2.1. 二维矩阵乘——<code>torch.mm(a, b)</code><br>2.2. 高维矩阵乘——<code>torch.matmul(a, b)</code></p>
<p>torch.nn.Conv2d() 对由多个输入平面组成的输入信号进行二维<strong>卷积</strong></p>
<h2 id="sorted-，sort区别"><a href="#sorted-，sort区别" class="headerlink" title="sorted ，sort区别"></a>sorted ，sort区别</h2><ul>
<li><p>sort()与sorted()的不同在于，sort是在原位重新排列列表，而<strong>sorted()是产生一个新的列表</strong>。</p>
<ul>
<li>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作</li>
</ul>
</li>
<li><p>sort 是应用在 list 上的方法，<strong>sorted 可以对所有可迭代的对象进行排序操作</strong>。</p>
</li>
</ul>
<h2 id="☆☆python基本的数据类"><a href="#☆☆python基本的数据类" class="headerlink" title="☆☆python基本的数据类"></a>☆☆python基本的数据类</h2><ul>
<li><p>Number（数字）<strong>int、float、bool、complex（复数）</strong></p>
</li>
<li><p>String（字符串）</p>
</li>
<li><p>List（列表）</p>
</li>
<li><p>Tuple（元组）</p>
</li>
<li><p>Set（集合）</p>
</li>
<li><p>Dictionary（字典）</p>
</li>
<li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p>
</li>
<li><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</p>
</li>
</ul>
<h2 id="Python可变数据类型，不可变数据类型"><a href="#Python可变数据类型，不可变数据类型" class="headerlink" title="Python可变数据类型，不可变数据类型"></a>Python可变数据类型，不可变数据类型</h2><p><strong>不可变数据类型：</strong> 数值型、字符串型string和元组tuple（元组使用逗号和圆括号来表示,如 (2, 4, 6)）<br>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址)</p>
<p><strong>可变数据类型：</strong> 列表list和字典dict，Set（集合）；<br>允许变量的值发生变化，即如果对变量进行append、+&#x3D;等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化</p>
<h2 id="list，dict，tuple，set区别"><a href="#list，dict，tuple，set区别" class="headerlink" title="list，dict，tuple，set区别"></a>list，dict，tuple，set区别</h2><p>1、list，dict，set都是可变数据类型，tuple是不可变数据类型（不能重新赋值替换）</p>
<p>​    tuple用处：如果你希望一个函数返回多个返回值，其实只要返回一个tuple就可以</p>
<p>2、List和Tuple用下标来访问内容，而Dict用Key来访问</p>
<p>3、dict中Key不可重复，set不能包含重复的元素</p>
<h2 id="元组和列表区别"><a href="#元组和列表区别" class="headerlink" title="元组和列表区别"></a>元组和列表区别</h2><p>python 中元组和列表的区别如下：<br>1、列表是动态数组，它们可变且可以重设长度（改变其内部元素的个数）；<br>2、元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变；<br>3、元组缓存于 Python 运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。<br>tuple 不可变:多线程无需加锁，可以作为 key，速度快，存储占用少。<br>tuple 只有一个元素时候要加逗号，例如 a&#x3D;(1,) 否则类型就是 int 而不是 tuple  </p>
<h2 id="python-字典删除元素"><a href="#python-字典删除元素" class="headerlink" title="python 字典删除元素"></a>python 字典删除元素</h2><p>1、<code>dict.pop(key,default)</code>，返回值是对应的value</p>
<p>如果设置default的值，如果key不存在，就返回default的值。</p>
<p>如果不设置default的值，如果key不存在，报错</p>
<p>2、<code>del dict[key]</code></p>
<p>如果key不存在，报错</p>
<h2 id="并行，并发"><a href="#并行，并发" class="headerlink" title="并行，并发"></a>并行，并发</h2><p><strong>并发：不同的代码块交替执行</strong><br><strong>并行：不同的代码块同时执行</strong></p>
<h2 id="☆☆python【线程】-x2F-多线程创建方式，查看线程数"><a href="#☆☆python【线程】-x2F-多线程创建方式，查看线程数" class="headerlink" title="☆☆python【线程】&#x2F;多线程创建方式，查看线程数"></a>☆☆python【线程】&#x2F;多线程创建方式，查看线程数</h2><p>（1）通过threading.Thread进行创建多线程</p>
<p>（2）通过<strong>继承</strong>threading.Thread<strong>定义子类</strong>创建多线程</p>
<p>（3）使用<strong>线程池</strong>ThreadPoolExecutor创建</p>
<p>length&#x3D;len(threading.enumerate())#查看线程数</p>
<hr>
<ol>
<li><strong>通过threading.Thread进行创建多线程</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  <span class="comment"># 由于代码执行过快，为了显示效果，使用sleep延时执行。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eat</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在吃饭...%d&quot;</span> % i)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#如果创建Thread时执行的函数，运行结束那么意味着这个子线程结束了.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在读书...%d&quot;</span> % i)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=eat)</span><br><span class="line">    t2 = threading.Thread(target=read)</span><br><span class="line">    t1.start()<span class="comment">#启动线程，即让线程开始执行</span></span><br><span class="line">    t2.start()</span><br><span class="line">    length=<span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())<span class="comment">#查看线程数</span></span><br><span class="line">    <span class="built_in">print</span>(length)</span><br><span class="line"></span><br><span class="line"><span class="comment">#当调用Thread的时候，不会创建线程</span></span><br><span class="line"><span class="comment">#当调用Thread创建出来的实例对象的start()方法地时候才会创建线程以及让这个线程开始运行</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过继承threading.Thread定义子类创建多线程</strong></li>
</ol>
<p>定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):  <span class="comment"># 定义一个类，继承threading.Thread</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):  <span class="comment"># 重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">&quot;I&#x27;m &quot;</span> + self.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)  <span class="comment"># name属性中保存的是当前线程的名字</span></span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line">        self.login()</span><br><span class="line">        self.register()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是登录&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是注册&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = MyThread()  <span class="comment"># 创建对象</span></span><br><span class="line">    t.start()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">I&#x27;m Thread-1 @ 0</span></span><br><span class="line"><span class="string">I&#x27;m Thread-1 @ 1</span></span><br><span class="line"><span class="string">I&#x27;m Thread-1 @ 2</span></span><br><span class="line"><span class="string">这是登录</span></span><br><span class="line"><span class="string">这是注册</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用线程池ThreadPoolExecutor创建</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sayhello</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello: &quot;</span> + a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    seed = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">    <span class="comment"># 最大线程数为3，使用with可以自动关闭线程池，简化操作</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> seed: </span><br><span class="line">        	<span class="comment"># map可以保证输出的顺序, submit输出的顺序是乱的</span></span><br><span class="line">            executor.submit(sayhello, each)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主线程结束&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/lxy0/p/11403555.html">https://www.cnblogs.com/lxy0/p/11403555.html</a></p>
<h2 id="多线程之间共享全局变量，args参数"><a href="#多线程之间共享全局变量，args参数" class="headerlink" title="多线程之间共享全局变量，args参数"></a>多线程之间共享全局变量，args参数</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210811141251924.png" alt="image-20210811141251924" style="zoom:60%;" />

<h2 id="互斥锁-多线程同步控制"><a href="#互斥锁-多线程同步控制" class="headerlink" title="互斥锁 多线程同步控制"></a>互斥锁 多线程同步控制</h2><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p>
<p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p>
<p>互斥锁为资源引入一个状态:锁定&#x2F;非锁定</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改;</p>
<p>直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。</p>
<p>互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">threading模块中定义了Lock类，可以方便的处理锁定:</span><br><span class="line">#创建锁</span><br><span class="line">#创建一个互斥锁，默认是没有上锁的</span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line">#锁定</span><br><span class="line">#上锁，如果之前没有被上锁，那么此时，上锁成功</span><br><span class="line">#如果上锁之前已经被上锁了，那么此时会堵塞在这里，直到这个锁被解开</span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line">#释放</span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>

<h2 id="死锁，避免死锁"><a href="#死锁，避免死锁" class="headerlink" title="死锁，避免死锁"></a>死锁，避免死锁</h2><p>在线程间共享多个资源的时候，<strong>如果两个线程分别占有一部分资源并且同时等待对方的资源</strong>，就会造成死锁。<br>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。</p>
<ul>
<li>程序设计时要尽量避免(银行家算法)</li>
<li>添加超时时间等</li>
</ul>
<p>什么是死锁？<br>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。</p>
<p><strong>1、死锁是指</strong>在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态。<strong>死锁的四个必要条件</strong>：</p>
<p>互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。</p>
<p>请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。</p>
<p>不可抢占条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。</p>
<p>循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</p>
<p><strong>java中产生死锁可能性的最根本原因是</strong>：1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。</p>
<p>如，线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因。</p>
<p><strong>2、避免死锁：</strong></p>
<p>只要破坏这四个必要条件中的<strong>任意一个条件</strong>，死锁就不会发生</p>
<p>〈1〉打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</p>
<p>〈2〉打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</p>
<p>〈3〉打破请求与保持条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。<strong>如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。</strong>只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</p>
<p>（4）打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高</p>
<p>•  方案一：破坏死锁的循环等待条件。</p>
<p>•  方法二：破坏死锁的请求与保持条件，使用lock的特性，为获取锁操作设置超时时间。这样不会死锁（至少不会无尽的死锁）</p>
<p>•  方法三：设置一个条件遍历与一个锁关联。该方法只用一把锁，没有chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。</p>
<h2 id="函数里面修改全局变量"><a href="#函数里面修改全局变量" class="headerlink" title="函数里面修改全局变量"></a>函数里面修改全局变量</h2><p>在一个函数中对全局变量进行修改的时候，到底是否需要使用global进行说明？</p>
<p>不可变数据类型都要加global</p>
<p>要看是否对全局变量的指向进行了修改，<br>如果修改了指向，即让全局变量指向了一个新的地方，那么必须使用global<br>如果，仅仅是修改了指向的空间中的数据，此时不用必须使用global</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">nums2 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    nums.append(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> nums2</span><br><span class="line">    nums2 += [<span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br><span class="line"><span class="built_in">print</span>(nums2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">[11, 22, 33]</span></span><br><span class="line"><span class="string">[1, 2, 33, 44]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="☆☆python-【进程】，状态，多进程创建"><a href="#☆☆python-【进程】，状态，多进程创建" class="headerlink" title="☆☆python 【进程】，状态，多进程创建"></a>☆☆python 【进程】，状态，多进程创建</h2><p>进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。</p>
<p>不仅可以通过线程完成多任务，进程也是可以的</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210811154716810.png" alt="image-20210811154716810" style="zoom:50%;" />

<ul>
<li>就绪态:运行的条件都已经准备好了，正在等在cpu执行</li>
<li>执行态: cpu正在执行其功能</li>
<li>等待态:等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li>
</ul>
<p><strong>python 进程的几种创建方式</strong></p>
<p>（1）使用multiprocessing模块Process类创建</p>
<p>（2）继承multiprocessing模块Process定义子类创建</p>
<p>（3）使用进程池Pool创建</p>
<p><strong>使用multiprocessing模块Process类创建</strong></p>
<p>multiprocessing模块提供了一个Process类来代表一个进程对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name, age</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--test--%s\t%d&quot;</span> % (name, age))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;子进程结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  p = Process(target=test, args=(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>))</span><br><span class="line">  p.start()</span><br><span class="line">  <span class="comment"># 等待进程实例执⾏结束，或等待多少秒；</span></span><br><span class="line">  p.join() <span class="comment"># 等待的最长时间</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;主进程结束&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">子进程结束</span></span><br><span class="line"><span class="string">主进程结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">join()方法表示主进程等待子进程执行完成后继续往下执行，如果把join()注释掉，则主进程开启子进程后不停顿继续往下执行，然后等待子进程完成程序结束。</span><br><span class="line">把join()方法注释掉的结果：</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">主进程结束</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">--test--aaa 18</span></span><br><span class="line"><span class="string">子进程结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>继承multiprocessing模块Process定义子类创建</strong></p>
<p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyProcess, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写run方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>, self.name)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = MyProcess(<span class="string">&#x27;xpt&#x27;</span>)</span><br><span class="line">        p.start()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello xpt</span></span><br><span class="line"><span class="string">hello xpt</span></span><br><span class="line"><span class="string">hello xpt</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用进程池Pool创建</strong></p>
<p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法</p>
<p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----pid=%d num=%d---&quot;</span> % (os.getpid(), num))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义一个进程池，最大进程数3</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---%d--&quot;</span> % i)</span><br><span class="line">        <span class="comment"># 向进程中添加任务</span></span><br><span class="line">        <span class="comment"># 注意：如果添加的任务数量超过了进程池中进程的个数的话，那么就不会接着往进程池中添加，</span></span><br><span class="line">        <span class="comment"># 如果还没有执行的话，他会等待前面的进程结束，然后在往进程池中添加新进程</span></span><br><span class="line">        <span class="comment"># Pool() .apply_ async(调用的目标，(传递给目标的参数元祖,))</span></span><br><span class="line">        pool.apply_async(worker, (i,))  <span class="comment"># 使用非阻塞方式调用func（并行执行)，一般用这个。</span></span><br><span class="line">        <span class="comment"># apply堵塞方式必须等待上一个进程退出才能执行下一个进程,用的不多。</span></span><br><span class="line">    pool.close() <span class="comment"># 关闭进程池</span></span><br><span class="line">    <span class="comment"># 等待所有子进程结束，主进程一般用来等待</span></span><br><span class="line">    <span class="comment"># 一定要添加join函数，否则主进程直接崩了，看不到进程池中子进程的现象</span></span><br><span class="line">    pool.join()</span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---0--</span></span><br><span class="line"><span class="string">---1--</span></span><br><span class="line"><span class="string">---2--</span></span><br><span class="line"><span class="string">---3--</span></span><br><span class="line"><span class="string">---4--</span></span><br><span class="line"><span class="string">---5--</span></span><br><span class="line"><span class="string">---6--</span></span><br><span class="line"><span class="string">---7--</span></span><br><span class="line"><span class="string">---8--</span></span><br><span class="line"><span class="string">---9--</span></span><br><span class="line"><span class="string">----pid=25096 num=0---</span></span><br><span class="line"><span class="string">----pid=22080 num=1---</span></span><br><span class="line"><span class="string">----pid=24196 num=2---</span></span><br><span class="line"><span class="string">----pid=22080 num=3---</span></span><br><span class="line"><span class="string">----pid=25096 num=4---</span></span><br><span class="line"><span class="string">----pid=24196 num=5---</span></span><br><span class="line"><span class="string">----pid=22080 num=6---</span></span><br><span class="line"><span class="string">----pid=25096 num=7---</span></span><br><span class="line"><span class="string">----pid=24196 num=8---</span></span><br><span class="line"><span class="string">----pid=25096 num=9---</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>   </span><br></pre></td></tr></table></figure>



<h2 id="进程间通信Queue和Pipe"><a href="#进程间通信Queue和Pipe" class="headerlink" title="进程间通信Queue和Pipe"></a>进程间通信Queue和Pipe</h2><p>python的multiprocessing 模块包装了底层的机制，提供了多种进程通信的方式，主要 Queue（队列）、Pipes（管道）这两种方式，<strong>Queue用于多个进程间实现通信，Pipe是两个进程的通信</strong></p>
<p><strong>1、通过multiprocessing.Queue()完成进程间通信</strong></p>
<p>Queue的使用<br>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。</p>
<ul>
<li><code>Queue.qsize()</code>    返回当前队列包含的消息数量</li>
<li><code>Queue.empty()</code>    如果队列为空，返回 True，否则返回 False</li>
<li><code>Queue.full()</code>    如果队列满了，返回 True，否则返回 False</li>
<li><code>Queue.get([block[, timeout]])</code>    获取队列中的一条消息，然后将其从队列中移除，block 默认值为 True。如果 block 使用默认值，且没有设置 timeout（单位：秒），消息队列为空，此时程序将被阻塞（停在读取状态），直到从消息队列读到消息为止，如果设置了 timeout，则会等待 timeout 秒，若还没有读取到任何消息，则抛出 <code>Queue.Empty</code> 异常</li>
<li><code>Queue.get_nowait()</code>    相当于 <code>Queue.get(False)</code></li>
<li><code>Queue.put(item, [block[, timeout]])</code>    将 item 消息写入队列，block 默认值为 True。如果 block 使用默认值，且没有设置 timeout（单位：秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了 timeout，则会等待 timeout 秒，若还没有空间，则抛出 <code>Queue.full</code> 异常</li>
<li><code>Queue.put_nowait(item)</code>    相当于 <code>Queue.put(item, False)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 初始化一个 Queue 对象，最多可接收 3 条 put 消息</span></span><br><span class="line"><span class="built_in">print</span>(q.empty())  <span class="comment"># True</span></span><br><span class="line">q.put(<span class="string">&quot;消息1&quot;</span>)</span><br><span class="line">q.put(<span class="string">&quot;消息2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># False</span></span><br><span class="line">q.put(<span class="string">&quot;消息3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为消息队列已满，再 put 会报异常，第一个 try 等待 2 秒后再抛出异常，第二个 try 立刻抛出</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put(<span class="string">&quot;消息4&quot;</span>, <span class="literal">True</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;消息队列已满，现有消息数量: %s&quot;</span> % q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="string">&quot;消息4&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;消息队列已满，现有消息数量: %s&quot;</span> % q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息时，先判断消息队列是否为空，再读取</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----从消息队列中获取消息--&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(q.get_nowait())</span><br></pre></td></tr></table></figure>

<p>下面通过一个实例结合 Process 和 Queue 实现进程间通信。创建两个子进程，一个子进程负责向队列中写入数据，另一个子进程负责从队列中读取数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向对列中写入数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_task</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q.full():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            message = <span class="string">&quot;消息&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            q.put(message)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;写入: %s&quot;</span> % message)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 从队列读取数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_task</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取: %s&quot;</span> % q.get(<span class="literal">True</span>, <span class="number">0.5</span>))  <span class="comment"># 等待 2 秒，如果还没有读取到任何消息，则抛出异常</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()  <span class="comment"># 父进程创建 Queue，并传递给子进程</span></span><br><span class="line">    pw = Process(target=write_task, args=(q,))</span><br><span class="line">    pr = Process(target=read_task, args=(q,))</span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">写入: 消息0</span></span><br><span class="line"><span class="string">读取: 消息0</span></span><br><span class="line"><span class="string">写入: 消息1</span></span><br><span class="line"><span class="string">读取: 消息1</span></span><br><span class="line"><span class="string">写入: 消息2</span></span><br><span class="line"><span class="string">写入: 消息3</span></span><br><span class="line"><span class="string">读取: 消息2</span></span><br><span class="line"><span class="string">写入: 消息4</span></span><br><span class="line"><span class="string">读取: 消息3</span></span><br><span class="line"><span class="string">读取: 消息4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>通过multiprocessing.Pipe()完成进程间通信</strong></p>
<p>Pipe()函数返回一对由管道连接的连接对象，默认情况下是双工（双向）。</p>
<p>Pipe()返回的两个连接对象代表管道的两端。 每个连接对象都有send()和recv()方法（等等）。 请注意，如果两个进程（或线程）尝试同时读取或写入管道的同一端，管道中的数据可能会损坏。 当然，同时使用管道不同端的过程也不会有风险。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Pipe()返回表示管道末端的一对Connection(conn1，conn2)对象。</span><br><span class="line">如果duplex为<span class="literal">True</span>（默认），则管道是双向的。</span><br><span class="line">如果duplex是<span class="literal">False</span>，那么管道是单向的：conn1只能用于接收消息，conn2只能用于发送消息。</span><br><span class="line"></span><br><span class="line">parent_conn, child_conn = Pipe(<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#表示parent_conn只能用于接收消息，child_conn只能用于发送消息</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># - * -coding: utf - 8 - * -</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">conn</span>):</span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(conn.recv())  <span class="comment"># 666</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Pipe()返回的两个连接对象代表管道的两端</span></span><br><span class="line">    <span class="comment"># 每个连接对象都有send()和recv()方法</span></span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(parent_conn.recv())  <span class="comment"># [42, None, &#x27;hello&#x27;]</span></span><br><span class="line">    parent_conn.send(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    p.terminate()</span><br></pre></td></tr></table></figure>

<h2 id="python-可迭代对象，迭代器，区别"><a href="#python-可迭代对象，迭代器，区别" class="headerlink" title="python 可迭代对象，迭代器，区别"></a>python 可迭代对象，迭代器，区别</h2><p>迭代是访问集合元素的一种方式。<strong>迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断classmate是否是可迭代对象</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable </span><br><span class="line"><span class="built_in">isinstance</span>(classmate, Iterable)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断classmate_iterator是否是迭代器</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator </span><br><span class="line"><span class="built_in">isinstance</span>(classmate_iterator, Iterator)</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">classmate = Classmate()  <span class="comment"># 创建了一个实例对象</span></span><br><span class="line"><span class="comment">#for循环内部实现细节</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> classmate:</span><br><span class="line">	<span class="keyword">pass</span> </span><br><span class="line"><span class="number">1.</span>判断classmate是否是可迭代对象</span><br><span class="line"><span class="number">2.</span>在第<span class="number">1</span>步成立的前提下，调用<span class="built_in">iter</span>函数得到classmate对象的__iter__方法的返回值，<span class="built_in">iter</span>(classmate)</span><br><span class="line"><span class="number">3.</span>__iter__方法的返回值是一个迭代器</span><br></pre></td></tr></table></figure>

<p>如果想要一个对象成为一个<strong>可迭代的对象</strong>，即可以使用for，那么必须实现<code>__iter__</code> 方法</p>
<p>创建一个<strong>迭代器</strong>，把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
<ul>
<li><p><code>__iter__() </code>方法返回一个特殊的迭代器对象， 这个迭代器对象实现了<code>__next__()</code>方法并通过StopIteration异常标识迭代的完成。</p>
</li>
<li><p><code>__next__() </code>方法会返回下一个迭代器对象。</p>
</li>
</ul>
<p><strong>可迭代对象与迭代器区别</strong></p>
<p>1）可迭代对象包含迭代器。（如果是迭代器，那么一定是可迭代对象，反之不成立）<br>2）如果一个对象拥有<code>__iter__()</code>方法，其是可迭代对象；如果一个对象拥有<code>__next__() </code>方法，其是迭代器。<br>3）定义可迭代对象，必须实现<code>__iter__()</code>方法；定义迭代器，必须实现<code>__iter__()</code>和<code>__next__() </code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.names.append(name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果想要一个对象成为一个可迭代的对象，即可以使用for，那么必须实现__iter__方法</span></span><br><span class="line">        <span class="keyword">return</span> ClassIterator(self)  <span class="comment"># 返回一个对象引用，把self传进去</span></span><br><span class="line"><span class="comment">#================这里其实还可以优化，直接return self，怎么做？看下一个代码====================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassIterator</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 这是一个迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        self.obj = obj  <span class="comment"># 想获取name怎么办，接收Classmate传进来的self</span></span><br><span class="line">        self.current_num = <span class="number">0</span>  <span class="comment"># 用来取下一个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如何避免报错IndexError: list index out of range</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.obj.names):</span><br><span class="line">            ret = self.obj.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="comment"># 后面一直输出None，如何让for循环停</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">classmate = Classmate()  <span class="comment"># 创建了一个实例对象</span></span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;老高&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;大宇&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#那直接return self，怎么做？</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line">        self.current_num = <span class="number">0</span>  <span class="comment"># 用来取下一个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.names.append(name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果想要一个对象成为一个可迭代的对象，即可以使用for，那么必须实现__iter__方法</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如何避免报错IndexError: list index out of range</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.names):</span><br><span class="line">            ret = self.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="comment"># 后面一直输出None，如何让for循环停</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">classmate = Classmate()  <span class="comment"># 创建了一个实例对象</span></span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;老高&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;大宇&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器的优点，占用极小的空间去迭代</span></span><br><span class="line"><span class="comment"># python-迭代器生成斐波那契数列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, all_num</span>):</span><br><span class="line">        self.all_num = all_num</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; self.all_num:  <span class="comment"># 判断是否可以迭代</span></span><br><span class="line">            ret = self.a</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration  <span class="comment"># 迭代完成，抛出异常，退出迭代</span></span><br><span class="line"></span><br><span class="line">fib = Fibonacci(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> fib:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p>并不是只有for循环能接收可迭代对象<br>除了for循环能接收可迭代对象， list、tuple等也能接收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li = list(FibIterator(15) )</span><br><span class="line">print(li)</span><br><span class="line">tp = tuple(FibIterator(6))</span><br><span class="line">print(tp)</span><br></pre></td></tr></table></figure>

<h2 id="Python-生成器，yield"><a href="#Python-生成器，yield" class="headerlink" title="Python 生成器，yield"></a>Python 生成器，yield</h2><p>生成器是一种特殊的迭代器</p>
<p><strong>为什么要有生成器</strong><br>列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。</p>
<p>如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p>
<p>简单一句话：<strong>我又想要得到庞大的数据，又想让它占用空间少，那就用生成器！</strong></p>
<p><strong>创建生成器方法1</strong>，第一种方法很简单，只要把一个列表生成式的[]改成()</p>
<p>生成器表达式与列表推导式长的非常像，但是它俩返回的对象不一样，前者返回生成器对象，后者返回列表对象。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812133035812.png" alt="image-20210812133035812" style="zoom:60%;" />

<p><strong>创建生成器方法2</strong>， 如果一个函数中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）对象。</p>
<p>yield返回值的过程（<em>关注点：每次停在哪，下次又开始在哪</em>）</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812132426231.png" alt="image-20210812132426231" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812135251018.png" alt="image-20210812135251018" style="zoom:50%;" />

<p>我们除了可以使用next()函数来唤醒生成器继续执行外，还可以<strong>使用send()函数来唤醒执行</strong>。使用send()函<br>数的一个好处是可以在唤醒的同时<strong>向断点处传入一个附加数据</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812142542982.png" alt="image-20210812142542982" style="zoom:50%;" />

<p><strong>生成器的工作原理</strong><br>（1）生成器(generator)能够迭代的关键是它有一个next()方法，</p>
<p>　　工作原理就是通过重复调用next()方法，直到捕获一个异常。</p>
<p>（2）<strong>带有 yield 的函数</strong>不再是一个普通函数，而是一个<strong>生成器generator</strong>。</p>
<p>　　可用next()调用生成器对象来取值。next 两种方式<code> t.__next__()</code>  | <code> next(t)</code>。</p>
<p>　　可用for 循环获取返回值（每执行一次，取生成器里面一个值）</p>
<p>　　（基本上不会用next()来获取下一个返回值，而是直接使用for循环来迭代）。</p>
<p>（3）yield相当于 return 返回一个值，并且记住这个返回的位置，<strong>下次迭代时，代码从yield的下一条语句开始执行。</strong></p>
<p>（4）.send() 和next()一样，都能让生成器继续往下走一步（下次遇到yield停），但<strong>send()能传一个值</strong>，这个值作为yield表达式整体的结果</p>
<p>　　——换句话说，就是send可以强行修改上一个yield表达式值。比如函数中有一个yield赋值，a &#x3D; yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，那么a&#x3D;10</p>
<h2 id="【协程】使用yield，greenlet，gevent完成多任务"><a href="#【协程】使用yield，greenlet，gevent完成多任务" class="headerlink" title="【协程】使用yield，greenlet，gevent完成多任务"></a>【协程】使用yield，greenlet，gevent完成多任务</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812143257904.png" alt="image-20210812143257904" style="zoom:50%;" />

<p><strong>greenlet</strong><br>为了更好地使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812143840147.png" alt="image-20210812143840147" style="zoom:50%;" />

<p><strong>greenlet已经实现了协程，但是这个还的人工切换</strong>，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够<strong>自动切换任务的模块gevent</strong></p>
<p><strong>gevent</strong><br>其原理是当一个greenlet遇到IO(指的是input output输入输出，比如网络、文件操作等)操作时，比如访问<br>网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。<br>由于IO操作非常耗时，经常使程序处于等待状态，有了<strong>gevent为我们自动切换协程</strong>，就保证总有greenlet在<br>运行，而不是等待IO</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812145116087.png" alt="image-20210812145116087" style="zoom:50%;" />

<p><strong>gevent打补丁，joinall更简洁：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812145044628.png" alt="image-20210812145044628" style="zoom:50%;" />

<h2 id="Python中生成器和迭代器的区别（可迭代对象"><a href="#Python中生成器和迭代器的区别（可迭代对象" class="headerlink" title="Python中生成器和迭代器的区别（可迭代对象"></a>Python中生成器和迭代器的区别（可迭代对象</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804125716180.png" alt="image-20210804125716180" style="zoom:50%;" />

<p>可迭代对象与迭代器</p>
<p>1）可迭代对象包含迭代器。<br>2）如果一个对象拥有<code>__iter__</code>方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。<br>3）定义可迭代对象，必须实现<code>__iter__</code>方法；定义迭代器，必须实现<code>__iter__</code>和next方法。</p>
<p><strong>生成器是一种特殊的迭代器，生成器自动实现了“迭代器协议”（即__iter__和next方法）</strong>，不需要再手动实现两方法。只需要一个<code>yiled</code>关键字。 生成器一定是迭代器（反之不成立）</p>
<p><strong>具有yield关键字的函数都是生成器</strong>，yield可以理解为return，返回后面的值给调用者。不同的是return返回后，函数会释放，而生成器则不会。在直接调用next方法或用for语句进行下一次迭代时，生成器会从yield下一句开始执行，直至遇到下一个yield。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804130113694.png" alt="image-20210804130113694" style="zoom:67%;" />



<h2 id="【进程、线程、协程】对比"><a href="#【进程、线程、协程】对比" class="headerlink" title="【进程、线程、协程】对比"></a>【进程、线程、协程】对比</h2><p>1.进程是资源分配的单位<br>2.线程是操作系统调度（CPU调度）的最小单位<br>3.进程切换需要的资源很最大，效率很低<br>4.线程切换需要的资源一般，效率一般(当然了在不考虑GIL的情况下)<br>5.协程切换任务资源很小，效率高，<strong>利用线程等待的时间</strong><br>6.多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中所以是并发</p>
<p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程的特点在于是一个线程执行，那<strong>和多线程比，协程有何优势？</strong></p>
<ul>
<li><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>
<h2 id="Python-file打开为什么要close，with用法"><a href="#Python-file打开为什么要close，with用法" class="headerlink" title="Python file打开为什么要close，with用法"></a>Python file打开为什么要close，with用法</h2><p>打开的文件句柄没有被close掉的话，那这个句柄只会在程序退出时才会被释放掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">class OpenFileTest:</span><br><span class="line">    def openfile(self, filePath):</span><br><span class="line">        handle = open(filePath, &#x27;wb&#x27;)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    t = OpenFileTest()</span><br><span class="line">    filePath = &#x27;a.txt&#x27;</span><br><span class="line">    t.openfile(filePath)</span><br><span class="line">    os.remove(filePath)</span><br><span class="line">    print(&quot;sucess&quot;)</span><br></pre></td></tr></table></figure>

<p>将代码稍作改动，将 handle &#x3D; open(filePath, ‘wb’) 替换为 self.handle &#x3D; open(filePath, ‘wb’)，执行结果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210806004346065.png" alt="image-20210806004346065" style="zoom:33%;" />

<p>由以上的表现可以得知，在第一个程序里由于handle是一个临时的变量（对象），在函数openfile退出时，handle对象被释放了，同时也把文件句柄给关闭了；</p>
<p>而在第二个程序里，self.handle不再是一个临时的对象，因此在openfile退出时就没有释放句柄，因此就无法删除test.txt这个文件了；</p>
<p>这里也可以猜测一下，在python里，open返回的是一个类似C++里智能指针的东西，这样就做到了handle释放时关闭文件句柄；不过从编程规范上来说，还是主动调用close来关闭文件句柄吧（注意这里指的是用with，一个比较pythonic的方式，如</p>
<blockquote>
<p>with open(r’test1.txt’,’a’) as handler:<br>    …   handler.write(‘123123’)）</p>
</blockquote>
<pre><code>有时候在编码的时候老忘记关闭文件，现在我们给出一种自动关闭文件的方法，从而不需要我们手动每次写关闭函数。Python--file 的with用法
</code></pre>
<h2 id="python-GIL-全局解释器锁"><a href="#python-GIL-全局解释器锁" class="headerlink" title="python GIL 全局解释器锁"></a>python GIL 全局解释器锁</h2><p>一、<strong>什么是GIL？</strong><br>即全局解释器锁（global interpreter lock），每个线程在执行时候都需要先获取GIL，<strong>保证同一时刻只有一个线程可以执行代码</strong>，即同一时刻只有一个线程使用CPU，也就是说多线程并不是真正意义上的同时执行。</p>
<hr>
<p>二、<strong>python为什么要有全局解释器锁（GIL</strong><br>GIL的目的是<strong>解决多线程同时竞争程序中的全局变量</strong>而出现的<strong>线程安全问题</strong>。<strong>它并不是python语言的特性</strong>，仅仅是由于<strong>历史原因</strong>，GIL在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。<br><strong>吉多在创建python时就只考虑到单核cpu</strong>，没有考虑到我们计算机发展这么快哈。解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁， 于是有了GIL这把超级大锁。cpython在解析多线程时，会上GIL锁，保证了同时只有一个线程占用cpu。<br>吉多有一个声明叫做：It isn’t Easy to Remove the GIL。有些消息就说吉多已经尝试过解决GIL的问题，要把GIL抹掉，就需要加其他东西来保证程序稳定运行，但是最终的效率没有GIL快，所以一直保留GIL到今天。</p>
<hr>
<p>三、<strong>由于GIL的存在，即使是多线程，事实上同一时刻只能保证一个线程在运行，既然这样多线程的运行效率不就和单线程一样了吗，那为什么还要使用多线程呢？</strong><br>例如在使用多线程抓取网页内容时，<strong>遇到IO阻塞时，正在执行的线程会暂时释放GIL锁</strong>，<strong>这时其它线程会利用这个空隙时间</strong>，执行自己的代码，因<strong>此多线程抓取比单线程抓取性能要好。</strong><br><strong>计算密集型（程序没有延时，一刻不停在计算）：</strong>要进行大量的数值计算，例如进行上亿的数字计算、计算圆周率、对视频进行高清解码等等。这种计算密集型任务虽然也可以用多任务完成，但是花费的主要时间在任务切换的时间，此时CPU执行任务的效率比较低。<strong>这时候用进程！！！</strong><br><strong>IO密集型（有等待的间隙）</strong>：读写，U盘的读写，网络的收与发、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，<strong>任务的大部分时间都在等待IO操作完成</strong>（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。<strong>这时候可以考虑用线程、协程！</strong></p>
<hr>
<p>四、<strong>怎么解决GIL的问题</strong></p>
<ol>
<li><strong>更换解释器</strong>，更换cpython为jpython(不建议)</li>
<li><strong>使用多进程</strong>完成多线程的任务</li>
<li><strong>多线程使用其他语言来实现</strong>，在使用多线程可以使用c语言去实现</li>
</ol>
<hr>
<p>五、<strong>什么时候会释放GIL锁？</strong></p>
<ol>
<li>遇到像 i&#x2F;o操作这种，会有时间空闲情况，造成cpu闲置的情况，可以暂时释放GIL，但在执行完毕后,必须重新获取GIL。</li>
<li>Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）<br>Python 2.x，有一个专门ticks进行计数 一旦ticks数值达到100，这个时候释放Gil锁，线程之间开始竞争Gil锁</li>
</ol>
<hr>
<p>六、<strong>互斥锁和Gil锁的关系</strong><br> Gil锁 : 保证同一时刻只有一个线程能使用到cpu<br> 互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混乱</p>
<h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>浅拷贝b&#x3D;a，指向<br><strong>浅拷贝:拷贝了引用，并没有拷贝内容</strong><br>完成浅拷贝c&#x3D;copy . copy(a)</p>
<p><strong>深拷贝是重新开辟内存空间并将数据完完全全的拷贝出来一份</strong><br>完成深拷贝import copy<br>c &#x3D; copy . deepcopy(a)</p>
<p>如果copy.copy拷贝的是元组，那么它不会进行浅拷贝，仅仅是引用指向<br>原因:因为元组时不可变类型，那么意味着数据定不能修改，因此用copy.copy的时候它会自动判断，如果是元组它就是指向了它</p>
<p>如果copy.deepcopy拷贝的是元组，真真实实的数据，那也是引用指向，但如果是（a,b）,a和b是列表，还是会完完全全的拷贝出来一份</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>一个函数定义中引用了函数外定义的变量，并且该函数可以在其定义环境外被执行。</p>
<p>我们可以将闭包理解为一种特殊的函数，这种函数由两个函数的嵌套组成，且称之为外函数和内函数，<strong>外函数返回值是内函数的引用</strong>，此时就构成了闭包。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812164059595.png" alt="image-20210812164059595" style="zoom:50%;" />

<h2 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h2><p>python装饰器就是用于<strong>拓展原来函数功能的一种函数</strong>，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在<strong>不用更改原函数的代码前提下给函数增加新的功能。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812165905345.png" alt="image-20210812165905345" style="zoom:67%;" />

<p><code>@set_ func 等价于test1 = set_ func(test1)</code>如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数,而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器的实现过程：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812170627134.png" alt="image-20210812170627134" style="zoom:67%;" />

<p><strong>（1）对有参数，无返回值的函数进行装饰：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812170943972.png" alt="image-20210812170943972" style="zoom:67%;" />

<p><strong>（2）对不定长参数的函数装饰：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812171857286.png" alt="image-20210812171857286" style="zoom:67%;" />

<p><strong>（3）对应有返回值函数进行装饰、通用装饰器：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812172356604.png" alt="image-20210812172356604" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812172420428.png" alt="image-20210812172420428" style="zoom:67%;" />

<p><strong>（4）多个装饰器对同一个函数装饰</strong></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210812173846673.png" alt="image-20210812173846673" style="zoom:60%;" />

<h2 id="python-反射"><a href="#python-反射" class="headerlink" title="python 反射"></a>python 反射</h2><p>在做程序开发中，我们常常会遇到这样的需求：需要执行对象里的某个方法，或需要调用对象中的某个变量，但是由于种种原因我们<strong>无法确定这个方法或变量是否存在</strong>，这是我们需要用一个特殊的方法或机制去访问和操作这个未知的方法或变量，这中机制就称之为反射。接下记录下反射几个重要方法：</p>
<p>hasattr判断对象中是否有这个方法或变量</p>
<p>getattr获取对象中的方法或变量的内存地址</p>
<p>setattr为对象添加变量或方法</p>
<p>delattr删除对象中的变量。注意：不能用于删除方法</p>
<p><strong>这就是python的反射，它的核心本质其实就是利用字符串的形式去对象（模块）中操作（查找&#x2F;获取&#x2F;删除&#x2F;添加）成员，一种基于字符串的事件驱动</strong></p>
<h2 id="python-抽象类，接口"><a href="#python-抽象类，接口" class="headerlink" title="python 抽象类，接口"></a>python 抽象类，接口</h2><p>首先，我们必须明确的一点是：python中无接口类型，定义接口只是人为规定，在编程过程自我约束！</p>
<p>定义一个接口对继承类进行约束，接口里有什么方法，继承类就必须有什么方法</p>
<p>抽象类，可以说是类和接口的混合体，既可以定义常规方法，也可以约束子类的方法（抽象方法）</p>
<p>在其他的语言里，比如Java，继承类没有重写接口方法是会报错的，而在python里不会，就是因为python没这个类型，所以只是在我们编程过程的一个规定，以I开头的类视为接口</p>
<h2 id="python-中-和"><a href="#python-中-和" class="headerlink" title="python 中 和*"></a>python 中 <em>和</em>*</h2><p>1、运算中</p>
<p>一个 <code>*</code> ：乘法<br>两个 <code>**</code>： 乘幂</p>
<p>2、收集列表中多余的值，只用于列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,*c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#[3, 4]</span></span><br></pre></td></tr></table></figure>

<p>3、 解包——用在变量前面</p>
<p>向函数传递参数，将变量中可迭代对象的元素拆解出来，作为独立的参数传递给函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">#元祖、列表、字符串都可以用</span></span><br><span class="line"><span class="built_in">print</span>(*a)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>而两个星号是给字典解包的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;a&#125;,&#123;b&#125;,&#123;c&#125;&#x27;</span>.<span class="built_in">format</span>(**dic))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#1,2,3</span></span><br></pre></td></tr></table></figure>

<p>4、在函数定义中使用，收集参数。【*代表收集参数，**代表收集关键字参数】</p>
<p>一个<code>*</code>的情况<br>该位置接受任意多个非关键字（non-keyword）参数，在函数中将其转化为<strong>元组</strong>(1,2,3,4)</p>
<p>也就是将调用时提供的所有值，放在一个元组里：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myprint</span>(<span class="params">*params</span>):</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">myprint(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#(1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<p>两个<code>**</code>的情况<br>该位置接受任意多个关键字 （keyword）参数，在函数<code>**</code>位置上转化为<strong>字典</strong>[key:value, key:value]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myprint2</span>(<span class="params">**params</span>):</span><br><span class="line">    <span class="built_in">print</span>(params)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">myprint2(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h2><p><strong>三种情况触发垃圾回收</strong><br>1、调用 gc.collect()<br>2、 GC 达到阀值时<br>3、程序退出时  </p>
<hr>
<p>如果不垃圾回收会发生什么问题? –内存泄漏</p>
<p>python的垃圾回收机制实际上是<strong>一个引用计数器+一个循环垃圾收集器</strong>来工作;</p>
<ul>
<li><p>垃圾回收器是一段独立的代码，用来寻找引用计数为0的对象;</p>
</li>
<li><p>垃圾回收器还负责检查虽然引用计数&gt;0但也应该被销毁的对象; —循环引用</p>
<ul>
<li><p>循环引用发生在<strong>有至少两个对象互相引用</strong>，垃圾回收器也会清理未引用的循环</p>
<p>python解释器会跟踪对象的引用技术，垃圾回收器负责释放内存</p>
</li>
</ul>
</li>
</ul>
<p><strong>python的垃圾回收机制，以引用计数为主，标记清除和分代回收为辅。</strong></p>
<p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<p><strong>一、Python中，主要通过引用计数（Reference Counting）进行垃圾回收。</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line"> int ob_refcnt;</span><br><span class="line"> struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p>在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。</p>
<p>以下情况是导致引用计数加一的情况:</p>
<ul>
<li>对象被创建，例如a&#x3D;2</li>
<li>对象被引用，b&#x3D;a</li>
<li>对象被作为参数，传入到一个函数中</li>
<li>对象作为一个元素，存储在容器中</li>
</ul>
<p>下面的情况则会导致引用计数减一:</p>
<ul>
<li>对象别名被显示销毁 del</li>
<li>对象别名被赋予新的对象</li>
<li>一个对象离开他的作用域</li>
<li>对象所在的容器被销毁或者是从容器中删除对象</li>
</ul>
<p><strong>二、标记清除</strong><br>标记清除可以处理这种循环引用的情况，它分为两个阶段：</p>
<ul>
<li><p>第1阶段，标记阶段<br>GC会把所有活动对象打上标记，这些活动的对象就如同一个点，他们之间的引用关系构成边，最终点个<br>边构成了一个有向图，如下图所示</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804111020532.png" alt="image-20210804111020532" style="zoom:25%;" />
</li>
<li><p>第2阶段，搜索清除阶段<br>从根对象(root) 出发，沿着有向边遍历整个图，<strong>不可达的对象就是需要清理的垃圾对象。</strong>这个根对象<br>就是全局对象，调用栈，寄存器。<br>在上图中，从root出发后，可以到达1234,而5，6，7均不能到达， 其中6和7互相引用，这3个对<br>象都会被回收。</p>
</li>
</ul>
<p><strong>三、分代回收</strong></p>
<ul>
<li>分代回收建立标记清除的基础之上，是一种以空间换时间的操作方式。标记清除可以回收循环引用的垃<br>圾，但是，<strong>回收的频次是需要控制的</strong>，如果时时刻刻做标记清除，可以想象， python的程序会慢成什么<br>样子。</li>
<li>分代回收，根据内存中对象的存活时间将他们分为3代，新生的对象放入到0代，如果-个对象能在第0<br>代的垃圾回收过程中存活下来，GC就会将其放入到1代中，如果1代里的对象在第1代的垃圾回收过程中<br>存活下来，则会进入到2代。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804111257575.png" alt="image-20210804111257575" style="zoom:50%;" /></li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804111426153.png" alt="image-20210804111426153" style="zoom:50%;" /></li>
<li>轻易不要改动！！！！</li>
</ul>
<h2 id="如何提高python执行效率"><a href="#如何提高python执行效率" class="headerlink" title="如何提高python执行效率"></a><strong>如何提高python执行效率</strong></h2><p>1、 使用函数，局部变量比全局变量快很多。尽量使用函数，尽量不使用全局变量</p>
<p>2、 有选择性的消除属性访问。如多用from math import sqrt 而不要直接在程序中多次调用 math.sqrt()，或直接声明局部变量。</p>
<p>3、尽量使用内建的字符串，元组，列表，集合，字典等容器</p>
<p>4、 避免不必要的数据结构或拷贝动作</p>
<p>5、 多使用内置方法（例如del方法、max 方法和min方法），内置操作符（例如”in 和not in”的使用）。</p>
<p>6、用If语句进行优化。</p>
<p>7、优化循环，避免在一个循环中使用点操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lowerlist = [<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lowercase&#x27;</span>]</span><br><span class="line">upper = <span class="built_in">str</span>.upper</span><br><span class="line">upperlist = []</span><br><span class="line">append = upperlist.append</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> lowerlist:</span><br><span class="line">    append(upper(word))</span><br><span class="line"><span class="built_in">print</span>(upperlist)</span><br><span class="line"><span class="comment">#[&#x27;THIS&#x27;, &#x27;IS&#x27;, &#x27;LOWERCASE&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>优化循环的关键，是要减少Python在循环内部执行的工作量，因为Python原生的解释器在那种情况下，真的会减缓执行的速度。</p>
<p>8、 元素排序尽可能使用键（key）和默认的sort()排序方法；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">somelist = [(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>), (<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>)]</span><br><span class="line">somelist.sort(key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(somelist)<span class="comment">#[(6, 2, 4), (1, 5, 8), (9, 7, 5)]</span></span><br></pre></td></tr></table></figure>

<p>9、 使用较新版本的Python</p>
<h2 id="python-单例模式"><a href="#python-单例模式" class="headerlink" title="python 单例模式"></a>python 单例模式</h2><p><strong>单例模式（Singleton Pattern）</strong>是一种常用的软件设计模式，该模式的主要目的是确保<strong>某一个类只有一个实例存在</strong>。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，<strong>我们希望在程序运行期间只存在一个实例对象</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> Singleton._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    Singleton._instance = <span class="built_in">object</span>.__new__(cls)  </span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line"><span class="built_in">print</span>(obj1,obj2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line">    obj = Singleton()</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task,args=[i,])</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/huchong/p/8244279.html">https://www.cnblogs.com/huchong/p/8244279.html</a></p>
<h2 id="python的面向对象"><a href="#python的面向对象" class="headerlink" title="python的面向对象"></a>python的面向对象</h2><p>封装性、继承性、多态性</p>
<p>多态意味着可以对不同的对象使用同样的操作，但它们可能会以多种形态呈现出结果。</p>
<p>方法多态，运算符也多态</p>
<p><strong>Python是支持多重类继承的</strong></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(3)——数据库</title>
    <url>/2022/02/03/QA_database/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-3-——数据库"><a href="#面试QA整理-3-——数据库" class="headerlink" title="面试QA整理(3)——数据库"></a>面试QA整理(3)——数据库</h1><h2 id="基于MySQL数据库的几种连接查询-内连接、外连接-join"><a href="#基于MySQL数据库的几种连接查询-内连接、外连接-join" class="headerlink" title="基于MySQL数据库的几种连接查询(内连接、外连接 join)"></a>基于MySQL数据库的几种连接查询(内连接、外连接 join)</h2><p>内连接、外连接（ 左(外)连接、右(外)连接、全(外)连接）。</p>
<p>内连接、左连接（左外连接）、右连接（右外连接）、全连接（全外连接）</p>
<ul>
<li><p>inner join内连接就是左右俩表的交集</p>
</li>
<li><p>左(外)连接，<strong>左表(a_table)的记录将会全部表示出来</strong>，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。（在右表 (table_name2) 中没有匹配的行，右表选择列置为null）</p>
</li>
<li><p>右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而<strong>右表(b_table)的记录将会全部表示出来</strong>。左表记录不足的地方均为NULL。</p>
</li>
<li><p>全连接，显示符合条件的数据行，同时显示左右不符合条件的数据行，相应的左右两边显示NULL，即显示左连接、右连接和内连接的<strong>并集</strong></p>
<ul>
<li>MySQL是不支持全外的连接的， full  join写法适合Oracle和DB2</li>
<li>MySQL数据库不支持全外连接查询 但是可以通过UNION来实现【左连接语句 UNION 右连接语句】</li>
</ul>
</li>
</ul>
<blockquote>
<p>from子句中on条件主要用来连接表，其他不属于连接表的条件可以使用where子句来指定； </p>
</blockquote>
<ul>
<li>cross join，交叉连接，实际上就是将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积</li>
<li>交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的 <ul>
<li>数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</li>
</ul>
</li>
</ul>
<h2 id="【索引】是帮助MySQL高效获取数据的排好序的数据结构"><a href="#【索引】是帮助MySQL高效获取数据的排好序的数据结构" class="headerlink" title="【索引】是帮助MySQL高效获取数据的排好序的数据结构"></a>【索引】是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></h2><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。<strong>索引的实现通常使用B树及其变种B+树</strong>。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>索引的优点<br>　　1.创建唯一性索引，保证数据库表中每一行数据的唯一性<br>　　2.大大加快数据的检索速度，这也是创建索引的最主要的原因<br>　　3.减少磁盘IO（向字典一样可以直接定位）<br>索引的缺点<br>      1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加<br>      2.索引需要占用额外的物理空间<br>      3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p>
<h2 id="什么情况适合-x2F-不适合建立索引"><a href="#什么情况适合-x2F-不适合建立索引" class="headerlink" title="什么情况适合&#x2F;不适合建立索引"></a>什么情况适合&#x2F;不适合建立索引</h2><p>一、哪些情况下适合建索引</p>
<ol>
<li>频繁作为where条件语句<strong>查询</strong>的字段</li>
<li>关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等</li>
<li>排序字段可以建立索引</li>
<li>分组字段可以建立索引，因为分组的前提是排序</li>
<li>统计字段可以建立索引，例如count(),max()</li>
</ol>
<p>二、哪些情况下不适合建索引<br>1.频繁<strong>更新的字段</strong>不适合建立索引<br>2.where条件中用不到的字段不适合建立索引<br>3.表数据可以确定比较少的不需要建索引<br>4.数据重复且分布比较均匀的的字段不适合建索引（<strong>唯一性太差的字段不适合建立索引</strong>），例如性别，真假值</p>
<ol start="5">
<li>参与列计算的列不适合建索引</li>
</ol>
<h2 id="☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引"><a href="#☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引" class="headerlink" title="☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引"></a>☆数据库索引的类型（普通索引、唯一索引、主键索引、组合索引、聚集索引、非聚集索引</h2><p><strong>普通索引</strong>（INDEX）这是最基本的索引，它没有任何限制</p>
<p><strong>唯一索引</strong>（UNIQUE） 避免同一个表中某数据列中的值重复</p>
<ul>
<li>索引列的值必须唯一， 但允许有空值。如果是组合索引，则列值的组合必须唯一。  </li>
<li>与主键索引的区别：主键索引只能有一个，唯一索引可有多个</li>
</ul>
<p><strong>主键索引</strong>（PRIMAY KEY）特殊的唯一索引， 不允许有空值。 一个表只能有一个主键。    </p>
<p><strong>联合索引</strong></p>
<p><strong>全文索引</strong>（FULLTEXT）快速定位特定数据</p>
<ul>
<li>只能用于MyISAM类型的数据表；只能用于CHAR ,VARCHAR,TEXT数据列类型；使用大型数据集</li>
</ul>
<p><strong>聚集索引</strong>：聚集索引的顺序就是数据的物理存储顺序，<strong>聚集索引：叶节点包含了完整的数据记录</strong></p>
<p><strong>非聚集索引</strong>：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（相当于就是个二级索引啊  </p>
<p><strong>非聚集索引和聚集索引的区别</strong>在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，</p>
<h3 id="B-树一个节点有多大？一千万条数据，B-树多高？"><a href="#B-树一个节点有多大？一千万条数据，B-树多高？" class="headerlink" title="B+树一个节点有多大？一千万条数据，B+树多高？"></a>B+树一个节点有多大？一千万条数据，B+树多高？</h3><ul>
<li>B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 &lt; 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。</li>
<li>在 MySQL 中 B+ 树的<strong>一个节点大小为“1页”，也就是16k</strong>。之所以设置为一页，是因为对于大部分业务，一页就足够了：</li>
<li>首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。</li>
<li><strong>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</strong></li>
<li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，<strong>一共是14字节</strong>，则16k能存放 <strong>16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针</strong>。</li>
<li>于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li>
<li>而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的。</li>
</ul>
<h2 id="☆索引数据结构（二叉树，红黑树，Hash表，B树，B-树"><a href="#☆索引数据结构（二叉树，红黑树，Hash表，B树，B-树" class="headerlink" title="☆索引数据结构（二叉树，红黑树，Hash表，B树，B+ 树"></a>☆索引数据结构（二叉树，红黑树，Hash表，B树，B+ 树</h2><p>二叉树，红黑树，Hash表，B树，B+ 树</p>
<p><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803154123502.png" alt="image-20210803154123502" style="zoom:40%;" />

<p><strong>B树</strong><br>叶节点具有相同的深度，叶节点的指针为空<br>所有索引元素不重复<br>节点中的数据索引从左到右递增排列</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803153830548.png" alt="image-20210803153830548" style="zoom:40%;" />

<p><strong>红黑树的约束:</strong></p>
<ol>
<li>节点可以是红色的或者黑色的</li>
<li><code>根节点</code>、<code>叶子节点</code>、<code>每个红色节点的子节点</code>是黑色的</li>
<li><code>任何一个节点到其每一个叶子节点</code>的所有路径上黑色节点数相同</li>
</ol>
<p><strong>红黑树的特点:</strong><br>速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 </p>
<h2 id="为什么说B-树更适合数据库索引？"><a href="#为什么说B-树更适合数据库索引？" class="headerlink" title="为什么说B+树更适合数据库索引？"></a>为什么说B+树更适合数据库索引？</h2><p><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</p>
<p>1、 <strong>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</strong></p>
<p>2、<strong>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<h2 id="为什么mongodb里用B树、mysql里面用B-树"><a href="#为什么mongodb里用B树、mysql里面用B-树" class="headerlink" title="为什么mongodb里用B树、mysql里面用B+树"></a>为什么mongodb里用B树、mysql里面用B+树</h2><p>是Mysql中数据遍历操作比较多，所以用B+树作为索引结构。</p>
<p>而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。</p>
<ul>
<li><strong>B+ 树(B树变种)</strong><br>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引<br>叶子节点包含所有索引字段<br>叶子节点用指针连接，提高区间访问的性能</li>
</ul>
<p>(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在<strong>做单一数据查询的时候，使用B树平均性</strong>能更好。但是，由于<strong>B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作</strong>。</p>
<p>(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，<strong>查询速度非常稳定</strong>（都要查到叶子节点）。因此，<strong>在做单一数据的查询上，其平均性能并不如B树。</strong>但是，<strong>B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可</strong>，这个特性使得<strong>B+树非常适合做范围查询</strong>。</p>
<h2 id="基于B-树的索引和基于hash的索引的区别"><a href="#基于B-树的索引和基于hash的索引的区别" class="headerlink" title="基于B+树的索引和基于hash的索引的区别"></a>基于B+树的索引和基于hash的索引的区别</h2><p><strong>哈希索引就是采用一定的哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p>
<p>B+树索引和哈希索引的明显区别是：</p>
<ul>
<li><strong>如果是等值查询，那么哈希索引明显有绝对优势</strong>，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>
<li><strong>如果是范围查询检索，这时候哈希索引就毫无用武之地了</strong>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，<strong>哈希索引也没办法利用索引完成排序</strong>，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li><strong>哈希索引也不支持多列联合索引的最左匹配规则</strong>；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<strong>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</strong>。</li>
</ul>
<h2 id="【mysql引擎】MyISAM索引实现-非聚集"><a href="#【mysql引擎】MyISAM索引实现-非聚集" class="headerlink" title="【mysql引擎】MyISAM索引实现(非聚集)"></a>【mysql引擎】MyISAM索引实现(非聚集)</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803155858999.png" alt="image-20210803155858999" style="zoom:33%;" />

<p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是<strong>分离</strong>的，<strong>索引保存的是数据文件的指针</strong>。主键索引和辅助索引是独立的。</p>
<h2 id="☆【mysql引擎】InnoDB索引实现-聚集"><a href="#☆【mysql引擎】InnoDB索引实现-聚集" class="headerlink" title="☆【mysql引擎】InnoDB索引实现(聚集)"></a>☆【mysql引擎】InnoDB索引实现(聚集)</h2><p>如果想看自己的数据库默认使用的那个存储引擎，可以通过使用命令<code>SHOW VARIABLES LIKE &#39;storage_engine&#39;</code></p>
<p><strong>InnoDB引擎采用B+Tree结构来作为索引结构。</strong></p>
<p><strong>聚集索引：叶节点包含了完整的数据记录</strong></p>
<blockquote>
<p>B+Tree在B-Tree的基础上有两点变化：<br>（1）数据是存在叶子节点中的<br>（2）数据节点之间是有指针指向的</p>
</blockquote>
<p><strong>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID）</strong></p>
<p>InnoDB的存储文件有两个，后缀名分别是 .frm（表的定义文件）和 .idb（表的数据文件）；</p>
<p>InnoDB是聚集索引，使用B+Tree作为索引结构，<strong>数据文件是和（主键）索引绑在一起的</strong>（表数据文件本身就是按B+Tree组织的一个索引结构）</p>
<p>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键）</p>
<p>必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210803162510756.png" alt="image-20210803162510756" style="zoom:33%;" />

<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型自增ID作为主键？</h3><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值-一致性和节省存储空间"><a href="#为什么非主键索引结构叶子节点存储的是主键值-一致性和节省存储空间" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值? (一致性和节省存储空间)"></a>为什么非主键索引结构叶子节点存储的是主键值? (一致性和节省存储空间)</h3><h3 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h3><p>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</p>
<h3 id="innodb默认隔离级别：可重复读-Repeated-Read"><a href="#innodb默认隔离级别：可重复读-Repeated-Read" class="headerlink" title="innodb默认隔离级别：可重复读(Repeated Read)"></a>innodb默认隔离级别：可重复读(Repeated Read)</h3><p>InnoDB默认级别：可重复读(Repeated Read)</p>
<h2 id="MyISAM与InnoDB-的区别-amp-如何选择？"><a href="#MyISAM与InnoDB-的区别-amp-如何选择？" class="headerlink" title="MyISAM与InnoDB 的区别 &amp; 如何选择？"></a>MyISAM与InnoDB 的区别 &amp; 如何选择？</h2><ol>
<li><p>InnoDB支持事务，MyISAM不支持；</p>
<p>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。</p>
</li>
</ol>
<p>  对一个包含外键的InnoDB表转为MYISAM会失败； </p>
<ol start="3">
<li><p>InnoDB的B+树主<strong>键索引的叶子节点就是数据文件</strong>，辅助索引的叶子节点是主键的值；</p>
<p>而MyISAM的B+树主键索引和辅助索引的叶子节点都是<strong>数据文件的地址指针</strong>。</p>
</li>
<li><p><strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。</strong></p>
<p>而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；<br>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询</p>
</li>
<li><p><strong>MyISAM表格可以被压缩后进行查询操作</strong></p>
</li>
<li><p><strong>InnoDB支持表、行(默认)级锁</strong>，而MyISAM支持表级锁</p>
<p>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p>
</li>
<li><p><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</strong></p>
</li>
<li><p><strong>Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI</strong><br>Innodb：frm是表定义文件，ibd是数据文件<br>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</p>
</li>
</ol>
<p>如何选择：</p>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ol>
<h2 id="☆数据库的三大范式1NF-2NF-3NF"><a href="#☆数据库的三大范式1NF-2NF-3NF" class="headerlink" title="☆数据库的三大范式1NF,2NF,3NF"></a>☆数据库的三大范式1NF,2NF,3NF</h2><p><strong>1．1NF，第一范式(确保每列保持原子性)</strong></p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</p>
<p><strong>2．2NF，第二范式(确保表中的每列都和主键相关)</strong></p>
<p>必须是满足第一范式的前提下， 第二范式要求，确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言，因为如果出现不完全依赖，只可能发生在联合主键的情况下）。</p>
<p>比如要设计一个订单表，设计五个字段“订单id”、“商品id”、“顾客id”、“商品名称”、“顾客姓名”，因为一个订单中可能会有多种商品，一个顾客可能会下多个订单，所以要将“订单id”、“商品id”、“顾客id”作为数据库表的联合主键，但是“商品名称”只和“商品id”有关系，“顾客姓名”只和“顾客id”有关系，这样就不满足第二范式。需要拆表</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210723181127392.png" alt="image-20210723181127392" style="zoom:33%;" />

<p><strong>3．3NF，第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></p>
<p>必须是满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。【叫做不能有传递依赖】</p>
<p>比如在设计一个订单数据表的时候，可以将客户id作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、电话、地址等）的字段。</p>
<h2 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h2><p>BCNF范式消除了可能存在的<strong>主属性</strong>对<strong>主码</strong>的部分依赖和传递依赖</p>
<p>BCNF范式在3NF基础上<strong>消除对主码子集的依赖</strong>。</p>
<p>以考试分数表为例：身份证号，学号，科目，分数。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201135632.png" alt="image-20210808201135632" style="zoom:50%;" />

<p>首先该表满足第三范式，表中存在有如下依赖关系：</p>
<p>(身份证号，科目)→(学号，分数)<br>(学号，科目) → (身份证号，分数)</p>
<p>由以上依赖关系可以得知(身份证号，科目)和(学号，科目) 为表关系中的<strong>候选码</strong>。</p>
<p>主属性:身份证号、学号、科目<br>非主属性:分数</p>
<p>但是，由于存在如下决定关系：</p>
<p>(身份证号)——&gt;(学号)</p>
<p>(学号)——&gt;(身份证号)</p>
<p>即存在关键字段决定关键字段的情况，因此其不符合BCNF。</p>
<p>解决方法：把考试分数系表分解为两个关系表：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201510297.png" alt="image-20210808201510297" style="zoom:50%;" />

<p>这样这个数据库表是符合BCNF的，并消除了删除异常、插入异常和更新异常。</p>
<h2 id="4NF-消除多值依赖"><a href="#4NF-消除多值依赖" class="headerlink" title="4NF-消除多值依赖"></a>4NF-消除多值依赖</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210808201630368.png" alt="image-20210808201630368" style="zoom:50%;" />

<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p><strong>mysql中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。</strong></p>
<p>事务：在数据库系统中，<strong>一个事务是指由一系列连续的数据库操作组成的一个完整的逻辑过程</strong>。这组操作执行前后，系统需要处于一个可预知的、一致的状态。</p>
<h2 id="☆数据库的四大特性！ACID特性"><a href="#☆数据库的四大特性！ACID特性" class="headerlink" title="☆数据库的四大特性！ACID特性"></a>☆数据库的四大特性！ACID特性</h2><p>ACID是指在 数据库管理系统（DBMS）中事务所具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<ul>
<li>1、<strong>原子性：事务被视为不可分割的最小单元，在一个事务中所有的操作要么都成功，要么都失败。</strong><ul>
<li>如银行转账，A向B账户转账1000元，这里可分为三个操作，1.A向B转账、2.银行处理、3.B账户收到转账。原子性就是保证这三个操作要么都成功，要么都失败，如果1、2操作成功，3失败了，那么1、2操作要进行回滚</li>
<li>回滚可以通过日志来实现，主要是基于MySQL日志系统的redo和undo机制。日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</li>
</ul>
</li>
<li>2、<strong>一致性：一个事务执行前和执行后都必须处于一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</strong><ul>
<li>一旦一个事务结束了，不管成功还是失败，系统所处的状态和它的业务规则是一致的。也就是说，数据应当不会被破坏。</li>
<li>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来还得是5000，这就是事务的一致性。</li>
</ul>
</li>
<li>3、<strong>隔离性：隔离性是指两个事务之间互不干扰。一个事务所做的修改在最终提交以前，对其他事务是可不见的。</strong><ul>
<li>当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
</ul>
</li>
<li>4、<strong>持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</strong><ul>
<li>持久性需要考虑到事物在执行过程中可能出现的各种异常，并对异常做出相应的处理。</li>
</ul>
</li>
</ul>
<h3 id="mysql中如何控制（开启，关闭）事务"><a href="#mysql中如何控制（开启，关闭）事务" class="headerlink" title="mysql中如何控制（开启，关闭）事务?"></a><strong>mysql中如何控制（开启，关闭）事务?</strong></h3><ul>
<li><p><code>select @@autocommit;</code>语句可以查询事务是否开启，1为开启。mysql默认是开启事务的(<strong>自动提交</strong>)。</p>
<p><code>rollback;</code>回滚，事务开启时是撤销不了的。</p>
</li>
<li><p>设置mysql自动提交为false：<code>set autocommit=0 ;</code></p>
<p>​    这时插入数据后，再<code>rollback;</code>是可以撤销的。</p>
<p>​    但是比如插入数据后输入<code>commit</code><strong>手动提交</strong>，然后再<code>rollback;</code>是不能撤销的。</p>
</li>
<li><p>事务开启之后，一旦commit 提交，就不可以回滚(也就是当前的这个事务在提交的时候就结束了|<br><code>begin;</code>，或者<code>start transaction;</code></p>
<p>——都可以帮我们手动开启一个事务，而且<code>rollback;</code>是可以撤销的</p>
<p>想要提交就<code>commit</code><strong>手动提交</strong>，commit之后不可撤销。</p>
</li>
</ul>
<h2 id="☆数据库四种隔离等级-amp-事务并发问题"><a href="#☆数据库四种隔离等级-amp-事务并发问题" class="headerlink" title="☆数据库四种隔离等级 &amp; 事务并发问题"></a>☆数据库四种隔离等级 &amp; 事务并发问题</h2><p>MySQL定义了四种隔离级别：</p>
<ul>
<li><strong>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。【都可以避免】</strong> <ul>
<li>完全的串行化读，所有SELECT语句都被隐式的转换成SELECT … LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。</li>
<li>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</li>
</ul>
</li>
<li><strong>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。【不可避免幻读】</strong><ul>
<li>在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)</li>
<li>在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了<strong>在一个事务内两次读到的数据是一样的，因此称为是可重复读</strong></li>
</ul>
</li>
<li><strong>③ Read committed (读已提交、不可重复读)：可避免脏读的发生。</strong><ul>
<li><strong>只能读取到已经提交的数据</strong>。即解决了脏读，但未解决不可重复读。（读锁，等写完）</li>
</ul>
</li>
<li><strong>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。【都不能避免】</strong><ul>
<li>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但<strong>允许其他事务读此行数据。</strong></li>
<li>a事务对数据进行操作，在操作的过程中，事务没有被提交，但是b可以看见a操作的结果。</li>
<li>SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）</li>
</ul>
</li>
</ul>
<p><strong>事务并发问题</strong><br><strong>1）脏读（Dirty Reads）</strong>：<br>事务A读取了事务B的更新的数据，但是事务B回滚了（未提交），导致A读取的为脏数据。</p>
<p><strong>2）不可重复读（Non-Repeatable Reads）</strong>：<br>事务A读取同一数据两次，但是在两次之间事务B对该数据进行了修改并提交，导致事务A读取两次读取不一致。</p>
<p><strong>3）幻读（Phantom Reads）</strong>：<br>事务A修改全表的数据，在事务A未提交时，事务B向表中插入或删除数据并提交，导致事务A读取的数据与需要修改的数据不一致。</p>
<p>PS: 不可重复读针对的是数据的修改，幻读针对的时数据的新增和删除。解决不可重复读问题只需要给对应记录上行锁，而解决幻读需要对表加锁。</p>
<ul>
<li><p>实现事物隔离性主要有两种方式</p>
<p><strong>读写锁</strong>和MVCC（Multi-Version Concurrency Control）<strong>多版本并发处理方式</strong>。</p>
</li>
</ul>
<p><strong>不考虑事务的隔离性，会发生的几种问题：</strong></p>
<ul>
<li>1，脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>
</ul>
<p>当一个事务正在多次修改某个数据，而在这个事务还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
<ul>
<li><p>2，不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<ul>
<li>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。</li>
<li><strong>不可重复读和脏读的区别是</strong>，脏读是某一事务读取了另一个事务<strong>未提交的脏数据</strong>，而不可重复读则是读取了<strong>前一事务提交的数据</strong>。</li>
<li>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</li>
</ul>
</li>
<li><p>3，虚读(幻读)：幻读是事务非独立执行时发生的一种现象。</p>
<ul>
<li>例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，<strong>这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。</strong>而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，<strong>其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</strong></li>
<li><strong>幻读和不可重复读</strong>都是读取了另一条<strong>已经提交的事务</strong>（这点就脏读不同），所不同的是<strong>不可重复读查询的都是同一个数据项</strong>，而<strong>幻读针对的是一批数据整体</strong>（比如数据的个数）。</li>
</ul>
</li>
</ul>
<h3 id="如何查看、修改数据库的隔离级别"><a href="#如何查看、修改数据库的隔离级别" class="headerlink" title="如何查看、修改数据库的隔离级别?"></a>如何查看、修改数据库的隔离级别?</h3><p>如何查看数据库的隔离级别?（默认是REPEATABLE-READ）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysq <span class="number">8.0</span>:</span><br><span class="line"><span class="comment">-- 系统级别的</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.transaction_isolation;</span><br><span class="line"><span class="comment">-- 会话级别的</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure>

<p>如何修改数据库的隔离级别?</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<h2 id="☆关系型数据库和非关系型数据库（区别、各自特性优缺点"><a href="#☆关系型数据库和非关系型数据库（区别、各自特性优缺点" class="headerlink" title="☆关系型数据库和非关系型数据库（区别、各自特性优缺点"></a>☆关系型数据库和非关系型数据库（区别、各自特性优缺点</h2><p><strong>区别总结：</strong></p>
<p><strong>1、数据存储结构不同</strong></p>
<ul>
<li>非关系型数据库存储数据的格式，可以是K-V键值对文形式、文档形式、图片形式等，对于数据的格式十分灵活。非关系型数据库可以存储基础类型以及对象或集合等；</li>
<li>而关系型数据库只支持基础类型。(例如在 MySQL 中，主要支持数值类型、日期&#x2F;时间类型、字符串字符类型)</li>
<li>因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择</li>
</ul>
<p><strong>2、可扩展性不同</strong></p>
<ul>
<li>关系型数据库一般都有固定的表结构，不是很容易进行扩展，灵活度稍欠缺。</li>
<li>非关系型数据库具有高扩展性：基于键值对，数据没有耦合性，容易扩展。</li>
</ul>
<p><strong>3、数据一致性方面不同</strong></p>
<ul>
<li>关系型数据库的最大特点就是事务的一致性</li>
<li>而非关系型数据库一般不支持ACID特性。</li>
<li>因此如果业务对于数据的一致性要求很高，那么非关系型数据库并不一个很好的选择</li>
<li>非关系型数据库是基于CAP模型，而传统的关系型数据库是基于ACID模型的<ul>
<li>什么是CAP？Consistency一致性，Availability可用性，Partition tolerance分区容错性。</li>
</ul>
</li>
</ul>
<p><strong>4、读写速度不同</strong></p>
<ul>
<li>关系型数据库，数据读写必须经过sql解析，大量数据、高并发下读写性能不足，对传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</li>
<li>非关系型数据库，在高并发，大数据下读写能力较强。无需经过sql层的解析，读写性能很高。</li>
<li>而且，nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li>
</ul>
<p><strong>5、复杂查询方面</strong></p>
<ul>
<li>关系型数据库，支持SQL，可用于一个表以及多个表之间非常复杂的查询。例如进行join等复杂查询。</li>
<li>非关系型数据库，数据结构相对复杂，复杂查询方面稍欠。</li>
</ul>
<p><strong>6、成本方面</strong></p>
<ul>
<li>关系型数据库，昂贵，像oracle需要花费大量成本购买使用。</li>
<li>nosql数据库部署简单，成本低，基本都是开源软件。</li>
</ul>
<p><strong>7、存储载体不同</strong></p>
<ul>
<li>nosql可以使用硬盘或者随机存储器作为载体</li>
<li>而关系型数据库只能使用硬盘。</li>
</ul>
<hr>
<p>关系型数据库通过外键关联来建立表与表之间的关系，非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</p>
<p>当前主流的<strong>关系型数据库</strong>有Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL等。</p>
<p><strong>非关系型数据库</strong>有 MongoDB、NoSql、Redis、Memcached、HBase   。</p>
<p>非关系型数据库也叫Nosql数据库，全称是not only sql</p>
<p>非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。</p>
<hr>
<p><strong>关系型数据库的特性</strong><br>1、关系型数据库，是指采用了关系模型来组织数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p>
<p><strong>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织</strong><br><strong>优点：</strong><br>1、易于维护：都是使用表结构，格式一致；丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br><strong>缺点：</strong><br>1、为了维护一致性所付出的巨大代价，就是其读写性能比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，灵活度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。<br>数据读写必须经过sql解析，大量数据、高并发下读写性能不足。</p>
<hr>
<p><strong>非关系型数据库的特性</strong><br>1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。可以是文档或者键值对等</p>
<p><strong>非关系型数据库的优点：</strong><br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式；而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、无需经过sql层的解析，读写性能很高；<br>4、高扩展性：基于键值对，数据没有耦合性，容易扩展；<br>5、成本低：nosql数据库部署简单，基本都是开源软件。</p>
<p><strong>非关系型数据库的缺点</strong><br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p>
<h2 id="☆非关系型数据库Mangodb（简介、增删改查命令"><a href="#☆非关系型数据库Mangodb（简介、增删改查命令" class="headerlink" title="☆非关系型数据库Mangodb（简介、增删改查命令"></a>☆非关系型数据库Mangodb（简介、增删改查命令</h2><p>MongoDB是用C++语言编写的非关系型数据库。</p>
<p>MongoDB是一个开源、 高性能、无模式的文档型数据库。是最像关系型数据库(MySQL) 的非关系型数据库。</p>
<p>它支持的数据结构非常松散，是一种类似于JSON的格式叫<strong>BSON</strong>,所以它既可以存储比较复杂的数据类型，又相当的灵活。</p>
<p>MongoDB中的记录是一个文档， MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。 </p>
<p>特点是高性能、易部署、易使用，存储数据十分方便，主要特性有：<br>    面向集合存储，易于存储对象类型的数据<br>    模式自由（不用像MySQL需要指定列啥的<br>    支持动态查询<br>    支持完全索引，包含内部对象<br>    支持复制和故障恢复<br>    使用高效的二进制数据存储，包括大型对象<br>    文件存储格式为BSON(一种JSON的扩展)</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805171429968.png" alt="image-20210805171429968" style="zoom:55%;" />

<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805144217821.png" alt="image-20210805144217821"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805144202411.png" alt="image-20210805144202411"></p>
<h2 id="mysql和redis两种数据库有什么区别"><a href="#mysql和redis两种数据库有什么区别" class="headerlink" title="mysql和redis两种数据库有什么区别"></a>mysql和redis两种数据库有什么区别</h2><p>mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p>
<p>redis是缓存数据库，即将数据存储在缓存中，用于存储使用频繁的数据，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p>
<blockquote>
<p>缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p>
</blockquote>
<p>redis和mysql的区别总结</p>
<p>（1）类型上</p>
<p>从类型上来说，mysql是关系型数据库，redis是缓存数据库</p>
<p>（2）作用上</p>
<p>mysql用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有Redis快<strong>，但是不受空间容量限制</strong>，性价比高</p>
<p>redis用于存储使用较为频繁的数据到缓存中，读取速度快，基于内存，读写速度快，也可做持久化，但是<strong>内存空间有限</strong>，当数据量超过内存空间时，需扩充内存，但内存价格贵</p>
<p>（3）需求上</p>
<p>mysql和redis因为需求的不同，一般都是<strong>配合使用</strong>。<br>需要<strong>高性能的地方使用Redis</strong>，<strong>不需要高性能的地方使用MySQL</strong>。存储数据在MySQL和Redis之间做同步。</p>
<h2 id="☆Redis面试题总结"><a href="#☆Redis面试题总结" class="headerlink" title="☆Redis面试题总结"></a>☆Redis面试题总结</h2><p><strong>redis 简介</strong><br>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 <strong>redis 的数据是存在内存中的，所以存写速度非常快</strong>，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<hr>
<p><strong>为什么要用 redis &#x2F;为什么要用缓存</strong></p>
<p>主要考虑两个角度：<strong>性能和并发</strong></p>
<p>如果说数据要去硬盘上读取，那么过程会比较慢。如果将频繁使用的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，<strong>所以速度相当快</strong>。</p>
<p>在<strong>大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常</strong>。这个时候，就需要使用 Redis 做一个缓冲操作。<strong>直接操作缓存</strong>能够承受的请求是<strong>远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，让请求到 Redis这里而不用经过数据库。</p>
<hr>
<p><strong>Redis支持哪几种数据类型？</strong></p>
<ol>
<li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p>
<p>最常规的 set&#x2F;get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p>
</li>
<li><p>list：按照添加顺序保持顺序的字符串列表。</p>
<p>使用 List 的数据结构（双向链表，可以做简单的消息队列的功能。比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。另外，可以利用 lrange 命令，就是从某个元素开始读取多少个元素,可以做基于 Redis 的分页功能，性能极佳，用户体验好。可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
</li>
<li><p>set：无序的字符串集合，不存在重复的元素。</p>
<p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p>
</li>
<li><p>Zset：有序集合。</p>
<p>多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p>
</li>
<li><p>hash：key-value对的一种集合。</p>
<p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p>
</li>
</ol>
<hr>
<p><strong>Redis到底是多线程还是单线程？单线程的 Redis 为什么这么快</strong></p>
<p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>
<p>(1) 绝大部分请求是<strong>纯粹的内存操作</strong>（非常快速）</p>
<p>(2) 采用单线程，<strong>避免了不必要的上下文切换和竞争</strong>条件</p>
<p>(3) 采用了非阻塞 <strong>I&#x2F;O 多路复用</strong>机制</p>
<p><strong>仔细说一说 I&#x2F;O 多路复用机制</strong></p>
<p>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I&#x2F;O 多路复用程序，将其置入<strong>队列</strong>之中。然后，文件事件分派器，<strong>依次去队列中取</strong>，转发到不同的事件处理器中。</p>
<hr>
<p><strong>redis 持久化机制</strong>（怎么保证 redis 挂掉之后再重启数据可以进行恢复）</p>
<p><strong>持久化</strong>就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis支持持久化，Redis 提供两种持久化机制 <strong>RDB（默认） 和 AOF 机制:</strong></p>
<p><strong>快照（snapshotting，RDB），只追加文件（append-only file,AOF）</strong></p>
<p>对比区别：</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全，但AOF 文件比 RDB 文件大，且恢复速度慢</li>
<li>RDB性能比AOF好，数据集大的时候，AOF比 rdb 启动效率低。</li>
<li><strong>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</strong></li>
</ul>
<p>（1）<strong>RDB：是Redis DataBase缩写快照</strong>。RDB是Redis默认的持久化方式。<strong>按照一定的时间将内存的数据以快照的形式保存到硬盘中</strong>，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>优点：</p>
<ul>
<li>1、只有一个文件 dump.rdb，方便持久化。</li>
<li>2、容灾性好，一个文件可以保存到安全的磁盘。</li>
<li>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li>
<li>4.相对于数据集大时，比 AOF 的启动效率更高。</li>
</ul>
<p>缺点：数据安全性低。RDB 是间隔一段时间进行持久化，<strong>如果持久化之间 redis 发生故障，会发生数据丢失</strong>。所以这种方式更适合数据要求不严谨的时候)</p>
<p>（2）<strong>AOF持久化，</strong>开启AOF持久化后<strong>每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。</strong>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>优点：</p>
<ul>
<li>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li>
<li>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li>
</ul>
<p>缺点：</p>
<ul>
<li>1、AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>2、数据集大的时候，比 rdb 启动效率低。</li>
</ul>
<p><strong>如何选择合适的持久化方式</strong></p>
<ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p><strong>Redis持久化数据和缓存怎么做扩容？</strong></p>
<ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<hr>
<p><strong>Redis主要消耗什么物理资源？</strong>内存。</p>
<p><strong>Redis的内存用完了会发生什么？</strong><br>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<p><strong>Redis如何做内存优化？</strong><br>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<hr>
<p><strong>知道跳跃表吗？在 Redis 中主要用在哪些地方？</strong></p>
<p>zset 有序集合，可以使用范围查找，排行榜功能或者topN功能。</p>
<p><strong>zset 有序集合 就是用跳表来实现的。</strong></p>
<p>跳跃表是一种有序的数据结构,它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<ul>
<li>跳跃表基于<strong>单链表加索引</strong>的方式实现</li>
<li>跳跃表<strong>以空间换时间</strong>的方式提升了查找速度</li>
<li>Redis有序集合在<strong>节点元素较大</strong>（比如很长的字符串）或者<strong>元素数量较多</strong>时使用跳跃表实现</li>
</ul>
<p>像这种链表<strong>加多级索引</strong>的结构，就是跳跃表：</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805220023861.png" alt="image-20210805220023861" style="zoom:33%;" />

<p>思考一个问题，为什么元素数量比较多或者成员 比较长的字符串的时候Redis要使用跳跃表来实现?<br>跳跃表在链表的基础上增加了多级索引以提升查找的效率,其是一个<strong>空间换时间</strong>的方案, 必然会带来个问题：索引是 占内存的。</p>
<p>原始链表中存储的有可能是很大的对象,索引结点只要存储关键值和几个指针,并不需要要存储对象，因此当节点本身比较大或者元素数量比较多的时候,其优势必然会被放大,而缺点则可以忽略。</p>
<hr>
<p><strong>Redis的过期键的删除策略</strong></p>
<p>Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong></p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当客户端访问一个key时，才会判断该key是否已过期，过期则清除。<ul>
<li>该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
</ul>
</li>
<li>定期过期：redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。<ul>
<li>不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略</li>
<li>该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
</li>
</ul>
<hr>
<p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据<br>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<p><strong>Redis的内存淘汰策略有哪些</strong><br>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<ul>
<li><p><strong>全局的键空间</strong>选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，首先通过<strong>LRU算法</strong>驱逐最久没有使用的键。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，随机移除某个key。</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
</li>
<li><p><strong>设置过期时间的键空间</strong>选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，移除最久没有使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，有更早过期时间的key优先移除。</li>
<li>volatile-lfu：从所有配置了过期时间的键中<strong>驱逐使用频率最少的键</strong></li>
</ul>
</li>
</ul>
<p>总结：Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<p><strong>LRU</strong></p>
<ol>
<li><p>新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。</p>
</li>
<li><p>修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。</p>
</li>
<li><p>访问key对应的值的时候把访问的Node节点移动到队尾即可。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210805225025923.png" alt="image-20210805225025923" style="zoom:50%;" />

<p><strong>Redis缓存雪崩、穿透、击穿</strong></p>
<p>缓存处理流程：前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果</p>
<p><strong>缓存雪崩</strong>：redis缓存key同一时间大量失效，导致大量请求全部打到数据库，造成数据库挂掉</p>
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</p>
<p>和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p> <strong>解决方案</strong>：</p>
<ol>
<li>设置缓存数据的过期时间，防止同一时间大量数据过期现象发生，随机初始化缓存失效时间。</li>
<li>redis一般都是集群部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
<li>不断的用定时任务去刷新缓存</li>
</ol>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击，但是不能可能会用不同的ID攻击。</p>
</li>
<li><p>IP拉黑，但可能会用不同的IP来攻击。</p>
</li>
<li><p>接口层增加参数合法性校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
</li>
<li><p>布隆过滤器，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下：</p>
<ul>
<li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li>
<li>这些K个hash值映射到对应的K个二进制的数组下标</li>
<li>将K个下标对应的二进制数据改成1。</li>
</ul>
<p>布隆过滤器筛掉非法的key，就是缓存中不存在且数据库也不存在的数据。布隆过滤器跟redis缓存其实是配合的，都是为了减少无效查询，当然redis缓存可以增加热数据的查询效率，布隆过滤器一般用redis的bitmap来存储，他不可能存数据库的全部信息，只是用来判断数据在或者不在。<br><strong>所以流程是1 查redis的布隆过滤器（如果未命中直接结束） 2 查redis缓存数据 3 查询数据库 淘汰更新缓存。</strong></p>
</li>
</ol>
<p><strong>缓存击穿</strong>是指突然该key失效，一瞬间大量该key的请求打到数据库上</p>
<p>缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，在请求数据库这边给他上锁，那么这个时候就只有一个线程，能抢到这个锁，所以也就只有一个线程能操作这个数据库，那么对数据库的压力就很小，当查询到数据之后呢，还会把缓存重新写到redis里去。其他没有抢到锁的线程，让他先睡几毫秒，然后再重新去redis里面去查询</li>
</ol>
<h2 id="CAP——非关系型数据库是基于CAP模型"><a href="#CAP——非关系型数据库是基于CAP模型" class="headerlink" title="CAP——非关系型数据库是基于CAP模型"></a>CAP——非关系型数据库是基于CAP模型</h2><p>一个经典的分布式系统理论。CAP理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。</p>
<p>1、一致性</p>
<p>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</p>
<p>2、可用性</p>
<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<p>3、分区容错性</p>
<p>分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h2 id="和-区别"><a href="#和-区别" class="headerlink" title="#和$区别"></a>#和$区别</h2><p>面试回答：</p>
<ul>
<li><p><strong>#对传入的参数视为字符串。</strong></p>
</li>
<li><p><strong>$引用参数时，不做任何处理，直接将值拼接在sql语句中。</strong></p>
</li>
<li><p><strong>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译，不能避免注入攻击。</strong></p>
</li>
</ul>
<hr>
<p>向sql语句传参，在sql语句中引用这些参数的时候，有两种方式：#， $。</p>
<p>开启预编译，<strong>如果是$是在此时将参数一起编译；如果是#参数不编译</strong>，会在执行sql查询的时候，将参数当成字符串放进去，也就是同样的sql语句只需要编译一次。</p>
<p><strong>两者的区别：</strong></p>
<ul>
<li><p>使用#方式引用参数的时候，会把传入的参数当成是一个字符串，自动添加双引号。</p>
</li>
<li><p>$引用参数时，不做任何处理，直接将值拼接在sql语句中。</p>
</li>
</ul>
<p>他们之间的区别用最直接的话来说就是：</p>
<p>#是一个占位符，$是拼接符。</p>
<p>#相当于对数据加上双引号，$相当于直接显示数据。</p>
<ul>
<li><p><strong>1、#对传入的参数视为字符串。</strong></p>
<ul>
<li><strong>#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值</strong></li>
<li>也就是它会预编译select * from user where name &#x3D; #{name}</li>
<li>比如我传一个csdn，那么传过来就是select * from user where name &#x3D; ‘csdn’</li>
</ul>
</li>
<li><p><strong>2、$引用参数时，不做任何处理，直接将值拼接在sql语句中。</strong>select * from user where name&#x3D;${name}</p>
<ul>
<li>比如我穿一个csdn，那么传过来就是select * from user where name&#x3D;csdn</li>
</ul>
</li>
<li><p><strong>3、使用 # 能够防止sql注入，$不能避免注入攻击。</strong></p>
<ul>
<li>比如：用户进行一个登录操作，后台sql验证式样的：select * from user where username&#x3D;#{name} and password &#x3D; #{pwd}</li>
<li>如果前台传来的用户名是“wang”，密码是 “1 or 1&#x3D;1”，用#的方式就不会出现sql注入，而如果换成$方式，sql语句就变成了select * from user where username&#x3D;wang and password &#x3D; 1 or 1&#x3D;1，这样的话就形成了sql注入。</li>
</ul>
</li>
<li><p>4、Mybatis 默认情况下，将对所有的 sql 进行预编译。</p>
</li>
<li><p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#。</p>
</li>
</ul>
<h2 id="mysql预编译"><a href="#mysql预编译" class="headerlink" title="mysql预编译"></a>mysql预编译</h2><p><strong>预编译：指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</strong></p>
<p> <strong>为什么需要预编译？预编译的好处：</strong><br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译<strong>。预编译阶段可以优化 sql 的执行。</strong></p>
<ul>
<li><strong>1、预编译之后DBMS可以省去编译，直接运行sql。</strong><ul>
<li>预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译。</li>
</ul>
</li>
<li><strong>2、</strong>一般而言，越复杂的SQL，编译的复杂度将越大，<strong>预编译可以将多个操作合并成一个操作。</strong></li>
<li><strong>3、预编译语句对象可以重复利用。</strong>（把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个 SQL，可以直接使用这个缓存的 PreparedState 对象。）</li>
<li><strong>4、可以将这类SQL语句中的值用占位符替代，不需要每次编译，可以直接执行，只需执行的时候，直接将每次请求的不同的值设置到占位符的位置。</strong></li>
<li><strong>5、预编译可以视为将sql语句模板化或者说参数化。</strong></li>
</ul>
<p><strong>mysql如何开启预编译</strong></p>
<ul>
<li>Mysql是默认 没有开启预编译的，需要在配置中加上<br>jdbc:mysql:&#x2F;&#x2F;xxx.22.11.31:3306&#x2F;dbname?useServerPrepStmts&#x3D;true</li>
</ul>
<p>（有兴趣的可以查看mysql驱动包里面的ConnectionImpl类是如何操作预编译的。这里提一下缓存PreparedStatement，在执行预编译时会先去判断是否存在缓存，如果存在则对参数清空，绑定新的参数。如果不存在则调用数据库进行预编译处理生成一个PreparedStatement对象。）</p>
<p>那如果按照默认不开启预编译的话，会是什么情况？ 每次JDBC都需要编译一条新的sql，即使查询的是同样的sql，也是重新编译一条sql</p>
<img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3c3df9bd05105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:33%;" />

<p>开启预编译，<strong>如果是${}是在此时将参数一起编译，如果是#{}参数不编译</strong>，会在执行sql查询的时候，将参数当成字符串放进去，也就是同样的sql语句只需要编译一次。</p>
<img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3c48dfb843898?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:33%;" />

<p>所以使用${}会编译你参数的这个参数，会有sql风险，而使用#{}仅仅是 select * from t_user where id &#x3D; xxx ，将参数不编译以字符串的形式，放到xxx的位置，参数你写别的sql想注入就会报错。 <strong>能用#{}尽量用#{}！</strong></p>
<h2 id="mysql-读写分离"><a href="#mysql-读写分离" class="headerlink" title="mysql 读写分离"></a>mysql 读写分离</h2><p>1、what 读写分离 </p>
<p>读写分离，基本的原理是让<strong>主数据库</strong>处理事务性<strong>增、改、删</strong>操作（INSERT、UPDATE、DELETE），而<strong>从数据库</strong>处理SELECT<strong>查询</strong>操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p>
<p><strong>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。</strong></p>
<p>2、why 那么为什么要读写分离呢？<br>因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。<br>但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。<br>所以读写分离，解决的是，数据库的写入，影响了查询的效率。</p>
<p>3、when 什么时候要读写分离？<br>数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。</p>
<h2 id="如何优化MySQL"><a href="#如何优化MySQL" class="headerlink" title="如何优化MySQL"></a>如何优化MySQL</h2><p>① SQL语句及索引的优化</p>
<p>② 数据库表结构的优化：使得数据库结构符合三大范式与BCNF</p>
<p>③ 系统配置的优化</p>
<p>④ 硬件的优化</p>
<p>SQL语句的优化：<br>        1、<strong>尽量避免使用子查询</strong>(先查外表再匹配内表,而不是先查内表,当外表的数据很大时,查询速度会非常慢。)<br>        2、<strong>避免函数索引</strong>（WHERE YEAR(d) &gt;&#x3D; 2016;即使d字段有索引，也会直接全表扫描。d &gt;&#x3D; ‘2016-01-01’）<br>        3、用IN来替换OR（MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。对于连续的数值，能用 between 就不要用 in 了）<br>        4、LIKE前缀%号、双百分号、<code>_</code>下划线查询非索引列或<code>*</code>无法使用到索引，如果查询的是索引列则可以<br>        5、<strong>读取适当的记录</strong>LIMIT M,N，而不要读多余的记录<br>        6、避免数据类型不一致<br>        7、分组统计可以禁止排序sort，总和查询可以禁止排重用union all<br>        8、避免随机取记录（MySQL不支持函数索引，会导致全表扫描<br>        9、禁止不必要的ORDER BY排序<br>        10、<strong>批量INSERT插入</strong><br>        11、<strong>不要使用NOT等负向查询条件</strong>（你可以想象一下，对于一棵B+树，根节点是40，如果你的条件是等于20，就去左面查，你的条件等于50，就去右面查，但是你的条件是不等于66，索引应该咋办？还不是遍历一遍才知道。<br>        12、**尽量不用<code>select *</code><em>*（SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）<br>        13、区分in和exists（区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</em>*</p>
<p>​        14、优化Group By语句</p>
<p>​        如果对group by语句的结果没有排序要求，<strong>要在语句后面加 order by null（group 默认会去排序）</strong>；</p>
<p>​        尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</p>
<p>​        如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</p>
<p>​        如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法（直接用磁盘临时表）得到group by的结果。</p>
<p>​        15、多表关联尽量用join，减少子查询的使用。表的关联字段如果能用主键就用主键，也就是尽可能的使用索引字段。如果关联字段不是索引字段可以根据情况考虑添加索引。</p>
<p>​    索引的优化：<br>​        1、<strong>Join语句的优化</strong><br>​        2、避免索引失效</p>
<p>​            1）如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<p>​            <strong>最左前缀匹配原则：</strong>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>​            2）<strong>不在索引列上做任何操作</strong> (计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描。<br>​            3）存储引擎不能使用索引中范围条件右边的列。如这样的sql: <code>select * from user where username=&#39;123&#39; and age&gt;20 and phone=&#39;1390012345&#39;</code>,其中username, age, phone都有索引，只有username和age会生效，phone的索引没有用到。</p>
<p>​            4）尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))</p>
<pre><code>   如select age from user减少select *
</code></pre>
<p>​            5）mysql在使用不等于(!&#x3D; 或者 &lt;&gt;)的时候无法使用索引会导致全表扫描。</p>
<p>​            6）is null, is not null 也无法使用索引，在实际中尽量不要使用null。</p>
<p>​            7）like 以通配符开头(‘%abc..’)mysql索引失效会变成全表扫描的操作。</p>
<pre><code>   所以最好用右边like &#39;abc%&#39;。如果两边都要用，可以用select age from user where username like &#39;%abc%&#39;,其中age是必须是索引列，才可让索引生效
</code></pre>
<h2 id="如果数据库查询很慢该怎么定位问题"><a href="#如果数据库查询很慢该怎么定位问题" class="headerlink" title="如果数据库查询很慢该怎么定位问题"></a>如果数据库查询很慢该怎么定位问题</h2><p><a href="https://www.cnblogs.com/ibytecoding/p/13859625.html">https://www.cnblogs.com/ibytecoding/p/13859625.html</a></p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210815230704693.png" alt="image-20210815230704693" style="zoom:60%;" />

<h1 id="x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-mysql实例-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D-mysql实例-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1><h2 id="【学生表，老师表，统计每个老师教了多少学生，降序排序】"><a href="#【学生表，老师表，统计每个老师教了多少学生，降序排序】" class="headerlink" title="【学生表，老师表，统计每个老师教了多少学生，降序排序】"></a>【学生表，老师表，统计每个老师教了多少学生，降序排序】</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> teachername,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> teacher</span><br><span class="line"><span class="keyword">on</span> student.teacherid<span class="operator">=</span>teacher.teacherid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student.teacherid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> A <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h2 id="【☆按小时统计每个不同的小时数据出现的个数】sql-的-DATE-FORMATE-函数"><a href="#【☆按小时统计每个不同的小时数据出现的个数】sql-的-DATE-FORMATE-函数" class="headerlink" title="【☆按小时统计每个不同的小时数据出现的个数】sql 的 DATE_FORMATE()函数"></a>【☆按小时统计每个不同的小时数据出现的个数】sql 的 DATE_FORMATE()函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DATE_FORMAT(a_time,<span class="string">&#x27;%Y-%m-%d %H&#x27;</span>) a_hour,<span class="built_in">count</span>(id) hour_count</span><br><span class="line"><span class="keyword">from</span> abc_log</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a_hour;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804104554233.png" alt="image-20210804104554233" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804104627399.png" alt="image-20210804104627399" style="zoom:50%;" />

<h2 id="【sql查询今天温度比昨天高的日期】DATEDIFF函数"><a href="#【sql查询今天温度比昨天高的日期】DATEDIFF函数" class="headerlink" title="【sql查询今天温度比昨天高的日期】DATEDIFF函数"></a>【sql查询今天温度比昨天高的日期】DATEDIFF函数</h2><p>日期之间差一天，即将表Weather定义为两个表A、B。</p>
<p>把A表看到昨日数据，B表看作今日数据。即A表的日期加1天等于B表的日期，B表的温度大于A表温度即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210806013113170.png" alt="image-20210806013113170"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.starttime <span class="keyword">FROM</span> Weather <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Weather <span class="keyword">AS</span> B <span class="keyword">ON</span> A.temperature<span class="operator">&gt;</span>B.temperature <span class="keyword">and</span> DATEDIFF(B.starttime,A.starttime) <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.starttime <span class="keyword">FROM</span> Weather <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Weather <span class="keyword">AS</span> B <span class="keyword">ON</span> A.temperature<span class="operator">&gt;</span>B.temperature <span class="keyword">and</span> DATE_ADD(A.starttime,<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span> ) <span class="operator">=</span> B.starttime</span><br></pre></td></tr></table></figure>

<h2 id="【查询分数-gt-80分的学生名字，查询列表的第10-20条】"><a href="#【查询分数-gt-80分的学生名字，查询列表的第10-20条】" class="headerlink" title="【查询分数&gt;80分的学生名字，查询列表的第10-20条】"></a>【查询分数&gt;80分的学生名字，查询列表的第10-20条】</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from scoretablename</span><br><span class="line">where 成绩&gt;80</span><br><span class="line">limit 9,11</span><br></pre></td></tr></table></figure>

<h2 id="【查找所有分数大于80的学生】"><a href="#【查找所有分数大于80的学生】" class="headerlink" title="【查找所有分数大于80的学生】"></a>【查找所有分数大于80的学生】</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">having</span> <span class="built_in">min</span>(code)<span class="operator">&gt;</span><span class="number">80</span>;</span><br></pre></td></tr></table></figure>



<h2 id="【按字段进行分组group-by】"><a href="#【按字段进行分组group-by】" class="headerlink" title="【按字段进行分组group by】"></a>【按字段进行分组group by】</h2><p>SQL如何查询一张表的所有字段并按其中一个字段进行分组</p>
<p>假设一个表tab有一个id字段、一个Name字段，内容如下</p>
<blockquote>
<p>id  Name<br>3  张三<br>5  李四<br>1  王五<br>1  赵六</p>
</blockquote>
<p>sql 语句<br><strong>select * from tab group by id</strong></p>
<p>这条SQL的结果应该是</p>
<blockquote>
<p>id Name<br>1  王五<br>3  张三<br>5  赵六</p>
</blockquote>
<p>第一个Name显示的是王五 因为sql group by满足条件的有多个时是取第一个的</p>
<p>group by 一般结合合计函数一起使用<br>比如 sql语句<br>select id,count(*) AS total from tab group by id<br>用于统计每个id有多少个<br>结果</p>
<blockquote>
<p>id total<br>1  2<br>3 1<br>5  1</p>
</blockquote>
<p>sql语句中的AS可以省略,一般as 后边是别名；能省略，但是不建议，建议写上as，增加可读性</p>
<h2 id="【给定id-name-score，统计每一个分数的人数】"><a href="#【给定id-name-score，统计每一个分数的人数】" class="headerlink" title="【给定id,name,score，统计每一个分数的人数】"></a>【给定id,name,score，统计每一个分数的人数】</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> score,<span class="built_in">count</span>(id)</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> score;</span><br></pre></td></tr></table></figure>

<h2 id="【数据库查询时间最新-order-by降序取desc-的前十行-limit-】"><a href="#【数据库查询时间最新-order-by降序取desc-的前十行-limit-】" class="headerlink" title="【数据库查询时间最新(order by降序取desc)的前十行(limit)】"></a>【数据库查询时间最新(order by降序取desc)的前十行(limit)】</h2><p>MYSQL,根据日期查询最新10条数据</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721012951842.png" alt="image-20210721012951842" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013012784.png" alt="image-20210721013012784" style="zoom:50%;" />

<blockquote>
<p>ORDER BY 关键字用于对结果集进行排序。</p>
<p>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
<p> <strong>limit</strong> 子句用于限制 SELECT 语句中查询的数据的数量。</p>
</blockquote>
<p>查询数据库中最近的十条数据，并按时间升序进行排列</p>
<ul>
<li>最近的十条数据：取最近的数据，降序排列，取十条</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013202198.png" alt="image-20210721013202198" style="zoom:50%;" />

<ul>
<li>但是要求按时间升序进行排列：<ul>
<li>即：将查询的结果作为一个中间表，然后再次进行查询</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013234284.png" alt="image-20210721013234284" style="zoom:50%;" />



<h2 id="【组合两个表】join连接-left-join解释一下"><a href="#【组合两个表】join连接-left-join解释一下" class="headerlink" title="【组合两个表】join连接:left join解释一下"></a>【组合两个表】join连接:left join解释一下</h2><p>LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。对于这样的行，右表选择列置为null</p>
<p><strong>注释：</strong>在某些数据库中， LEFT JOIN 称为 LEFT OUTER JOIN。</p>
<p><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></p>
<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210721013559792.png" alt="image-20210721013559792" style="zoom:67%;" />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address</span><br><span class="line"><span class="keyword">on</span> Person.PersonId <span class="operator">=</span> Address.PersonId</span><br></pre></td></tr></table></figure>

<h2 id="【查询student表中两门科成绩90分以上的学生学号】"><a href="#【查询student表中两门科成绩90分以上的学生学号】" class="headerlink" title="【查询student表中两门科成绩90分以上的学生学号】"></a>【查询student表中两门科成绩90分以上的学生学号】</h2><p>查询student表中两门科成绩90分以上的学生学号的SQL语句？<br>（学号，姓名，课程号，成绩）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 学号</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> 成绩<span class="operator">&gt;</span><span class="number">90</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="【☆查出表中学生成绩最好的学生信息】"><a href="#【☆查出表中学生成绩最好的学生信息】" class="headerlink" title="【☆查出表中学生成绩最好的学生信息】"></a>【☆查出表中学生成绩最好的学生信息】</h2><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210804100831418.png" alt="image-20210804100831418" style="zoom:67%;" />

<h2 id="【查找or删除重复的电子邮箱】"><a href="#【查找or删除重复的电子邮箱】" class="headerlink" title="【查找or删除重复的电子邮箱】"></a>【查找or删除重复的电子邮箱】</h2><p><a href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210722102030346.png" alt="image-20210722102030346" style="zoom:50%;" />

<p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 </span><br><span class="line"><span class="keyword">FROM</span> Person p1,Person p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210722102350174.png" alt="image-20210722102350174" style="zoom:50%;" />



<h2 id="【mysql语句：查重复城市信息…-返回表中有两名以上学员的城市的所有学员信息】"><a href="#【mysql语句：查重复城市信息…-返回表中有两名以上学员的城市的所有学员信息】" class="headerlink" title="【mysql语句：查重复城市信息….返回表中有两名以上学员的城市的所有学员信息】"></a>【mysql语句：查重复城市信息….返回表中有两名以上学员的城市的所有学员信息】</h2><p> ID Name <strong>City</strong> Address<br>1 包彦钦 北京 北京市东四北大街520号<br>2 王洪涛 北京 北京市西单北大街151号<br>3 张立涛 大连 大连市西岗区新开路69号<br>4 佘高峰 济南 山东省济南市泺文路50号<br>5 徐俊 上海 上海市静安区南阳路46号<br>6 张忠飞 上海 上海市肇嘉浜路414号<br>7 徐俊 上海 上海市乳山路150号<br>返回表中有两名以上学员的城市的所有学员信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> City</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>




<h2 id="sql优化——count-1-、count-与count-列名-的区别"><a href="#sql优化——count-1-、count-与count-列名-的区别" class="headerlink" title="sql优化——count(1)、count(*)与count(列名)的区别"></a>sql优化——count(1)、count(*)与count(列名)的区别</h2><p><a href="https://blog.csdn.net/wx1528159409/article/details/95643499">https://blog.csdn.net/wx1528159409/article/details/95643499</a></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>面试QA整理(9)——测试开发相关知识</title>
    <url>/2022/02/09/QA_test/</url>
    <content><![CDATA[<p>Welcome to xpt’s blog! 2021年准备秋招期间整理的一些笔记，分享给大家！</p>
<p>文档分享的初衷是给师弟师妹们作为参考，主要是适合想去<strong>大厂+测试开发岗</strong>的朋友们。<br>建议大家自己整理文档，把我的文档作为参考，有些东西自己整理，自己去写出来，才是最适合你自己的！<br>文章还未精细整理，如存在错误之处，可以<strong>邮件or微信</strong>反馈给我呀，感激不尽！</p>
<p>想进大厂，要抓住提前批免笔试的机会！（例如京东、字节、百度等报名时间一般为七月，面试时间为报名后的一周内，面试一般为3轮，面试相关经验后续我会单独再写blog分享^_^，也欢迎大家来跟我talk，一定知无不言。）</p>
<p>本人情况：普通211、研究生、有京东、百度、以及字节提前批测开岗offer。7月初开始准备，准备太迟，一边准备一边投简历+面试。</p>
<ul>
<li>投递简历时间：京东（7.14），字节（7.30），百度（7.30）</li>
<li>三轮面试时间：京东（7.21-7.22-7.26），字节（8.4-8.6-8.9），百度（8.9-8.12-8.16）</li>
<li>意向书时间：京东（8.12），字节（8.16），百度（9.9）</li>
</ul>
<p>京东提前批开始很早，我投的时候已经是第二批。经过京东几轮面试，熟悉了面试流程，大概掌握了测开岗会问些什么问题。<br>字节和百度提前批我是在ddl前一天投递，其实已经算很迟了，hc不多了。<br><strong>投递要趁早，很多岗位有固定hc。</strong><br><strong>多拿offer，才有谈薪资的底气。</strong></p>
<p>我面试的岗位有以下：<br>1、测试开发岗（京东、百度、以及字节提前批）<br>2、银行java开发岗（所以我会整理一点java，银行问的都很简单，所以我这里对java的整理比较少）</p>
<p>整理的内容均来源于历年网络上分享的面经（主要来源于牛客），以及我面试时被问过的问题，list如下：<br>(1)——<a href="https://xpt.hatake18.top/2022/02/01/QA_network/">计算机网络</a><br>(2)——<a href="https://xpt.hatake18.top/2022/02/02/QA_os/">操作系统</a><br>(3)——<a href="https://xpt.hatake18.top/2022/02/03/QA_database/">数据库</a><br>(4)——<a href="https://xpt.hatake18.top/2022/02/04/QA_datastructure/">数据结构</a><br>(5)——<a href="https://xpt.hatake18.top/2022/02/05/QA_python/">python</a><br>(6)——<a href="https://xpt.hatake18.top/2022/02/06/QA_java/">java</a><br>(7)——<a href="https://xpt.hatake18.top/2022/02/07/QA_linux/">linux</a><br>(8)——<a href="https://xpt.hatake18.top/2022/02/08/QA_code/">常考编程题</a><br>(9)——<a href="https://xpt.hatake18.top/2022/02/09/QA_test/">测试开发相关知识</a></p>
<h1 id="面试QA整理-9-——测试开发相关知识"><a href="#面试QA整理-9-——测试开发相关知识" class="headerlink" title="面试QA整理(9)——测试开发相关知识"></a>面试QA整理(9)——测试开发相关知识</h1><h2 id="测试流程—-软件生命周期-（六个阶段-计划-x2F-需求-x2F-设计-x2F-编码-x2F-测试-x2F-运行与维护"><a href="#测试流程—-软件生命周期-（六个阶段-计划-x2F-需求-x2F-设计-x2F-编码-x2F-测试-x2F-运行与维护" class="headerlink" title="测试流程—-软件生命周期 （六个阶段:计划&#x2F;需求&#x2F;设计&#x2F;编码&#x2F;测试&#x2F;运行与维护)"></a>测试流程—-软件生命周期 （六个阶段:计划&#x2F;需求&#x2F;设计&#x2F;编码&#x2F;测试&#x2F;运行与维护)</h2><p><strong>软件生命周期的六个阶段：</strong></p>
<p><strong>计划阶段（planning）-〉需求分析（requirement）-〉软件设计阶段（design）-〉编码（coding）-&gt;测试（testing）-&gt;运行与维护（running maintrnacne）</strong>（集成-实施-交付）</p>
<p><strong>测试里面还可以细分：单元测试、集成测试、系统测试、验收测试(Alpha、Beta)、回归测试</strong></p>
<p>一、问题定义及规划阶段<br>主要确定软件的开发目的及其<strong>可行性</strong>，制定开发计划</p>
<p>此轮是软件开发人员和需求方之间的探讨，以此<strong>确认软件开发目标和可行性</strong>。</p>
<p>二、需求分析&#x2F;评审阶段<br>分析来源（原型图&#x2F;软件需求说明书）、参与人员（主持–产品经理，其他参与、研发、设计、测试）、关注一个问题–<strong>测试参与这个需求分析的目的是什么？（知己知彼、方便提出疑问）</strong></p>
<p>在确定软件开发可行的情况下，将<strong>对软件需要实现的每个功能进行详细分析</strong>。</p>
<p>需求分析阶段是非常重要的阶段。这个阶段做得很好，将为整个软件开发项目的成功奠定良好的基础。</p>
<p>三、软件设计阶段（属性：属于开发的工作）</p>
<p>在此阶段，将根据需求分析的结果来设计整个软件系统，例如系统框架设计，数据库设计等。软件设计一般分为总体设计和详细设计。</p>
<p>总体设计：总体架构     、、、概要设计（数据库 表 等框架性的东西）</p>
<p>详细设计(LLD)：每个模块的设计、、、、、、详细设计（伪代码级别）</p>
<p>四、软件编码阶段<br>开发人员任务、程序员编码</p>
<p>五、软件测试阶段<br>测试工程师的任务或开发的任务</p>
<p>开发：单元测试、<br>开发or测试：集成测试—接口测试<br>测试人员：系统测试、<br>客户or产品经理：验收测试—Alpha测试、Beta测试</p>
<p>六、软件运行维护阶段<br>版本、产品上线（版本的升级改进）BUG的修复</p>
<h2 id="单元测试、集成测试、系统测试、验收测试-Alpha、Beta-、回归测试"><a href="#单元测试、集成测试、系统测试、验收测试-Alpha、Beta-、回归测试" class="headerlink" title="单元测试、集成测试、系统测试、验收测试(Alpha、Beta)、回归测试"></a>单元测试、集成测试、系统测试、验收测试(Alpha、Beta)、回归测试</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/edeb39cdb48346f780b2b8cc99e48059">https://www.nowcoder.com/questionTerminal/edeb39cdb48346f780b2b8cc99e48059</a><br>来源：牛客网</p>
<h3 id="请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"><a href="#请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试" class="headerlink" title="请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试"></a><strong>请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试</strong></h3><p><strong>单元测试</strong>：单元测试就是最初的白盒测试，测试编码是否符合设计要求。软件中最小的测试单元，比如java中的一个方法。相关单元测试放在一起就是一个模块。 </p>
<p><strong>集成测试</strong>：集成测试就是接口测试，对接口是否能够实现进行测试，对接口实现后的结果进行测试。通过测<strong>试发现与模块接口有关的问题</strong>。在单元测试的基础上将所有模块按照要求设计组装。<strong>测试不同模块之间是否按照预期工作，比如不同模块之间的数据传输。</strong></p>
<p><strong>系统测试</strong>：系统测试就是对可视化图形界面测试。对整个系统功能进行测。是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。</p>
<p><strong>验收测试</strong>：验收测试就是模拟客户进行测试。确保软件各部分功能正常运行。确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。</p>
<p><strong>回归测试</strong>：在缺陷修复之后的检验测试，回归测试，是软件维护阶段对软件修改后进行的测试，指<strong>修改了旧代码后</strong>，重新进行测试以确认<strong>修改没有引入新的错误</strong>或导致其他代码产生错误</p>
<p><a href="https://blog.csdn.net/qq_42434318/article/details/109099271">https://blog.csdn.net/qq_42434318/article/details/109099271</a></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>完成最小的<strong>软件设计单元（模块）</strong>的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是<strong>白盒</strong>的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>通过测<strong>试发现与模块接口有关的问题</strong>。目标是把通过了单元测试的模块拿来，构造一个在设计中所述的程序结构，应当避免一次性的集成（除非软件规模很小），而<strong>采用增量集成</strong>。</p>
<p><strong>自顶向下集成</strong>：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。</p>
<p><strong>自底向上集成</strong>：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。</p>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。</p>
<h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，<strong>验证以前发现和修复的错误是否在新软件版本上再次出现</strong>。根据修复好了的缺陷再重新进行测试。<strong>回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现</strong>。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。</p>
<p>回归测试，是软件维护阶段对软件修改后进行的测试，指<strong>修改了旧代码后</strong>，重新进行测试以确认<strong>修改没有引入新的错误</strong>或导致其他代码产生错误</p>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。</p>
<h4 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h4><p>是由用户在开发者的场所来进行的，在一个受控的环境中进行。</p>
<p>例如游戏的删档内测，Alpha测试不是面对所有的用户，而是针对公司内部员工进行游戏试玩，来检测是否存在一些bug，然后反馈错误给开发去修复。</p>
<h4 id="Beta测试"><a href="#Beta测试" class="headerlink" title="Beta测试"></a>Beta测试</h4><p>它不是受控活动，因为它发生在用户身边。在将软件交付给客户之前，它视为最终测试。发布用于beta测试的软件称为测试版软件。</p>
<p>由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。</p>
<p>例如游戏的不删档公测，通过Alpha内测之后，会进行不删除用户资料的公共测试，让大量的用户去进行体验，试玩。许多用户可以使用它，并传达他们对应用程序的反馈。提交给测试，测试再提交给开发人员去修复。</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720121118998.png" alt="image-20210720121118998" style="zoom:50%;" />

<p><a href="https://www.bilibili.com/video/BV1Tt411c78F?p=3">https://www.bilibili.com/video/BV1Tt411c78F?p=3</a> 7:03</p>
<h2 id="黑盒测试和白盒测试"><a href="#黑盒测试和白盒测试" class="headerlink" title="黑盒测试和白盒测试"></a>黑盒测试和白盒测试</h2><p>软件测试方法一般分为两种：白盒测试与黑盒测试。</p>
<p>其中，<strong>白盒测试</strong>又称为<strong>结构测试、逻辑驱动测试或基于程序本身的测试</strong>，着重于程序的内部结构及算法，通常不关心功能与性能指标。</p>
<p><strong>黑盒测试</strong>又被称为<strong>功能测试、数据驱动测试或基于规格说明的测试</strong>，实际上是站在最终用户的立场上，检验输入输出信息及系统性能指标是否符合规格说明书中有关功能需求及性能需求的规定。</p>
<hr>
<p>黑盒测试方法，不考虑程序内部结构和内部特性，而是从用户观点出发，针对程序接口和用户界面进行测试，根据产品应该实现的实际功能和已经定义好的产品规格，来验证产品所应该具有的功能是否实现，是否满足用户的要求。</p>
<p>所以，黑盒测试方法技术相对要求低，方法简单有效，可以整体测试系统的行为，可以从头到尾（end-to-end）进行数据完整性测试。</p>
<ul>
<li><p>黑盒测试方法适合系统的<strong>功能测试</strong>、易用性测试，也适合和用户共同进行<strong>验收测试、软件确认测试</strong>。</p>
</li>
<li><p>黑盒测试方法不适合<del>单元测试、集成测试</del>，而且测试结果的覆盖度不容易度量，其测试的潜在风险比较高。</p>
</li>
</ul>
<hr>
<p>白盒测试方法，已知产品的内部工作过程，针对性很强，可以对程序每一行语句、每一个条件或分支进行测试，测试效率比较高，而且可以清楚已测试的覆盖程度。如果时间足够多，可以保证所有的语句和条件得到测试，测试的覆盖程度达到很高。</p>
<ul>
<li>白盒测试方法所以适合<strong>单元测试、集成测试</strong>，</li>
<li>而不适合系统测试。白盒测试方法准备的时间很长，如果要覆盖全部程序语句、分支的测试，一般花费比编程更长的时间。</li>
</ul>
<p>白盒测试方法所要求的技术也较高，相应的测试成本要大。对于一个应用的系统，程序的路径数可能是一个天文数字，即使借助一些测试工具，白盒测试法也不可能进行穷举测试，企图遍历所有的路径往往是做不到的。即使，穷举路径测试，也不能查出程序违反了设计规范的地方，不能发现程序中已实现但不是用户所需要的功能，可能发现不了一些与数据相关的错误或用户操作行为的缺陷。所以白盒测试方法也存在一定的局限性。</p>
<p><strong>常用的黑盒测试方法有：</strong><br><strong>等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。</strong></p>
<p>等价类划分法，主要解决穷举的问题：</p>
<ul>
<li>等价类划分法将测试数据中具有某种共同特征的数据集合，进行划分。</li>
<li>有效等价类:满足需求的数据集合<br>无效等价类:不满足需求的数据集合</li>
</ul>
<p>边界值分析法</p>
<ul>
<li>选取正好等于、刚好大于、刚好小于边界的值作为测试数据</li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720170029843.png" alt="image-20210720170029843" style="zoom:50%;" /></li>
</ul>
<p>判定表</p>
<ul>
<li>是一种以表格形式表达<strong>多条件逻辑判断</strong>的工具</li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720190353979.png" alt="image-20210720190353979" style="zoom:50%;" /></li>
<li>判定表中贯穿条件项和动作项的一列就是一条规则<br>假设有n个条件，每个条件的取值有两个(0,1)，全组合有2的n次方种规则</li>
</ul>
<p>场景法</p>
<ul>
<li>场景法也可以叫流程图法，是用流程图描述用户的使用场景，然后通过<strong>覆盖流程路径</strong>来设计测试用例。</li>
<li>意义:<br>➢用户使用角度:用户平时使用的不是单个功能，而是多个功能组合起来进行使用<br>➢测试人员角 度:平时测试的都是单个功能点进行测试，容易忽略多个功能的组合测试</li>
</ul>
<hr>
<p>白盒测试主要是检查程序内部的逻辑结构，也就是对所有逻辑路径进行测试，是一种穷举路径的测试方法。</p>
<p><strong>白盒测试：逻辑覆盖+路径覆盖</strong></p>
<p><strong>白盒测试常用方法：</strong></p>
<p>1、逻辑覆盖测试：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖、路径覆盖</p>
<blockquote>
<p>六种覆盖标准发现错误的能力呈由弱到强的变化： 1.语句覆盖每条语句至少执行一次。 2.判定覆盖每个判定的每个分支至少执行一次。 3.条件覆盖每个判定的每个条件应取到各种可能的值。 4.判定&#x2F;条件覆盖同时满足判定覆盖条件覆盖。 5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。 6.路径覆盖使程序中每一条可能的路径至少执行一次。</p>
<p>所以理论上来讲<strong>路径覆盖是最彻底的测试用例覆盖</strong>，但实际上很多时候路径覆盖的可操作性不强。</p>
</blockquote>
<p>2、基本路径覆盖测试：选择足够的测试用例，使得运行这些测试用例时，被测程序的每条可能执行的路径都至少经过一次。</p>
<p>数据流测试：</p>
<p>循环测试：简单循环、嵌套循环、串接循环和非结构循环。</p>
<h3 id="黑盒白盒适合运用于什么场景"><a href="#黑盒白盒适合运用于什么场景" class="headerlink" title="黑盒白盒适合运用于什么场景"></a>黑盒白盒适合运用于什么场景</h3><h3 id="黑盒测试与白盒测试优缺点"><a href="#黑盒测试与白盒测试优缺点" class="headerlink" title="黑盒测试与白盒测试优缺点"></a>黑盒测试与白盒测试优缺点</h3><p>黑盒测试的优点有：<br>  比较简单，不需要了解程序内部的代码及实现；<br>  与软件的内部实现无关；<br>  从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；<br>  基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；<br>  在做软件自动化测试时较为方便。</p>
<p>黑盒测试的缺点有：<br>  不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；<br>  自动化测试的复用性较低。</p>
<p>白盒测试的优点有：<br>  帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。</p>
<p>白盒测试的缺点有：<br>  程序运行会有很多不同的路径，不可能测试所有的运行路径；<br>  测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；<br>  系统庞大时，测试开销会非常大。</p>
<h2 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h2><p><strong>冒烟测试： 确保开发人员修复了 bug 后，这个 bug 的修复没有影响到其他功能模块。</strong></p>
<p><strong>冒烟测试是否通过决定了下一轮系统测试是否可以执行。</strong></p>
<p>冒烟测试的重要性，不作用于本身，而是决定了下一轮测试是否能达到理想的效果</p>
<p>与系统测试不同之处在于冒烟测试是一种<strong>不要求覆盖面有多广的测试，但是要保证被测对象的主要部分功能要得到测试</strong>，不要求每一个功能都面面俱到，但是要保证所有被修改过以及与修改相关的功能、主要的功能都是可用的，<strong>即证明这个版本可进行系统测试</strong></p>
<p><strong>冒烟测试，是版本验证测试</strong>，主要<strong>确认新的版本是否存在致命性bug</strong>，功能可以正常运行（不会出现跑不通的状况），不会影响下一轮测试的进行，如果上述都符合那么这个版本就可以进行下一轮测试。</p>
<p><a href="https://zhuanlan.zhihu.com/p/103637689">https://zhuanlan.zhihu.com/p/103637689</a></p>
<p>与回归测试不同，回归测试，是软件维护阶段对软件修改后进行的测试，指<strong>修改了旧代码后</strong>，重新进行测试以确认<strong>修改没有引入新的错误</strong>或导致其他代码产生错误</p>
<hr>
<ul>
<li><strong>1.什么是测试用例</strong></li>
<li>用例:用户使用的案例<br>测试用例:执行测试时用户案例<br>英文: Test Case</li>
<li><strong>2.为什么 需要编写测试用例</strong></li>
<li>目的:保证测试点的正确执行</li>
<li><strong>3.测试用例编写格式</strong></li>
<li>说明:用例编写格式一般由八大要素组成。</li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720131430892.png" alt="image-20210720131430892"></li>
<li><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720132312175.png" alt="image-20210720132312175" style="zoom:25%;" /></li>
<li><strong>4.编写示例</strong></li>
</ul>
<p>微信登录测试点:<br>1、登录成功<br>2、密码错误,登录失败</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720133450128.png" alt="image-20210720133450128"></p>
<h2 id="☆☆☆测试用例☆☆☆"><a href="#☆☆☆测试用例☆☆☆" class="headerlink" title="☆☆☆测试用例☆☆☆"></a>☆☆☆测试用例☆☆☆</h2><h2 id="这几个方面看（功能、界面、性能、安全性、兼容性"><a href="#这几个方面看（功能、界面、性能、安全性、兼容性" class="headerlink" title="这几个方面看（功能、界面、性能、安全性、兼容性"></a>这几个方面看（功能、界面、性能、安全性、兼容性</h2><p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210801095511694.png" alt="image-20210801095511694"> </p>
<h3 id="x3D-x3D-x3D-x3D-x3D-具体的例子，要说详细。在测试内容明确的基础上，再从测试手段上去进行考量，才是比较全面的思路-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-具体的例子，要说详细。在测试内容明确的基础上，再从测试手段上去进行考量，才是比较全面的思路-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;具体的例子，要说详细。在测试内容明确的基础上，再从测试手段上去进行考量，才是比较全面的思路&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;具体的例子，要说详细。在测试内容明确的基础上，再从测试手段上去进行考量，才是比较全面的思路&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h3><p>But，还没有结束。如果更近一步，可以从测试手段上进行进一步的思考。<strong>你是希望测试一个矿泉水瓶呢还是一百万个？</strong>测试一个的话手动就行了。如果是一百万个？只能借助机器，用自动化的方式来实现了。再比如稳定性测试中，<strong>瓶盖是需要开启十次还是一万次</strong>？十次手动做做还可以接受，一万次扭下来估计手也要废掉了。所以必须考虑自动化。诸如此类</p>
<h3 id="【飞书】视频会议测试用例"><a href="#【飞书】视频会议测试用例" class="headerlink" title="【飞书】视频会议测试用例"></a>【飞书】视频会议测试用例</h3><p>功能测试<br>界面测试<br>性能测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong></p>
<ol>
<li><p>发起新会议，按钮是否可用，弹出的界面是否正确</p>
</li>
<li><p><strong>是否支持设置会议主题</strong>，验证每种合法的输入，结果是否正确，<strong>各种正常输入的字符，混合输入，排列组合。</strong><br> 是否可以输入数字，英文，中文，特殊字符等<br> 是否可以<strong>混合输入</strong>数字，英文，中文，特殊字符等<br><strong>边界值验证</strong>：不输入字，输入字，最多输入多少字，在允许的字符串长度<strong>内外</strong>，系统如何处理<br>是否只能输入允许的字符串长度<br>超长字符串粘贴输入，系统<strong>是否会截取允许的长度</strong>来检验结果</p>
</li>
</ol>
<p>  输入框是否支持<strong>编辑、复制、粘贴、剪切、</strong>等操作</p>
<ol start="2">
<li>麦克风设置，是否支持关闭、开启麦克风；是否支持切换扬声器选项；是否支持测试扬声器和麦克风可用性</li>
<li>摄像头设置，是否支持关闭、开启摄像头；是否支持设置虚拟背景，虚拟形象；</li>
<li>如果使用手机应用，<strong>使用移动网络</strong>进行视频通话是否会有提示：使用流量提示</li>
<li>开始会议，音视频是否连接成功</li>
<li>清晰度，流畅度，<strong>声音和画面是否正常</strong>，是否同步</li>
<li><strong>是否支持录制，录制之后是否支持飞书妙记的功能</strong></li>
<li>会议分享邀请功能是否可用</li>
<li>会议权限设置，根据不同的权限，测试有效和无效用例</li>
<li>屏幕共享功能，，，是否所有进程都能被检测到，飞书云文件文档是否也可分享</li>
<li>字幕功能是否可用，字幕设置语言，可进行实时翻译</li>
<li>多人视频会议<strong>可容纳的人数上限</strong></li>
<li><strong>视频会议中，</strong>网络质量差是否有提示信息</li>
<li>视频会议挂断功能<strong>是否正常（全员结束会议</strong></li>
<li>会议记录详情</li>
<li>加入会议功能是否可用，会议ID错误是否有提示</li>
<li>会议ID输入框，是否只支持输入数字，其他特殊字符是否可输入</li>
<li>在<strong>断网的情况</strong>下视频会议,<strong>检查是否有提示信息</strong></li>
<li>在<strong>弱网的情况</strong>下视频会议，网络延迟，卡顿，服务器响应, 检查提示信息</li>
</ol>
<p>异常：<br><strong>无网络</strong>是否可以发起会议，是否提示：当前网络不可用，请检查网络设置<br>无网络是否可以结束会议（通话中断<br><strong>网络质量不好</strong>的情况下发起、接收会议<br>会议中<strong>有新的</strong>会议邀请<br>会议中手机&#x2F;电脑<strong>没电、断网、故障、系统更新、应用app切换</strong>（中断测试<br>会议中<strong>来电话，短信</strong>（中断测试<br>会议时电脑&#x2F;<strong>手机重启、手机卡死</strong>（中断测试<br>会议中<strong>系统版本升级</strong>（中断测试</p>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>双方视频框大小布局合理</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>视频会议接听后的<strong>响应速度</strong></li>
<li><strong>高并发场景下，多人同时进入视频会议的响应情况</strong></li>
<li>压力测试——<strong>长时间视频会议（如12小时）是否能保持正常</strong>（CPU，内存消耗，流量消耗）等；</li>
<li>稳定性测试——<strong>频繁</strong>进行视频会议；</li>
<li><strong>不同网络测试：</strong>2G,3G,4G,5G,wifi和热点，不同运营商测试；不同网速测试</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li><strong>脚本的禁用，防止XSS攻击，填入js代码是否异常（alert(1111)）</strong></li>
<li><strong>SQL的注入，检索SQL SELECT语句等</strong>（’ or 1&#x3D;1# ）如单引号、%等等，造成查询SQL拼接出的语句产生漏洞</li>
<li>文字聊天中，敏感内容是禁止的，对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制</li>
<li>是否有安全设计控制</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>（例如ios12,13,14，安卓）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>多浏览器</strong>chrome、IE、火狐、360等</li>
<li><strong>不同的飞书版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="视频直播测试用例（直播或播放"><a href="#视频直播测试用例（直播或播放" class="headerlink" title="视频直播测试用例（直播或播放"></a>视频直播测试用例（直播或播放</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试<br><strong>一、功能测试</strong><br><strong>使用移动网络</strong>是否会有提示：移动网络下将产生手机流量<br>进入直播中，视频<strong>能否链接成功</strong><br>进入直播中，<strong>声音和画面是否正常，是否同步</strong><br>进入直播中，<strong>插拔耳机</strong>是否能正常直播<br>直播的模式：横屏，竖屏，或者来回切换。<br>直播中，<strong>网络质量差</strong>是否有提示信息</p>
<p>直播间<strong>可容纳的人数上限</strong></p>
<p>播放的UI键位：返回，关闭，播放&#x2F;暂停，最大化&#x2F;最小化，音量的调节。<br>是否可以<strong>点击返回键、Home键</strong><br>是否可以<strong>与其他应用切换</strong><br><strong>挂断功能</strong>是否正常</p>
<p>直播播放的机制：首次进入正常播放 ，暂停播放，继续播放，快进播放，倍速播放，连续播放，拖拽播放等等情况<br>直播延迟情况：对于直播，延迟是否在需求内<br>直播中的互动：互动，评价等是否正常<br>播放缓存机制：如支持缓存下载，则校验下载，下载完成播放，下载暂停，下载继续，下载删除再下载等情况</p>
<p>直播结束，直播者<strong>结束直播</strong>，接收者是否也结束<br>直播详情页面，<strong>是否有直播显示记录</strong></p>
<p>播放的网络：WIFI、2G、3G、4G网络环境下的播放和加载情况。断网之后能否继续恢复播放</p>
<p>异常：<br><strong>无网络</strong>是否可以发起直播，是否提示：当前网络不可用，请检查网络设置<br>无网络是否可以结束视直播（直播中断<br><strong>网络质量不好</strong>的情况下发起、接收直播<br>直播中手机<strong>没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>直播中<strong>来电话，短信</strong>（中断测试<br>直播<strong>手机重启、手机卡死</strong>（中断测试<br>直播<strong>直播软件版本升级</strong>（中断测试<br>异常情况：播放中多个APP前后切换，播放是否正常<br>异常情况：播放中被外界打断，如来电，短信，按home键等</p>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>双方视频框大小布局合理</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>发起直播的<strong>响应速度</strong>，打开直播的响应速度</li>
<li><strong>高并发场景下用户进入直播的响应时间测试。</strong><br>模拟大量用户同时进入直播，检查一定压力下能否正常跳转。</li>
<li>负载测试：看极限能承载多大的用户量同时正常使用</li>
<li>弱网测试，<strong>弱网时直播的响应时间</strong></li>
<li>压力测试——<strong>长时间直播（如12小时）是否能保持正常</strong>（CPU，内存消耗，流量消耗）等；</li>
<li>稳定性测试——<strong>频繁</strong>进行直播；</li>
<li><strong>不同网络测试：</strong>2G,3G,4G,5G,wifi和热点，不同运营商测试；不同网速测试</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li><strong>脚本的禁用，防止XSS攻击，填入js代码是否异常（alert(1111)）</strong></li>
<li><strong>SQL的注入，检索SQL SELECT语句等</strong>（’ or 1&#x3D;1# ）如单引号、%等等，造成查询SQL拼接出的语句产生漏洞</li>
<li>直播中，敏感内容是禁止的，对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制</li>
<li>是否有安全设计控制</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>（例如ios12,13,14，安卓）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>多浏览器</strong>chrome、IE、火狐、360等</li>
<li><strong>不同的直播软件版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="登录测试用例（例如微信等APP，网站登录"><a href="#登录测试用例（例如微信等APP，网站登录" class="headerlink" title="登录测试用例（例如微信等APP，网站登录"></a>登录测试用例（例如微信等APP，网站登录</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong></p>
<ol>
<li>输入已注册<strong>正确</strong>的用户名和密码，点击提交按钮，验证是否能正确登录。<strong>检查登录成功后数据库是否写入了session信息</strong></li>
<li>输入<strong>未注册</strong>用户名或者<strong>错误</strong>的密码，验证登录会<strong>失败</strong>，并且<strong>提示用户或密码错误信息</strong>。检查登录失败时数据库生成的session不会记录用户信息</li>
<li>什么都不输入，点击提交按钮，检查提示信息。（微信是什么都不输，登录按钮为不可用灰色）</li>
<li><strong>未注册用户通过手机号验证码第一次登录成功时，是否提示修改密码</strong></li>
<li><strong>通过手机号+验证码方式登录，在用户授权的情况下，检查能不能自动获取到短信验证码</strong></li>
<li>登录成功后<strong>能否跳转到正确的页面</strong></li>
<li>检查<strong>能否选择不同登录方式</strong>进行登录，如使用手机号登录、使用微信号登录或扫码登录。</li>
<li>扫码登录，<strong>检查二维码是否可以定时失效刷新</strong></li>
<li>检查有没有<strong>记住用户名的功能</strong></li>
<li><strong>登陆失败后，不能记录密码</strong>的功能</li>
<li><strong>密码是否非明文显示</strong>，使用星号圆点等符号代替。</li>
<li>有验证码时，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色、刷新或换一个按钮是否好用</li>
<li>登录页面中的注册、忘记密码，登出用另一帐号登陆<strong>等功能的链接是否正确</strong></li>
<li>输入密码的时候，大写键盘开启的时候要有提示信息</li>
<li>在<strong>断网的情况</strong>下能否正常登录**,检查是否有提示信息**</li>
<li>在<strong>弱网的情况</strong>下能否正常登录，网络延迟服务器响应, <strong>检查提示信息</strong></li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>布局是否合理，textbox（文本框控件）和按钮是否整齐。</li>
<li>textbox和按钮的长度，高度是否符合要求。</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
<li>界面中的文字简洁易懂，没有错别字。</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li><strong>打开登录页面，需要的时间</strong>是否在<strong>需求</strong>要求的时间内。</li>
<li><strong>不同网速下搜索时的响应时间</strong>3g,4g,5g,WIFI、热点；不同运营商网络</li>
<li><strong>单用户登录的响应时间。</strong><br>​    输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。</li>
<li><strong>高并发场景下用户登录的响应时间测试。</strong><br>​    模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>登录成功后生成的<strong>Cookie，是否是http-only</strong> (否则容易被脚本盗取)。</li>
<li>用户名和密码<strong>是否通过加密的方式，发送给Web服务器</strong>。</li>
<li>用户名和密码的输入框，应该<strong>屏蔽SQL注入攻击</strong>。</li>
<li>用户名和密码的的输入框，应该<strong>禁止输入脚本 （防止XSS攻击）</strong>。</li>
<li><strong>防止暴力破解</strong>，检测是否有错误<strong>登陆的次数限制</strong>。</li>
<li>是否支持<strong>多用户在同一机器上登录</strong>。</li>
<li><strong>同一用户能否在多台机器上登录</strong>。</li>
<li><strong>密码输入框</strong>是否<strong>是不支持复制粘贴的</strong></li>
<li><strong>异地登录校验、更换设备校验</strong></li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同移动平台</strong>或PC环境下下能否显示正常且功能正常（平台不同</li>
<li><strong>同种平台</strong>下<strong>不同微信版本</strong>下能否显示正常且功能正常。（微信版本</li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本。</strong>（本地化测试）【就比如设置手机语言环境为英文&#x2F;中文】</li>
</ol>
<h3 id="百度搜索框测试用例"><a href="#百度搜索框测试用例" class="headerlink" title="百度搜索框测试用例"></a>百度搜索框测试用例</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试<br><strong>特性</strong></p>
<p><strong>一、功能测试</strong></p>
<ol>
<li>验证每种合法的输入，结果是否正确，<strong>各种正常输入的字符，混合输入，排列组合。</strong></li>
<li>是否可以输入数字，英文，中文等</li>
<li>是否可以<strong>混合输入</strong>数字，英文，中文等</li>
<li><strong>分词功能</strong>，在输入一些毫无关联的文字时，是否针对其中某一个有实际的关键词进行搜索</li>
<li>搜索内容与搜索结果的<strong>匹配程度</strong></li>
<li>点击搜索，<strong>是否正常显示搜索界面</strong></li>
<li><strong>搜索内容为空</strong>，系统如何处理（为空测试</li>
<li>搜索内容为空格，系统如何处理</li>
<li><strong>边界值验证</strong>：不输入字，输入字，最多输入多少字，在允许的字符串长度<strong>内外</strong>，系统如何处理</li>
<li>是否只能输入允许的字符串长度</li>
<li>超长字符串粘贴输入，系统<strong>是否会截取允许的长度</strong>来检验结果</li>
<li>在系统允许的合法的字符串长度后，<strong>加空格来验证检索结果是否变化</strong></li>
<li>多个关键字中间加入空格，逗号，验证系统的结果是否正确</li>
<li>输入<strong>拼音</strong>能不能进行检索</li>
<li>输入<strong>特殊字符</strong>、转义字符等是否可以搜索</li>
<li>是否支持<strong>语音搜索</strong>，语音搜索按钮是否可用，语音搜索的内容是否匹配</li>
<li>是否支持<strong>图片搜索</strong>，图片搜索按钮是否可用，进行图片搜索时是否可以选择拍照或从相册中选取图片进行搜索</li>
<li>如果从相册中选取图片进行搜索，图的大小是否有限制</li>
<li>能否识别图片中的内容</li>
<li>是否支持回车键搜索</li>
<li>输入的内容是否支持快捷键操作等</li>
<li>是否支持检索内容的<strong>编辑、复制、粘贴、剪切、</strong>等操作</li>
<li><strong>重复提交，</strong>多次输入相同的内容，查看系统的检索结果是否一致</li>
<li>搜索内容有没有<strong>搜索联想</strong>功能</li>
<li>搜索的<strong>历史纪录</strong>是否显示，是否有缓存记录</li>
<li>点击<strong>清空历史记录</strong>，搜索框是否会清空</li>
<li>输入链接是否正确跳转</li>
<li>在<strong>断网的情况</strong>下无法搜索,<strong>检查是否有提示信息</strong></li>
<li>在<strong>弱网的情况</strong>下能否搜索，网络延迟服务器响应, <strong>检查提示信息</strong></li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong>，</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>是否有<strong>错别字</strong></li>
<li><strong>搜索结果显示</strong>的布局是否美观</li>
<li>已查看的结果链接，链接的颜色要<strong>灰化处理</strong>，</li>
<li>结果数量庞大时，页面的<strong>分页布局</strong>是否合理</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、安全性测试</strong></p>
<ol>
<li><strong>脚本的禁用，防止XSS攻击，填入js代码是否异常（alert(1111)）</strong></li>
<li><strong>SQL的注入，检索SQL SELECT语句等</strong>（’ or 1&#x3D;1# ）如单引号、%等等，造成查询SQL拼接出的语句产生漏洞</li>
<li>敏感内容的检索是禁止的，对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制</li>
<li>特殊字符的检索</li>
<li>被删除、加密、授权的数据，不允许被查出来</li>
<li>是否有安全设计控制</li>
</ol>
<p><strong>四、性能测试</strong></p>
<ol>
<li>搜索页面的链接<strong>打开速度的时间</strong></li>
<li>搜索出结果消耗时间</li>
<li><strong>高并发场景下用户搜索的响应时间测试。</strong><br>模拟大量用户同时搜索，检查一定压力下能否正常跳转。</li>
<li><strong>弱网时搜索的响应时间</strong></li>
<li><strong>不同网速下搜索时的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>多平台</strong>Windows，mac</li>
<li><strong>移动平台</strong>android，ios</li>
<li><strong>多浏览器</strong>chrome、IE、火狐、360等</li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="微信朋友圈点赞测试"><a href="#微信朋友圈点赞测试" class="headerlink" title="微信朋友圈点赞测试"></a>微信朋友圈点赞测试</h3><p>功能测试<br>界面测试<br><strong>接口测试</strong>（相同好友<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong><br>按点赞人</p>
<ol>
<li>是否可以点赞，<strong>点赞成功</strong>是否显示结果</li>
<li>点赞后能否<strong>取消点赞</strong>，取消后重新点赞情况</li>
<li>点赞是否<strong>显示头像和昵称</strong></li>
<li>点赞<strong>之后能否进行评论</strong></li>
<li>点赞后，其他<strong>共同好友点赞</strong>，是否有消息提醒</li>
<li>点赞后，其他<strong>非共同好友点赞</strong>，是否有消息提醒</li>
<li>点击点赞人的昵称，<strong>能否跳转到其资料页</strong>（可以点自己的，也可以点别人的</li>
<li>从朋友圈动态点赞</li>
<li>访问好友相册，对历史动态点赞情况，点赞不同时间的朋友圈（当天，一周后，一月后，半年后</li>
<li><strong>点赞已经被删除的朋友圈</strong>（点赞方还没来得及刷新的时候</li>
<li>点赞时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试</li>
<li>点赞时<strong>来电话，来信息</strong>有没有影响（中断测试</li>
<li>点赞时<strong>手机重启、手机卡死</strong>（中断测试</li>
<li>点赞时<strong>微信版本升级</strong>（中断测试</li>
</ol>
<p>按被点赞人</p>
<ol>
<li>自己给自己点赞</li>
<li>点赞人昵称是否显示正常（有备注的是否展示备注名，昵称特殊符号能否展示</li>
<li><strong>点赞后列表显示，是否是按时间顺序进行排列</strong></li>
<li>点赞显示区域<strong>一行可以显示多少人，是否换行显示</strong></li>
<li>从朋友圈动态页查看，是否显示点赞用户昵称</li>
<li>从个人相册页查看，是否显示点赞用户头像图标</li>
<li>从个人相册页点击单张图片查看，是否显示点赞用户数量</li>
<li>解除好友关系后，或者屏蔽好友后是否还展示其点赞</li>
</ol>
<p>按点赞内容：</p>
<ol>
<li><strong>点赞不同类型的朋友圈，图片，文字，视频，链接</strong></li>
</ol>
<p>消息提醒：</p>
<ol>
<li>进去朋友圈，<strong>顶端消息提醒</strong></li>
<li>用户屏蔽了朋友圈提醒，有新点赞是否不提醒</li>
<li>动态删除后，原来未查看的消息，是否展示</li>
<li>消息列表展示详情</li>
<li><strong>消息未查看，换设备登录，是否仍存在消息提醒</strong></li>
</ol>
<p>其他</p>
<ol>
<li><strong>多次点赞</strong>会出现什么情况</li>
<li>点赞是否有<strong>人数限制</strong>？</li>
<li>同一朋友圈，<strong>多个好友同时点赞</strong></li>
<li>同一朋友圈，用户<strong>在手机和电脑上同时点赞</strong></li>
<li><strong>弱网</strong>的时候进行点赞是什么情况</li>
<li><strong>没有网络</strong>时是否可以点赞</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否简单，美观</li>
<li>点赞的头像是否显示正常，大小是否合适</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、接口测试</strong>相同好友</p>
<ol>
<li>点赞之后相同好友是否收到提示信息</li>
<li>相同好友处的提示信息是否按照时间顺序</li>
<li>相同好友处的点赞是否显示头像和名称</li>
</ol>
<p><strong>四、性能测试</strong></p>
<ol>
<li>点赞图标的<strong>显示速度</strong>——用户点击点赞几秒后可以看到点赞成功，取消点赞后几秒可以看到取消</li>
<li><strong>多用户同时</strong>给我点赞时，我是否可以全部接收到提示消息（压力测试</li>
<li>频繁点击是否卡顿</li>
<li>频繁浏览是否易崩溃</li>
<li>3g,4g,5G,WIFI、热点，不同运营商网络的网络测试</li>
<li>弱网测试，网络延迟，断网的响应结果</li>
</ol>
<p><strong>五、安全性测试</strong><br>点赞是否会泄漏微信用户相关信息</p>
<p><strong>六、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>，是否都可以进行点赞和取消点赞功能（例如ios12,13,14，安卓）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>不同的微信版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="微信视频通话测试用例"><a href="#微信视频通话测试用例" class="headerlink" title="微信视频通话测试用例"></a>微信视频通话测试用例</h3><p>功能测试<br>界面测试<br>性能测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong><br>发起视频通话，<strong>使用移动网络</strong>进行视频通话是否会有提示：移动网络下将产生手机流量<br>发起视频通话，对方<strong>接听前，是否可以点击取消</strong>，取消有无信息提示<br>发起视频通话，是否可以听到<strong>铃声</strong><br>发起视频通话，对方<strong>接听前是否可以切换到语音通话</strong><br>发起视频通话，<strong>对方正在视频通话</strong>是否会有提示信息<strong>“对方忙”</strong><br>发起视频通话，<strong>对方无应答</strong>，是否有提示信息<br>发起视频通话，<strong>对方拒绝</strong>，是否有提示信息</p>
<p>视频通话中，视频<strong>能否链接成功</strong><br>视频通话中，<strong>声音和画面是否正常，是否同步</strong><br>视频通话中，<strong>是否可切换到语音通话</strong><br>视频通话中，<strong>前后摄像头转换</strong>是否正常<br>视频通话中，<strong>插拔耳机</strong>是否能正常通话<br>视频通话中，点击对方视频窗口<strong>是否可以窗口交换</strong><br>视频通话中，点击音量键<strong>是否可以调节音量</strong><br>视频通话中，是否可以<strong>点击返回键、Home键</strong><br>视频通话中，是否可以<strong>与其他应用切换</strong><br>视频通话中，<strong>挂断功能</strong>是否正常<br>视频通话中，<strong>网络质量差</strong>是否有提示信息</p>
<p>视频通话结束，发起者<strong>结束通话</strong><br>视频通话结束，接收者结束通话<br>视频通话结束，<strong>是否会返回聊天页面</strong><br>聊天页面，<strong>是否有显示记录</strong>（通话时长00:27，对方已取消，对方已拒绝，通话中断，对方忙线中，已拒绝，已取消……</p>
<p>多人视频通话：<br>勾选好友后，确认按钮才可以点击<br>邀请的好友是否都可以进入视频通话<br>未被邀请的好友能否进入视频通话<br><strong>未被邀请的好友是否可以发起视频通话</strong>（只能加入正在进行的通话，不能发起<br>在群聊里<strong>发起</strong>视频通话是否有消息显示：谁谁谁发起了语音通话<br>在群聊里视频通话<strong>结束</strong>是否有已经结束的提示：语音通话已结束<br><strong>使用移动网络</strong>进行视频通话是否会有提示</p>
<p>异常：<br><strong>无网络</strong>是否可以发起视频通话，是否提示：当前网络不可用，请检查网络设置<br>无网络是否可以结束视频通话（通话中断<br><strong>网络质量不好</strong>的情况下发起、接收视频通话<br>视频通话中<strong>有新的</strong>视频通话邀请<br>视频通话中手机<strong>没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>视频通话中<strong>来电话，短信</strong>（中断测试<br>视频通话时<strong>手机重启、手机卡死</strong>（中断测试<br>视频通话中<strong>微信版本升级</strong>（中断测试</p>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>双方视频框大小布局合理</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>视频通话接听后的<strong>响应速度</strong></li>
<li>多人视频通话<strong>可容纳的人数上限</strong></li>
<li>压力测试——<strong>长时间视频（如12小时）是否能保持正常</strong>（CPU，内存消耗，流量消耗）等；</li>
<li>稳定性测试——<strong>频繁</strong>进行视频通话；</li>
<li><strong>不同网络测试：</strong>2G,3G,4G,5G,wifi和热点，不同运营商测试；不同网速测试</li>
</ol>
<p><strong>四、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>，是否都可以进行点赞和取消点赞功能（例如ios12,13,14，安卓）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>不同的微信版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="微信发红包测试用例"><a href="#微信发红包测试用例" class="headerlink" title="微信发红包测试用例"></a>微信发红包测试用例</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong><br><strong>发给单个好友红包</strong><br>输入正确或错误的金额、有无留言、有无表情、有无选择红包封面 <strong>做排列组合的测试</strong><br>是否可以按返回键，<strong>是否可以取消</strong>发红包</p>
<p>对于金额，<strong>是否只能输入数字和小数点</strong><br>对于金额，<strong>是否支持复制、粘贴、剪切</strong><br>对于金额，<strong>测一些边界值</strong>（0，0.01，01，199.99，200，200.01）<br>对于金额，检查<strong>限制几位小数点</strong>，<strong>最少可以输入的钱数</strong><br>对于金额，检查限制单个红包金额，<strong>最多可以输入的钱数</strong>，是否不超过200<br>对于金额（0.01-200），输入0，或者0.0或者0.00，是否可以点击塞钱进红包（<strong>为空测试</strong><br>对于超过200的金额，是否可以点击塞钱进红包<br><strong>直接输入小数点，那么小数点之前是否自动补0</strong><br>对于输入0开头的金额，比如023，<strong>是否会去掉首部0，只显示23</strong></p>
<p>对于留言，测试默认留言：恭喜发财，大吉大利<br><strong>测试输入</strong>数字、中文、英文、特殊字符、emoji表情,；或者他们的<strong>组合</strong><br>测试<strong>留言长度限制</strong>，输入超长文本时，是否会截断显示限制<br>是否支持<strong>复制、粘贴、剪切</strong></p>
<p>测试表情，是否支持选择自己收藏的表情测试（动图&#x2F;静图）<br>测试表情，是否支持选择下载的表情测试（动图&#x2F;静图）<br>自拍表情，是否支持录制并添加进行测试<br>选择完表情之后，<strong>是否图标改变，预览显示小表情</strong><br>点击表情，<strong>是否支持删除</strong>已选择表情</p>
<p>是否支持添加红包封面，输入序列号领取<br>是否支持切换红包封面<br>是否显示红包封面的有效期<br>是否能查看已失效的红包封面<br>是否下一次发红包，默认是上一次选择的红包封面（没过期失效的情况下</p>
<p><strong>点击塞钱进红包，弹出来的界面是否正确</strong><br><strong>如果未开通微信支付，有无引导提示！！！！！</strong><br>如果有开通微信支付，则<strong>支付方式</strong>是否可以修改<br>信用卡交易，<strong>不可选</strong><br>零钱或者零钱通余额小于要发红包的金额，<strong>不可选</strong><br>有没有<strong>添加新的银行卡选项</strong><br>选择支付方式之后，<strong>是否按用户设置的默认方式进行支付</strong>，例如使用正确指纹、或者正确面容、或者正确密码确认付款功能是否正常<br>不正确的指纹或者面容，<strong>不正确的是否提示</strong>，重试依旧<strong>不正确之后是否提示密码输入</strong><br>选择支付方式之后，使用密码确认付款（正确的&#x2F;不正确的密码，不正确的是否提示）<br><strong>密码是否非明文显示</strong><br>密码输入错误，是否可以<strong>选择忘记密码，或者重试，跳转页面是否正确</strong><br>是否<strong>限制密码输入错误次数</strong><br>考虑所选支付方式金额不足的情况，如果<strong>支付失败，是否会提示余额不足</strong><br>如果余额不足是否会提示，换支付方式，已经尝试过的余额不足的选项<strong>是否被灰化</strong></p>
<p>如果红包发送成功，所选支付方式<strong>是否减少了相应的金额</strong><br><strong>账单明细</strong>里是否会同步显示<br>发送者&#x2F;接收者，点击红包是否可以<strong>查看红包的具体信息</strong>，金额，留言，表情等显示正确<br><strong>发给单个用户的红包，发送者自己无法领取</strong><br>接收者点击红包之后，零钱中将增加相应的金额，再次点击之后，只能查看到红包的信息<br>被领取的红包有颜色变化，<strong>颜色被弱化</strong><br>24小时之内没有领取的红包，将<strong>退回原账户</strong>，此时原账户的零钱将增加相应金额的金钱。<br>24小时后好友点击红包，显示红包<strong>已过期，无法查看到</strong>红包的详情以及红包金额</p>
<p><strong>发送群红包</strong>（仅写出与单用户发红包不同的地方<br>红包类型可以选择，拼手气，专属红包<br>红包个数的<strong>输入框中只能输入数字</strong><br>红包<strong>个数最大限制</strong>，100<br>红包个数，输入0，输入01，输入最大100<br>拼手气红包<strong>是否每个红包金额随机</strong><br>普通红包是否<strong>每个红包金额一样</strong>，塞进红包钱数是不是<strong>个数×单个金额</strong><br>拼手气红包，测试红包个数为3，总金额为0.02情况，<strong>会显示单个红包不可低于0.01</strong><br>群中所有人均<strong>可以抢红包（包括自己）</strong>，每个人最多只有一次抢该红包的机会<br>发红包的人<strong>聊天界面是否可以看到红包被领取的消息提示</strong><br>在24小时之内红包的金额被完全抢完，且此时为拼手气红包时，金额最多的人会显示为运气王（若有两个人取得红包的最大值时，则只有一个人会显示为最佳手气）；<br>在24小时之内，若没有被完全抢完，则没有最佳手气，检查余额会退还到原账户<br>超过24小时没有领取的红包，检查是否不可以领取</p>
<p><strong>异常</strong>：<br>发红包、抢红包时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>发红包、抢红包时<strong>来电话，来信息</strong>有没有影响（中断测试<br>发红包、抢红包时<strong>手机重启、手机卡死</strong>（中断测试<br>发红包、抢红包时<strong>微信版本升级</strong>（中断测试<br><strong>断网</strong>时，无法发红包，抢红包</p>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li><strong>弱网</strong>时，抢红包，发红包时间</li>
<li>2G,3G,4G,5G,wifi和热点，<strong>不同运营商测试</strong>；<strong>不同网速测试</strong>时，抢红包，发红包的时间</li>
<li>发红包和收红包成功后的<strong>跳转响应时间</strong></li>
<li>稳定性：是否可以<strong>连续多次</strong>发红包</li>
<li>群发红包，多人同一时间抢，<strong>高并发场景</strong>下响应时间</li>
<li>耗电量</li>
<li>消耗流量的多少</li>
<li>所占内存</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>对方<strong>微信号异地登录</strong>，是否会有提醒</li>
<li>红包被领取以后，收红包金额会增加</li>
<li>红包未领取<strong>，超时是否原路返回</strong></li>
<li><strong>发送红包失败</strong>，余额和银行卡里的钱数不会少</li>
<li>红包<strong>发送成功，是否会收到微信支付</strong>的通知</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>（例如ios12,13,14，安卓）</li>
<li><strong>不同的微信版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="微信评论测试用例（论坛评论、抖音评论功能"><a href="#微信评论测试用例（论坛评论、抖音评论功能" class="headerlink" title="微信评论测试用例（论坛评论、抖音评论功能"></a>微信评论测试用例（论坛评论、抖音评论功能</h3><p>功能测试<br>界面测试<br>性能测试<br>接口测试（共同好友<br>安全性测试<br>兼容性测试</p>
<p>（论坛评论，需要另外注意，1、用户是否登录，是否有权限评论； 2、没有共同好友可见这种说法</p>
<p>（抖音评论，需要另外注意，1、用户是否登录，是否有权限评论； 2、没有共同好友可见这种说法；3.可以@别人，提醒功能，可以给评论点赞功能，可以给别人评论回复，点赞多5-5条的是否置顶显示，评论的点赞数显示是否正常，某条评论的回复互动是否可以展开，收起</p>
<p><strong>一、功能测试</strong><br><strong>按评论人</strong></p>
<ol>
<li>是否可以评论，<strong>评论成功</strong>是否显示结果</li>
<li>评论后能否<strong>删除评论</strong>，删除后重新评论情况</li>
<li><strong>支持哪些评论类型</strong>：文字、表情</li>
<li><strong>能否评论为空，评论空格</strong>（为空测试！！！！！！！</li>
<li>评论的<strong>字数长度限制</strong></li>
<li>评论输入框是否<strong>支持复制粘贴剪切</strong></li>
<li>能否<strong>多次评论</strong></li>
<li>评论后是否<strong>显示头像和昵称</strong></li>
<li>评论后，其他<strong>共同好友是否可以看到</strong></li>
<li>是否可以<strong>看到其他共同好友的评论</strong></li>
<li>是否可以<strong>回复其他共同好友的评论</strong></li>
<li>评论后，其他<strong>共同好友评论</strong>，是否有提醒</li>
<li>评论后，其他<strong>非共同好友评论</strong>，是否有提醒</li>
<li>点击评论人的昵称，<strong>能否跳转到其资料页</strong>（可以点自己的，也可以点别人的</li>
<li>从朋友圈<strong>动态页评论</strong></li>
<li>访问好友相册，<strong>对历史动态评论</strong>，评论不同时间的朋友圈（当天，一周后，一月后，半年后</li>
<li><strong>评论已经被删除的朋友圈</strong>（还没来得及刷新的时候</li>
<li>评论时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试</li>
<li>评论时<strong>来电话，来信息</strong>有没有影响（中断测试</li>
<li>评论时<strong>手机重启、手机卡死</strong>（中断测试</li>
<li>评论时<strong>微信版本升级</strong>（中断测试</li>
</ol>
<p><strong>按被评论人：</strong></p>
<ol>
<li>自己给自己评论</li>
<li>评论人<strong>头像、昵称是否显示正常</strong>（有备注的是否展示备注名，昵称特殊符号能否展示</li>
<li><strong>评论后列表显示，是否是按时间顺序</strong></li>
<li>评论显示区域<strong>是否按评论人单独一行显示，一行最多多少字，长度超过是否换行显示</strong></li>
<li>从朋友圈动态页查看，是否显示评论用户头像、昵称、评论内容</li>
<li>从个人相册页点击单张图片查看，是否显示评论的数量</li>
<li>解除好友关系后，或者屏蔽好友后是否还展示其评论</li>
</ol>
<p><strong>按评论的朋友圈内容：</strong></p>
<ol>
<li><strong>评论不同类型的朋友圈，图片，文字，视频，链接</strong></li>
</ol>
<p><strong>消息提醒：</strong></p>
<ol>
<li>进去朋友圈，<strong>顶端消息提醒</strong></li>
<li>用户<strong>屏蔽了朋友圈提醒</strong>，有新评论是否不提醒</li>
<li>动态删除后，原来未查看的消息，是否展示</li>
<li><strong>消息列表展示详情</strong></li>
<li><strong>消息未查看，换设备登录，是否仍存在消息提醒</strong></li>
</ol>
<p><strong>其他</strong></p>
<ol>
<li><strong>多次评论</strong>会出现什么情况</li>
<li>评论是否有<strong>人数限制</strong>？</li>
<li>同一朋友圈，<strong>多个好友同时评论</strong></li>
<li>同一朋友圈，用户<strong>在手机和电脑上同时评论</strong></li>
<li><strong>弱网</strong>的时候进行评论是什么情况</li>
<li><strong>没有网络</strong>时是否可以评论</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否简单，美观</li>
<li>评论人的头像、昵称等是否显示正常，大小是否合适</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、接口测试</strong>（相同好友</p>
<ol>
<li>评论之后相同好友是否收到提示信息</li>
<li>相同好友处的提示信息是否按照时间顺序</li>
<li>相同好友处的评论是否显示头像和名称</li>
</ol>
<p><strong>四、性能测试</strong></p>
<ol>
<li>评论的<strong>显示速度</strong>——用户评论几秒后可以看到评论显示成功，取消评论后几秒可以看到取消</li>
<li><strong>多用户同时</strong>给我评论时，我是否可以全部接收到提示消息（压力测试</li>
<li>频繁评论是否卡顿</li>
<li>频繁浏览是否易崩溃</li>
<li>3g,4g,5g,WIFI、热点，不同运营商网络的网络测试</li>
<li>弱网测试，网络延迟，断网的响应结果</li>
</ol>
<p><strong>五、安全性测试</strong></p>
<ol>
<li>评论是否会泄漏微信用户相关信息</li>
<li>评论里放不安全的链接</li>
</ol>
<p><strong>六、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>，是否都可以进行评论和取消评论功能（例如ios12,13,14，安卓）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>不同的微信版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="购物车测试（例如淘宝、淘宝结账测试用例"><a href="#购物车测试（例如淘宝、淘宝结账测试用例" class="headerlink" title="购物车测试（例如淘宝、淘宝结账测试用例"></a>购物车测试（例如淘宝、淘宝结账测试用例</h3><p>业务流程：<br>进入购物车-&gt;加商品到购物车-&gt;编辑购物车-&gt;选择商品-&gt;提交订单</p>
<p><strong>一、功能测试</strong></p>
<ol>
<li>用户的权限：用户登录后才能对购物车操作，未登录会提示需要登录</li>
<li>未登录时，将商品加入购物车，页面跳转到登录页面，登录成功后购物车数量增加</li>
<li>未登录时，点击底部购物车菜单栏，页面跳转到登录页面，登录成功后可以查看购物车</li>
<li>登录后，验证所有链接是否跳转正确，是否能够正常进入购物车页面，有两种方式：通过底部菜单栏或在商品详情页面跳转到购物车结算。</li>
<li>对购物车商品的操作：<ol>
<li>添加商品<br> 商品是否可以成功加入购物车<br> 添加一件商品到购物车，查看购物车页面商品是否增加<br> 添加同一个店铺的多个商品到购物车，查看显示是否正常<br> 添加不同店铺的多个商品到购物车，查看显示是否正常<br> 店铺或商品名过长时，是否进行部分显示<br> 点击商品链接是否能跳转到商品详情<br> 购物车商品总数是否有限制<br> 购物车商品总数是否正确<br> 新加入购物车商品排序（添加购物车中存在店铺的商品，购物车中不存在店铺的商品）显示是否正确</li>
<li>删除商品<br> 删除功能是否好用<br> 点击删除商品，是否有提示<br> 商品删除后商品总数是否减少</li>
<li>增加&#x2F;减少商品数量<br> 通过“+”、“-”来增加&#x2F;减少商品数量，考虑边界值0、最大限购数量、库存<br> 通过输入来确定数量，是否只支持整数输入，有效：整数；无效：特殊字符、小数、负数是否不允许输入；输入023是否自动会自动检测为23</li>
<li>对商品的管理<br> 是否支持重新选择商品规格<br> 打折或者活动，例如满减商品是否打标<br> 移入收藏夹，收藏夹有相应商品，购物车中没有<br> 是否支持找相似商品的功能<br> 单选、按店铺全选和整个购物车全选功能是否好用<br> 多选商品，数量与选择是否一致<br> 商品无货或下架等，是否移到失效<br> 是否有回到顶部的功能<br> 是否支持一键清理，一键删除的功能，是否有警告提示</li>
<li>结算<br> 对选择的商品进行结算，数量与选择的是否一致，需支付价格与实际价格总和是否一致。</li>
</ol>
</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li><strong>不同卖家的商品是否区分明显！！！！</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字是否显示清晰，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li><p>加入购物车响应速度</p>
</li>
<li><p>打开购物车响应速度</p>
</li>
<li><p>进入购物车结算响应速度</p>
</li>
<li><p><strong>高并发场景下用户进行购物车操作的响应时间测试。</strong><br>模拟大量用户同时加购物车，检查一定压力下能否正常跳转。</p>
</li>
<li><p>频繁加购物车，频繁浏览是否易卡顿、崩溃</p>
</li>
<li><p>中断测试：<br>加购物车时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>加购物车时<strong>来电话，来信息</strong>有没有影响（中断测试<br>加购物车时<strong>手机重启、手机卡死</strong>（中断测试<br>加购物车时<strong>淘宝版本升级</strong>（中断测试</p>
</li>
<li><p><strong>弱网测试（地铁，高铁，山区）延时，丢包，fiddler，弱网时加购的响应时间</strong>. </p>
<p>延时——超时, 2min之内没有收到请求;合理性提示.<br>丢包——系统2min之内，没有上传到服务器，做失败处理;重发机制</p>
</li>
<li><p><strong>不同网速下加购的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</p>
</li>
<li><p>网络延迟，断网的响应结果</p>
</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>通过一些工具进行安全扫描，检查是否有安全漏洞</li>
<li>防止结算价格修改等，fiddler</li>
<li>防止sql注入，跨站攻击等</li>
<li>验证敏感信息是否加密，是否可以篡改</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>，是否都可以进行正常的购物车功能（安卓系统、ios系统，主流的系统版本需要测试覆盖）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>不同的淘宝版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="淘宝搜索框测试用例"><a href="#淘宝搜索框测试用例" class="headerlink" title="淘宝搜索框测试用例"></a>淘宝搜索框测试用例</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong></p>
<ol>
<li><p>未登录情况和登录情况下的搜索（登录情况下存储用户搜索的关键字&#x2F;搜索习惯）</p>
</li>
<li><p>输入<strong>搜索关键字</strong>，验证每种合法的输入，结果是否正确，<strong>各种正常输入的字符，混合输入，排列组合。</strong></p>
</li>
<li><p>是否可以输入数字，英文，中文等</p>
</li>
<li><p>是否可以<strong>混合输入</strong>数字，英文，中文等</p>
</li>
<li><p>输入<strong>可查到结果的正常关键字</strong>、词、语句，<br>输入<strong>不可查到结果的</strong>关键字、词、语句；<br>输<strong>入一些特殊的内容</strong>，如空、特殊符、标点符；（为空测试</p>
</li>
<li><p>点击搜索，<strong>是否正常显示搜索界面</strong></p>
</li>
<li><p>搜索内容与搜索结果的<strong>匹配程度</strong>，点击商品链接是否正确跳转</p>
</li>
<li><p>查看返回结果是否准确，<strong>返回的商品文本长度是否有限制</strong></p>
<p>结果显示：标题，卖家，销售量，价格，单行&#x2F;多行，列表&#x2F;平铺显示，是否有图片</p>
</li>
<li><p>结果排序：按价格 销量 综合 信用</p>
</li>
<li><p>返回结果数量很多时，限制一页的显示量，是否支持下拉</p>
</li>
<li><p>筛选功能是否可用：分类、价格区间、发货地、品牌、产地、折扣与服务（是否天猫，是否全球购，是否包邮，是否支持7天内退货等）筛选与设置</p>
</li>
<li><p>是否支持模糊搜索（输入<strong>拼音</strong>能不能进行检索），有疑似输入条件错误时提示可能正确的输入项等等处理（栗子七，你要找的是不是李子柒</p>
</li>
<li><p>标题查询、全文检索、模糊查询、容错查询、多关键字查询（空格间格开）等搜索方式是否正常</p>
</li>
<li><p>是否支持<strong>图片搜索</strong>，图片搜索按钮是否可用，进行图片搜索时是否可以选择拍照或从相册中选取图片进行搜索</p>
</li>
<li><p>如果从相册中选取图片进行搜索，图的大小是否有限制</p>
</li>
<li><p>能否识别图片中的内容</p>
</li>
<li><p>是否支持检索内容的<strong>编辑、复制、粘贴、剪切、</strong>等操作</p>
</li>
<li><p><strong>重复提交，</strong>多次输入相同的内容，查看系统的检索结果是否一致</p>
</li>
<li><p>搜索内容有没有<strong>搜索联想</strong>功能</p>
</li>
<li><p>搜索的<strong>历史纪录</strong>是否显示，是否有缓存记录</p>
</li>
<li><p>点击<strong>清空历史记录</strong>，是否有提示确认，历史记录是否会清空</p>
</li>
<li><p>在<strong>断网的情况</strong>下无法搜索,<strong>检查是否有提示信息</strong></p>
</li>
<li><p>在<strong>弱网的情况</strong>下能否搜索，网络延迟服务器响应, <strong>检查提示信息</strong></p>
</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>交互界面的设计是否便于理解、易于使用依据不同的查询结果会有相关的人性化提示，查不到时告知？查到时统计条数并告知？</li>
<li>查看界面<strong>是否显示正确，布局是否合理</strong>，</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>是否有<strong>错别字</strong></li>
<li><strong>搜索结果显示</strong>的布局是否美观</li>
<li>已查看的结果链接，链接的颜色要<strong>灰化处理</strong>，</li>
<li>结果数量庞大时，页面的<strong>分页布局</strong>是否合理</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>搜索商品响应速度</li>
<li><strong>高并发场景下用户搜索的响应时间测试。</strong><br>模拟大量用户同时搜索，检查一定压力下能否正常跳转。</li>
<li>负载测试：看极限能承载多大的用户量同时正常使用</li>
<li>弱网测试，<strong>弱网时搜索的响应时间</strong></li>
<li>网络测试，<strong>不同网速下搜索时的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</li>
<li>稳定性测试：常规压力下能保持多久持续稳定运行</li>
<li>内存测试：有无内存泄漏现象</li>
<li>大数据量测试：如模拟从庞大的海量数据中搜索结果、或搜索出海量的结果后列示出来，看表现如何等</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li><strong>脚本的禁用，防止XSS攻击，填入js代码是否异常（alert(1111)）</strong></li>
<li><strong>SQL的注入，检索SQL SELECT语句等</strong>（’ or 1&#x3D;1# ）如单引号、%等等，造成查询SQL拼接出的语句产生漏洞</li>
<li>敏感内容的检索是禁止的，对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制</li>
<li>特殊字符的检索</li>
<li>被删除、加密、授权的数据，不允许被查出来</li>
<li>是否有安全设计控制</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>多平台</strong>Windows，mac、LINUX</li>
<li><strong>移动平台</strong>android，ios</li>
<li><strong>多浏览器</strong>chrome、IE、火狐、360等</li>
<li><strong>不同淘宝版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="支付功能测试（支付宝支付，微信支付，银行卡支付等"><a href="#支付功能测试（支付宝支付，微信支付，银行卡支付等" class="headerlink" title="支付功能测试（支付宝支付，微信支付，银行卡支付等"></a>支付功能测试（支付宝支付，微信支付，银行卡支付等</h3><p><strong>一、功能测试</strong></p>
<p><strong>支付流程测试点</strong></p>
<ol>
<li>正常完成支付的流程；</li>
<li>调起订单后，取消订单</li>
<li>支付中断后，继续支付的流程；</li>
<li>支付中断后，结束支付的流程；</li>
<li>单订单支付的流程；</li>
<li>多订单合并支付的流程；</li>
<li>支付失败后，再次支付</li>
<li>弱网状态下，连续点击支付功能功能，会不会支付多次；</li>
<li>找人代付；</li>
<li>密码错误；</li>
<li>密码错误次数过多，是否限制；</li>
<li><strong>支付后，有没有跳回原页面</strong></li>
<li>支付成功后，产品购买是否成功</li>
</ol>
<p><strong>支付方式测试点</strong></p>
<ol>
<li>不同的支付方式：银行卡网银支付、支付宝支付、微信支付等；</li>
<li>不同终端上支付：包括PC端的支付、笔记本电脑的支付、平板电脑的支付、手机端的支付等；</li>
<li>（支付宝）<strong>支付过程中是否允无网络的情况下，可以进行打开付款码界面，被扫码支付。</strong></li>
<li>（支付宝）<strong>支付宝付款码是否付款码每间隔一段时间会更新一次。</strong></li>
<li>（支付宝）主动扫一扫支付，被动付款码支付</li>
<li>（支付宝）点击主页“付钱&#x2F;收钱”按钮， 是否可以成功的调出二维码识别界面。</li>
<li>有优惠券、折扣、促销价进行结算是否正确；</li>
<li>优惠券&#x2F;折扣是否是必选，是否可以不选择折扣</li>
<li>支付订单退款完成后，优惠券&#x2F;折扣是否还能使用</li>
</ol>
<p><strong>支付金额测试点</strong></p>
<ol>
<li>正常金额支付</li>
<li>金额字段校验：非数字、sql相关字符、负数、边界值与数据库设计长度，为空是否报错  </li>
<li>金额的最小值：0.01</li>
<li>无意义的值：0元</li>
<li>最大金额：设置支付的最大金额</li>
<li>银行卡或微信等，设置每日最大消费金额或者单笔最大消费金额</li>
<li>余额不足；</li>
<li>是否支持添加新卡支付；</li>
<li>付款金额和应付金额是否一致，（比如：扫描的支付二维码，和显示的应支付金额是否一致）。支付还是要走整个支付流程才行，从确认订单到最后的支付成功，任何一步都有可能有问题。</li>
<li>支付成功后，用户的金额是否扣除成功</li>
<li>取消支付后，退款金额是否正确</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>各种提示，是否显示正常（例如点击付款按钮取消付款，是否有提示；</li>
<li>交互界面的设计是否便于理解、易于使用</li>
<li>查看界面<strong>是否显示正确，布局是否合理</strong>，</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li><p>支付的响应时间，取消支付的响应时间；</p>
</li>
<li><p><strong>高并发场景下用户进行支付操作的响应时间测试。</strong><br>模拟大量用户同时支付，检查一定压力下能否正常跳转。</p>
</li>
<li><p>中断测试：<br>支付时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>支付时<strong>来电话，来信息</strong>有没有影响（中断测试<br>支付时<strong>手机重启、手机卡死</strong>（中断测试<br>支付时<strong>当前支付软件版本升级</strong>（中断测试</p>
</li>
<li><p><strong>弱网测试（地铁，高铁，山区）延时，丢包，fiddler，弱网时加购的响应时间</strong>. </p>
<p>延时——超时, 2min之内没有收到请求;合理性提示.<br>丢包——系统2min之内，没有上传到服务器，做失败处理;重发机制</p>
</li>
<li><p><strong>不同网速下加购的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</p>
</li>
<li><p>网络延迟，断网的响应结果</p>
</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>通过一些工具进行安全扫描，检查是否有安全漏洞</li>
<li><strong>使用Fiddler拦截订单信息，并修改订单金额，或者修改订单号，</strong>(下两个订单A,B，付款时拦截订单B，并把订单B的订单号改为A订单的订单号)<strong>是否无法完成支付；</strong></li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>多平台</strong>Windows，mac、LINUX</li>
<li><strong>移动平台</strong>android，ios</li>
<li><strong>多浏览器</strong>chrome、IE、火狐、360等</li>
<li>支付软件不同版本</li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="支付宝转账测试用例"><a href="#支付宝转账测试用例" class="headerlink" title="支付宝转账测试用例"></a>支付宝转账测试用例</h3><p>转账方–&gt;支付宝–&gt;收款方流程，观察测试场景</p>
<p><strong>一、功能测试</strong></p>
<p><strong>转账流程测试点</strong></p>
<ol>
<li>正常完成转账的流程；</li>
<li>发起转账后，取消转账</li>
<li>转账支付中断后，继续转账支付的流程；</li>
<li>转账支付中断后，结束转账支付的流程；</li>
<li>给单人转账</li>
<li>给多人转账；</li>
<li>转账人确认与校验</li>
<li>转账失败后，再次转账</li>
<li>弱网状态下，连续点击转账支付功能，会不会转账多次；</li>
<li>面容支付，或者指纹，或者密码错误；</li>
<li>密码错误次数过多，是否限制；</li>
</ol>
<p><strong>转账方式测试点</strong></p>
<ol>
<li>不同的转账支付方式：面容支付，指纹支付，密码支付等；</li>
<li>不同终端上转账支付：包括PC端的支付、平板电脑的支付、手机端的支付等；</li>
</ol>
<p><strong>转账金额测试点</strong></p>
<ol>
<li>正常金额转账</li>
<li>转账金额大于、等于、小于当前余额，<strong>余额不足的</strong>情况</li>
<li><strong>金额字段校验：非数字、sql相关字符、负数、边界值与数据库设计长度，为空是否报错</strong>  </li>
<li>金额的<strong>最小值</strong>：0.01</li>
<li>无意义的值：0元</li>
<li><strong>最大金额</strong>：转账的最大金额</li>
<li>银行卡或微信等，设置每日最大转账金额或者单笔最大转账金额</li>
<li>是否支持添加新卡转账支付；</li>
<li>转账金额和扣款金额是否一致</li>
<li>转账成功后，用户的金额是否扣除成功</li>
<li>转账之后是否对方是否到账</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>各种提示，是否显示正常（例如转账，取消转账，转账确认等，是否有提示；</li>
<li>交互界面的设计是否便于理解、易于使用</li>
<li>查看界面<strong>是否显示正确，布局是否合理</strong>，</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的设计风格，颜色搭配是否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li><p>转账的响应时间，取消转账的响应时间；</p>
</li>
<li><p><strong>高并发场景下用户进行转账操作的响应时间测试。</strong><br>模拟大量用户同时转账，检查一定压力下能否正常跳转。</p>
</li>
<li><p>中断测试：<br>转账时<strong>手机没电、断网、手机故障、系统更新、app切换</strong>（中断测试<br>转账时<strong>来电话，来信息</strong>有没有影响（中断测试<br>转账时<strong>手机重启、手机卡死</strong>（中断测试<br>转账时<strong>支付宝版本升级</strong>（中断测试</p>
</li>
<li><p><strong>弱网测试（地铁，高铁，山区）延时，丢包，fiddler，弱网时加购的响应时间</strong>. </p>
<p>延时——超时, 2min之内没有收到请求;合理性提示.<br>丢包——系统2min之内，没有上传到服务器，做失败处理;重发机制</p>
</li>
<li><p><strong>不同网速下加购的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</p>
</li>
<li><p>网络延迟，断网的响应结果</p>
</li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>通过一些工具进行安全扫描，检查是否有安全漏洞</li>
<li><strong>使用Fiddler拦截转账信息，并修改转账金额，或者修改转账交易号，</strong>(下两个转账A,B，转账时拦截订单B，并把转账B的交易号改为转账A的交易号)<strong>是否无法完成支付；</strong></li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>多移动平台</strong>android，ios</li>
<li>支付宝不同版本</li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是支持多种语言版本</strong></li>
</ol>
<h3 id="x3D-x3D-x3D-x3D-x3D-实物类测试-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-实物类测试-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;实物类测试&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;实物类测试&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h3><h3 id="自动售货机测试用例"><a href="#自动售货机测试用例" class="headerlink" title="自动售货机测试用例"></a>自动售货机测试用例</h3><p>功能测试<br>界面测试(外观，大小等)<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p>首先，拆解自动售货机为不同模块，存放货物区、取货区、付钱区<br><strong>一、功能测试</strong></p>
<ol>
<li>自动售货机的<strong>按钮能否正常使用</strong>，有没有按不动的情况</li>
<li><strong>货物是否正常放置</strong></li>
<li>验证用户<strong>选择饮料功能是否正确</strong>，比如选择农夫山泉最终出来的是不是农夫山泉</li>
<li>点击货物选择按钮<strong>是否能进入支付页面</strong></li>
<li>是否支持<strong>选择多个货物</strong></li>
<li>是否<strong>支持硬币、纸币、微信、支付宝等方式支付</strong></li>
<li>付了钱选择了货物，是否能正常出货</li>
<li>验证<strong>投币付款功能</strong>是否正确，是否支持<strong>找零</strong><br>同面额的纸币硬币，有面额不接受怎么办<br>付钱不够怎么办<br>付钱多了怎么办<br>付钱多了但是没有零钱找怎么办<br>付钱不是正常的钱怎么办，比如假钱，游戏币等</li>
<li><strong>货物是否能正常取出</strong>(有的货物过大、过小、形状不规范等)，取货口是否好拿货物（针对不同的人群，是否使用方便，孕妇、儿童、老人、成年人</li>
<li><strong>出现故障时能否自动退款</strong></li>
<li>货物卡住了或者钱没有退，是否有联系客服的方式</li>
<li>屏幕是否正常播放广告</li>
<li>屏幕是否显示二维码</li>
<li>操作过程有没有<strong>相应的提示音</strong></li>
<li>售货机<strong>缺货时会不会有提醒</strong></li>
<li><strong>定价功能</strong>可否正常使用，是否支持非整数定价，像定个九块</li>
<li><strong>优惠信息</strong>可否正常折扣，像有优惠券或打折时</li>
<li>操作是否跟<strong>网络状态</strong>有关系（弱网、强网、无网）</li>
<li>对于存放的货物有没有<strong>常温、冷藏、加热功能，温度能不能设置</strong><br>有效的等价类有：<br>        金额刚够，顺利出货<br>        金额超出，找零出货<br>        金额超出, 没钱找零,出货<br>        金额不足，进行提示，把货币退出<br>        金额足够，取消交易<br>        假币，不出货<br>无效等价类：<br>     投入金额，不出货，不找零<br>     投入金额，不出货，退钱<br>     金额超出，出货，不找零<br>     金额超出，不出货，找零<br>     金额不足，出货，找零l<br>     金额不足，出货，不找零<br>     金额不足，不出货，不退款<br>     金额刚够，不出货，退款<br>     金额刚够，出货，找零<br>     金额刚够，不出货，找零<br>     不投金额，直接出货</li>
</ol>
<p><strong>二、界面测试</strong></p>
<ol>
<li>外观设计是否合理，售货机的<strong>大小</strong>是否合适</li>
<li><strong>操作界面的布局</strong>搭配是否合理，不同模块的大小分配是否合理（投币口是否明显，取物口是否明显</li>
<li>操作是否简便，流程是否复杂，使用说明是否通俗易懂</li>
<li><strong>操作接口</strong>是否齐全</li>
<li><strong>按钮</strong>的大小、颜色、形状是否美观，是否通俗易懂</li>
<li>有没有设备编号、<strong>服务电话</strong>标识</li>
<li>有没有消费者投诉电话</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>选择商品后<strong>跳转到支付页面的时间</strong></li>
<li>利用微信、支付宝等<strong>第三方平台支付时的响应速度</strong></li>
<li>支付成功后<strong>商品掉落时间</strong></li>
<li><strong>退币时的响应时间和退币速度</strong></li>
<li>付款时<strong>突然断电</strong>，异常断电、系统故障，是否有恢复功能</li>
<li>跟第三方支付平台的<strong>接口</strong>对接是否可用</li>
<li>软硬件结合的效率，软硬件软件发出操作指令后，硬件的及时正确响应</li>
<li><strong>多个用户同时扫码支付</strong></li>
</ol>
<p><strong>四、安全性测试</strong></p>
<ol>
<li>售货机上的二维码是否屏幕实时显示，刷新<strong>，防止他人恶意替换二维码</strong></li>
<li><strong>收款码</strong>是否携带恶意病毒</li>
<li>售货机的<strong>材料</strong>是否安全无害</li>
<li><strong>玻璃</strong>是否易被敲碎</li>
<li>是否漏电，下雨天会不会漏水</li>
<li>受到外力撞击是否容易<strong>倾倒</strong></li>
<li>售货机设计的<strong>有没有锋利的地方</strong>，会不会划伤到顾客</li>
<li>售货机<strong>存钱的地方是否安全</strong>，会不会被他人偷取</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li>是否能在<strong>室外、室内</strong>工作</li>
<li>是否能在<strong>高温下</strong>工作</li>
<li>是否能在<strong>低温下</strong>工作</li>
</ol>
<h3 id="水杯测试用例（一次性咖啡杯、纸杯等等"><a href="#水杯测试用例（一次性咖啡杯、纸杯等等" class="headerlink" title="水杯测试用例（一次性咖啡杯、纸杯等等"></a>水杯测试用例（一次性咖啡杯、纸杯等等</h3><p>功能测试+易用性测试<br>界面测试(外观，大小)<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p><strong>一、功能测试</strong><br>盛放<strong>半杯水</strong>是否漏水<br><strong>超过水杯规定的安全线</strong>是否漏水<br>盛放<strong>一整杯水</strong>是否会溢出<br><strong>拧紧盖子，摇晃</strong>是否漏水<br><strong>水杯容量</strong>是否与需求一致 (例如需求是500ml)<br>盛放热水<strong>是否烫手</strong><br>（易用性测试）<br>杯子<strong>倒水</strong>是否方便<br>杯子<strong>喝水</strong>是否方便<br>水杯是否<strong>使用简单，容易操作</strong><br>杯子是否<strong>方便外带</strong></p>
<p><strong>二、性能测试</strong><br>水杯<strong>耐热性</strong><br>水杯<strong>耐寒性</strong><br>水杯能够盛放<strong>热水</strong>的容量<br>水杯能够盛放<strong>冷水</strong>的容量<br>能够使用的<strong>最大次数或时间</strong><br>盖子<strong>拧多紧不会漏水</strong><br>掉在地上不易摔坏<br>能否保温，<strong>保温</strong>时长<br><strong>长时间放置</strong>是否漏水(7×24h)<br>检查水杯的<strong>最大抗压</strong>和拉扯承受力<br>杯子从<strong>不同高度掉下的损坏程度</strong><br><strong>防震性能测试</strong>：杯子加包装(有填充物) ，六面震动，检查产品是否能应对恶劣的铁路&#x2F;公路&#x2F;航空运输</p>
<p><strong>三、界面测试</strong><br>使用手册是否对杯子的用法、限制、使用条件等有详细描述<br>水杯外观是否<strong>简单、美观</strong><br>水杯设计是否符合人体，<strong>拿着舒服</strong><br>水杯大小是否<strong>与设计一致</strong>（水杯的高、宽、容量、直径<br>水杯材质是否<strong>与需求一致</strong><br>水杯上<strong>图案</strong>是否合法，是否容易掉落，遇水是否掉落</p>
<p><strong>四、安全性测试</strong><br>检查水杯万一被破坏，是否会伤害使用者<br>杯子使用的材质<strong>是否有毒</strong>或有细菌<br>杯子盛放热水、冷水是否有有毒气体散发（<strong>高温下材</strong>质是否释放毒性、<strong>低温下</strong>材质是否释放毒性<br>杯子是否有<strong>防滑措施</strong></p>
<p><strong>五、兼容性测试</strong><br>除盛放水外，<strong>能否盛放果汁、碳酸饮料</strong>等<br>除盛放饮用品外，<strong>能否盛放硫酸、酒精、汽油</strong>等<br>杯子<strong>在不同地方、不同温度环境下</strong>都可以正常使用</p>
<h3 id="矿泉水瓶测试用例"><a href="#矿泉水瓶测试用例" class="headerlink" title="矿泉水瓶测试用例"></a>矿泉水瓶测试用例</h3><p><strong>一、功能测试</strong><br>装水、喝水的功能，具体如下：</p>
<ol>
<li>检查矿泉水瓶的容量是否符合设计要求</li>
<li>将空瓶和装满水的瓶子放在电子秤上，检查瓶子装满水前后的重量，是否符合设计要求。</li>
<li>检查水瓶在装少量水、半瓶水、装满水的情况下是否会漏水；</li>
<li>检查水瓶在装少量水、半瓶水、装满水的情况下能否喝到水；</li>
<li>在瓶盖拧紧不漏水的情况下，分别让成年男性、成年女性和小孩尝试拧开瓶盖，看是否成功；</li>
<li>分别将水瓶放在手中、口袋、包包、车上等不同位置，看是否方便携带</li>
</ol>
<p><strong>二、界面测试（外观测试</strong><br>主要是两方面，水瓶的大小、水瓶外观设计：</p>
<ol>
<li>瓶子的高度、底座尺寸是否符合设计要求；</li>
<li>瓶子的口径尺寸是否符合设计要求；</li>
<li>瓶身上的字体颜色、大小是否符合设计要求，是否有错别字；</li>
<li>瓶身上的纹路、线条是否符合设计要求；</li>
<li>瓶身上图标布局是否合理，其间距、大小是否符合公设计要求；</li>
<li><strong>是否符合用户审美，用户体验感</strong></li>
</ol>
<p><strong>三、性能测试</strong><br>测试水瓶的抗摔、抗压、抗高低温等情况：</p>
<ol>
<li>将瓶子装满水后拧紧瓶盖，将其倒置或使劲摇晃、各种角度挤压，看是否漏水或破裂。</li>
<li>将空瓶、半瓶水、满瓶水分别从不同的高度（1m、3m、8m、15m）摔下来，看瓶子是否摔坏，是否漏水；</li>
<li>将空瓶和半瓶水、满瓶水分别放置于不同温度下（冰箱、室内和太阳光高温）下一段时间（1天，10天，1个月，6个月），观察瓶子是否漏水，瓶身是否破裂；</li>
<li>将空瓶、装半瓶水的瓶子、装满水的瓶子分别置于水平桌面上，用电风扇吹桌面上的瓶子，调节电风扇的风力大小，观察瓶子是否会被吹倒或吹走</li>
<li>满瓶的水加包装后，六面震动，检查产品是否能应对铁路&#x2F;公路&#x2F;航空等运输环境。</li>
</ol>
<p><strong>四、安全性测试</strong><br>测试水瓶使用时是否会伤害到人、是否产生对人体有害物质等：</p>
<ol>
<li><p>用手去抚摸瓶身的内壁和外壁，是否感觉光滑舒适不刺手；</p>
</li>
<li><p>用矿泉水瓶喝水，并转动瓶口，感受瓶口是否圆滑；</p>
</li>
<li><p>空瓶长时间放置一段时间（一个月、三个月、半年），一起检测是否产生塑化剂或细菌；</p>
</li>
<li><p>将空瓶子燃烧掉，观察燃烧时的火焰，闻燃烧时的气味，查看燃烧的残留物是否符合材质的燃烧特性，是否产生有害的毒气。</p>
</li>
<li><p>矿泉水瓶分别装满不同液体（水、碳酸饮料、果汁等），放置一段时间，看瓶身是否与液体之间发生化学反应，是否产生有毒物质或细菌；</p>
</li>
<li><p>矿泉水瓶中装入热水（或放入微波炉），观察瓶子是否变形，是否有异味产生</p>
</li>
<li><p>用手轻拿装满水的瓶子，看是否轻易掉落，是否有防滑措施；</p>
</li>
<li><p>矿泉水瓶分别装入不同温度（30℃、60℃、80℃）的水，用手感受瓶身温度，看是否会烫手，因为感受不到的话更容易烫嘴。；</p>
</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li>瓶中分别装入碳酸饮料、果汁、咖啡、茶水、油类等液体，放置一段时间是否变味；</li>
<li>瓶中是否可以装入固体例如饼干、沙子，石头等），且瓶子与装入的固体是否会发生化学反应。</li>
</ol>
<p>But，还没有结束。如果更近一步，可以从测试手段上进行进一步的思考。<strong>你是希望测试一个矿泉水瓶呢还是一百万个？</strong>测试一个的话手动就行了。如果是一百万个？只能借助机器，用自动化的方式来实现了。再比如稳定性测试中，<strong>瓶盖是需要开启十次还是一万次</strong>？十次手动做做还可以接受，一万次扭下来估计手也要废掉了。所以必须考虑自动化。诸如此类</p>
<p>在测试内容明确的基础上，再从测试手段上去进行考量，才是比较全面的思路。</p>
<h3 id="一个网站测试用例"><a href="#一个网站测试用例" class="headerlink" title="一个网站测试用例"></a>一个网站测试用例</h3><p>首先，查找需求说明、网站设计等相关文档，分析测试需求。<br>制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试；界面测试；性能测试；数据库测试；安全性测试；兼容性测试<br>设计测试用例：<br>功能性测试<br>可以包括，但不限于以下几个方面：<br>链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的出错信息返回。<br>提交功能的测试。<br>多媒体元素是否可以正确加载和显示。<br>多语言支持是否能够正确显示选择的语言等。<br>界面测试<br>可以包括但不限于一下几个方面：<br>页面是否风格统一，美观<br>页面布局是否合理，重点内容和热点内容是否突出<br>控件是否正常使用<br>对于必须但未安装的控件，是否提供自动下载并安装的功能<br>文字检查<br>性能测试<br>一般从以下两个方面考虑：<br>压力测试；负载测试；强度测试<br>数据库测试要具体决定是否需要开展。数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。</p>
<p>安全性测试：</p>
<p>基本的登录功能的检查<br>是否存在溢出错误，导致系统崩溃或者权限泄露<br>相关开发语言的常见安全性问题检查，例如SQL注入等<br>如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者获取支持<br>兼容性测试，<br>根据需求说明的内容，确定支持的平台组合：<br>浏览器的兼容性；<br>操作系统的兼容性；<br>软件平台的兼容性；<br>数据库的兼容性<br>开展测试，并记录缺陷。合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系（例如，需求变更、风险、配置、测试文档、缺陷报告、人力资源等内容）。<br>定期评审，对测试进行评估和总结，调整测试的内容。</p>
<h3 id="App测试用例"><a href="#App测试用例" class="headerlink" title="App测试用例"></a>App测试用例</h3><p>（1）APP的功能性测试<br>功能测试都是我们首要测试的，只有功能实现了才算符合上线发布的最低标准。我们需要检测产品功能是否已实现、产品功能是否符合设计要求、产品功能是否有重复、产品是否有重复的功能<br>（2）APP易用性测试<br>检测界面是否美观、操作是否简单易用，符合用户的操作行为、产品是否有相关的帮助文档<br>（3）APP兼容性测试<br>检测与本地及主流APP是否兼容、各设备是否兼容（不同手机屏幕分辨率的兼容性、不同手机品牌的兼容性、不同手机操作系统的兼容性）<br>（4）APP交叉事件测试（也属于功能测试的范畴）<br>检测APP运行时前&#x2F;后台切换是否影响正常功能、APP运行时拨打&#x2F;接听电话APP是否能正常响应、APP运行时发送&#x2F;接收信息APP是否能正常响应、<br>APP运行时发送&#x2F;收取邮件APP能否正常响应、APP运行时浏览网络能否正常响应、APP运行时使用蓝牙传送&#x2F;接收数据APP是否能正常响应<br>（5）APP安全性测试<br>检测软件是否有正规的数字签名、软件程序是否有加密、敏感数据是否有脱敏显示、数据传输时是否有加密、安全性漏洞、系统漏洞<br>（6）APP可靠性测试<br>验证程序中影响软件可靠性的故障，并排除故障实现软件可靠性增长、验证软件当前的可靠性水平是否满足用户的要求、验证软件的数据备份、恢复<br>（7）APP性能测试<br>检测程序在正常情况、峰值情况下的系统的各项性能指标是否正常。性能指标主要有：响应时间（应用响应时间从发出请求开始到客户端接收到响应所消耗的时间）、最大并发用户数、吞吐量、CPU内存占用、耗电量、流量</p>
<h3 id="一个口罩测试用例"><a href="#一个口罩测试用例" class="headerlink" title="一个口罩测试用例"></a>一个口罩测试用例</h3><ul>
<li>测试一个口罩<br>我当时从性能、功能、外观、系统、压测、运输、易用性、移植性等测试的，然后反问环节面试官说我对测试基础知识不太了解。。。他也没问我测试方法，就测试一个口罩，不知道为什么就被贴标签了。。。而且我看网上都是这么测的，也没标准答案，大家可以讨论一下</li>
</ul>
<p>后来我想到这么测<br>大方向 单元测试（把口罩拆成各个部分）、集成（不同单元组合测试）、系统（性能、功能、外观、系统、压测、运输、易用性、移植性等）、回归、验收 前三步可以穿插黑盒白盒测试方法，总结起来就是你知道啥流程、方法都套进去，估计那个面试官想让我这么测，这个方法还是搜集了很多资料慢慢总结出来的</p>
<h3 id="洗衣机测试用例"><a href="#洗衣机测试用例" class="headerlink" title="洗衣机测试用例"></a>洗衣机测试用例</h3><p>功能测试：该洗衣机是否能正常的洗衣服，能否预约，按钮设置是否都可用等等等<br>需求测试：查看洗衣机的使用说明书和安全说明书等<br>性能测试：使用时用电量如何，是否满足用户需求<br>界面测试：洗衣机的外观是否满足客户的需求<br>易用测试：该洗衣机是否容易操作<br>兼用性测试：该洗衣机除了能洗衣服以外还能洗别的吗<br>安全性测试：该洗衣机通电以后人接触以后是否有电，童锁<br>负载测试：通过逐步增加系统负载，最终确定在什么负载条件下系统性能将处于崩溃状态，以此获得系统能提供的最大服务<br>压力测试：通过逐步增加系统负载，最终确定在什么负载条件下系统性能将处于崩溃状态，以此获得系统能提供的最大服务级别的测试。<br>稳定性测试：加到一定的衣服然后过一段时间看洗衣机是否正常洗</p>
<h3 id="电梯测试用例"><a href="#电梯测试用例" class="headerlink" title="电梯测试用例"></a>电梯测试用例</h3><p>1.功能测试：上升、下降、停止、开门、关门、梯内电话、灯光、指示灯等；<strong>每个单元测试后进行集成测试。</strong><br>2.性能测试：速度、反应时间、关门时间等；<br>3.压力测试：超载、尖锐物碰撞电梯壁等；<br>4.安全测试：停电、报警装置、轿箱停靠位置、有人扒门时的情况等；<br>5.可用性：按键高度、操作是否方便、舒适程度等；<br>6.UI测试：美观程度、光滑程度、形状、质感等；<br>7.稳定性测试：长时间运行情况等；<br>8.兼容性测试：不同电压是否可工作、不同类型电话是否可安装等。</p>
<p>功能测试：<br>1.测试电梯能否实现正常的上升和下降功能。<br>2.电梯的按钮是否都可以使用。<br>3.电梯门的打开，关闭是否正常。<br>4.报警装置是否可用。<br>5.<strong>与其他电梯之间是否协作良好。</strong><br>6.通风状况如何。<br>7.突然停电时的情况。<br>8.上升途中的响应。<br>1）电梯本来在1楼，如果有人按18楼，那么电梯在上升到5楼的时候，有人按了10楼，这时候是否会在10楼先停下来；<br>2）电梯下降到10层时显示满员，此时若8层有人等待电梯，是否在8层停。<br>9.<strong>是否有手机信号</strong></p>
<p>安全性：<br>1.门关上的一刹那出现障碍物。<br>2.同时按关门和开门按钮。<br>3.点击当前楼层号码<br>4.多次点击同一楼层号码<br>5.同时按上键和下键</p>
<p>易用性：<br>电梯的按钮的设计符合一般人的习惯吗<br>用户文档：<br>使用手册是否对电梯的用法、限制、使用条件等有详细的描述<br>压力测试：<br>1.看电梯的最大承重量，在负载过重时报警装置是否有提醒<br>2.在一定时间内不断让电梯上升、下降<br>稳定性测试：<br>看电梯在最大负载下平稳运行的最长时间</p>
<h3 id="判断IP地址是否合法的测试用例"><a href="#判断IP地址是否合法的测试用例" class="headerlink" title="判断IP地址是否合法的测试用例"></a>判断IP地址是否合法的测试用例</h3><p><a href="https://www.cnblogs.com/mrwuzs/p/8028373.html">https://www.cnblogs.com/mrwuzs/p/8028373.html</a>  看这个！！！打开链接看</p>
<p>等价类划分</p>
<p>首先把IP地址分成有效可用的IP地址和有效但不可用的IP地址两个<strong>等价类</strong>；其中有效可用的IP地址中包括IP地址的A，B，C三类地址，有效但不可用的IP地址包括D、E两类IP地址和A、B、C三类地址中的全网地址、广播地址以及回环地址。</p>
<p>如果是有效的 IPv4 地址，有效可用，有效不可用，（边界值等等）<br>如果是有效的 IPv6 地址<br>无效的</p>
<h3 id="测试人脸识别系统"><a href="#测试人脸识别系统" class="headerlink" title="测试人脸识别系统"></a>测试人脸识别系统</h3><p>功能测试<br>界面测试<br>性能测试<br>安全性测试<br>兼容性测试</p>
<p>人脸识别设计到AI的两个概念：<br>计算机视觉（机器视觉）和生物识别。由此展开测试寻找测试点<br>AI测试与传统测试的异同点：<br>AI测试需要结合AI架构，算法，应用场景等针对测试。<br>这里的人脸查准率和人脸设定阈值有关系<br>设定阈值的过程就是模型评估，阈值设定越低，通过率越高，误报率越低<br>阈值设置越高，通过率越低，误报率越高</p>
<p><strong>一、功能测试</strong><br>1、启动系统，是否能跳转到正确的页面<br>2、人脸检测<br>人脸&#x2F;非人脸（拍摄的不是人脸，结果的验证<br>对人脸属性进行验证(年龄、性别、种族、表情、脸型、是否戴眼镜)<br>照相功能、打开摄像头功能、关闭摄像头功能、按钮的验证<br>检测状态(动态和静态)（静态指图片，动态指活体检测）<br>光线(强弱、顺逆)<br>人脸截取是否合理（拍摄人脸面积的不同，结果的验证<br>单脸&#x2F;多脸检测（拍摄多个人，结果的验证；多次拍摄同一个人的照片,结果的验证<br>检测距离、距离远近与结果的关系<br>检测姿势(拍摄角度不同，结果的验证<br>遮挡&#x2F;衣着影响（同一个人穿衣不同，结果的验证<br>抓拍&#x2F;正常拍<br>3、人脸对比<br>选择&#x2F;上传图片，图片类型、路径、大小、清晰度、像素、按钮验证<br>显示图片，与上传图片是否一致、显示顺序<br>两次传入同一张图<br>传入图像的类型不符合<br>后台做增删查改后再次人脸验证<br>按钮验证<br>结果的验证：<br>    上传同一张图像<br>    上传不同的图像<br>    上传不是人脸图像的结果验证<br>4、异常检测<br>网络测试：断网、弱网、网络正常<br>中断测试：<br>占用摄像头(拍摄、录像、关闭摄像头)<br>系统没电、断网、系统故障、系统更新（中断测试<br>手机来短信，来电话<br>系统重启、系统卡死（中断测试<br>系统版本升级（中断测试<br>不合法图片or选择不是人脸图像的文件上传</p>
<p>提示语：执行不同功能，后台消息打印的验证</p>
<p><strong>二、界面测试</strong></p>
<ol>
<li>查看界面<strong>是否显示正确，布局是否合理</strong></li>
<li>界面是否<strong>简单，美观</strong></li>
<li>界面文字是否显示清晰，图片和图标显示正常</li>
<li>是否有<strong>错别字</strong></li>
<li>操作过程中出现的<strong>各种提示显示正常</strong>。</li>
<li>按钮、控件是否整齐，长度高度是否符合要求</li>
<li>界面的<strong>设计风格</strong>，<strong>颜色搭配是</strong>否合理，是否符合UI设计风格</li>
</ol>
<p><strong>三、性能测试</strong></p>
<ol>
<li>检测速度、响应速度</li>
<li>精准率</li>
<li><strong>多人检测的响应时间测试。</strong></li>
<li>高并发场景，模拟多用户同时进入人脸识别系统检测</li>
<li>频繁进行人脸识别，是否易卡顿、崩溃</li>
<li><strong>弱网测试（地铁，高铁，山区）延时，丢包，fiddler，弱网时加购的响应时间</strong>.<br>延时——超时, 2min之内没有收到请求;合理性提示.<br>丢包——系统2min之内，没有上传到服务器，做失败处理;重发机制</li>
<li><strong>不同网速下的响应时间</strong>3g,4g,5G,WIFI、热点，不同运营商网络</li>
<li>网络延迟，断网的响应结果</li>
</ol>
<p><strong>四、安全性测试</strong><br>活体检测、连续检测、3D检测</p>
<ol>
<li>活体检测：判断用户是否为正常操作，通过指定用户做随机动作，一般有张嘴、摇头、点头、凝视、眨眼等等，防止照片攻击。 判断用户是否真实在操作，指定用户上下移动手机，防止视频攻击和非正常动作的攻击。</li>
<li>3D检测：验证采集到的是否为立体人像，能够防止平面照片、不同弯曲程度的照片等。</li>
<li>连续检测：通过连续的检测，验证人脸运动轨迹是否正常，防止防止跳过活体检测直接替换采集的照片，也能够防止中途切换人。</li>
</ol>
<p><strong>五、兼容性测试</strong></p>
<ol>
<li><strong>不同手机型号，不同手机操作系统</strong>，是否都可以进行正常的识别功能（安卓系统、ios系统，主流的系统版本需要测试覆盖）</li>
<li><strong>不同的电脑机型，不同的电脑操作系统</strong>（win7,8,10,mac,linux</li>
<li><strong>不同的人脸识别系统版本</strong></li>
<li>不同的分辨率下显示是否正常。</li>
<li><strong>不同语言环境下，页面的显示是否正确，是否支持多种语言版本</strong></li>
</ol>
<hr>
<p>微信注册页面密码的测试用例编写</p>
<p><a href="https://www.cnblogs.com/niuniu0328/p/14721497.html">https://www.cnblogs.com/niuniu0328/p/14721497.html</a></p>
<p><strong>要求：</strong> 6~18位且由数字和字母组成，注册成功,跳转页面；注册失败，请重新输入密码</p>
<ol>
<li>画思维导图</li>
</ol>
<img src="https://img2020.cnblogs.com/blog/1890611/202104/1890611-20210430113231014-818663855.png" alt="img" style="zoom:50%;" />

<ol start="2">
<li>excel编写测试用例</li>
</ol>
<p><img src="https://img2020.cnblogs.com/blog/1890611/202104/1890611-20210430114549487-1107512808.png" alt="img"></p>
<h2 id="☆☆☆定位bug、定位前后端问题☆☆☆"><a href="#☆☆☆定位bug、定位前后端问题☆☆☆" class="headerlink" title="☆☆☆定位bug、定位前后端问题☆☆☆"></a>☆☆☆定位bug、定位前后端问题☆☆☆</h2><p>什么情况下用数据库，Linux，fiddler</p>
<p>用数据库</p>
<ul>
<li>修改数据，方便测试</li>
<li>校验数据落地，比如你充值了1万，页面显示你充值成功，所以到底成没成功，要去看数据库</li>
</ul>
<p>用Linux</p>
<p>（Xshell连Linux，cd到日志存放的地方，一般日志分小时去切割，日志号一般般根据设备号或者手机号去筛选</p>
<ul>
<li>查看日志</li>
<li>埋点&#x2F;打点测试，比如要新增两个功能，读书，看视频，想看有多少人点击了，收集行为，每点一个按钮，都会发送日志，向后台发送json，应该是点一次打一个，需要看有没有多打，点一次打三个就是bug了</li>
</ul>
<p>用fiddler，charles</p>
<ul>
<li>手工测不出来</li>
<li>看重要请求有没有加密，能不能篡改</li>
<li>请求会不会重复发送（滴滴打车，会不会同时呼叫了好几个司机</li>
</ul>
<p>抓包的方式，获取请求数据和响应的数据，然后去对应开发人员提供的接口文档</p>
<p>如果请求数据有问题，那么这就是客户端的问题，如果在这种情况下还是无法定位这个bug的话，</p>
<p>可以通过接口测试的方式来定位，比如说登录功能，正确的用户名正确的密码，如果用app来登录的话，提示失败</p>
<p>而使用接口测试的方式来进行登录的话，提示成功，这种情况下就可以判断出，这个bug是属于前端的bug</p>
<h3 id="成功购买后，查看订单有商品没有显示出来"><a href="#成功购买后，查看订单有商品没有显示出来" class="headerlink" title="成功购买后，查看订单有商品没有显示出来"></a>成功购买后，查看订单有商品没有显示出来</h3><p>假设你在某购物网站上购买了两件商品，一件打折的，一件不打折，当你下完订单并且成功支付之后，再次去我的订单中查看订单内容时，发现两件商品，只显示出来一件， 而打折的商品并没有显示出来。</p>
<p><strong>1、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看购买记录和订单相关的日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果显示出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以再去看数据库</li>
</ul>
<p><strong>2、查看数据库，一些select查询语句</strong></p>
<ul>
<li>查看订单表数据是否正常<ul>
<li>如果数据库没有记录，说明是后端的问题（因为，你已经下完订单并且成功支付了</li>
<li>如果数据库有记录，可以去抓包</li>
</ul>
</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<ul>
<li>抓前端查看订单请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="如果出现加入购物车商品，再结账时不正确，怎么定位异常？"><a href="#如果出现加入购物车商品，再结账时不正确，怎么定位异常？" class="headerlink" title="如果出现加入购物车商品，再结账时不正确，怎么定位异常？"></a>如果出现加入购物车商品，再结账时不正确，怎么定位异常？</h3><p><strong>1、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看加入购物车记录和订单相关的日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果显示出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以再去看数据库</li>
</ul>
<p><strong>2、查看数据库，一些select查询语句</strong></p>
<ul>
<li>查看加入购物车商品数据是否正常<ul>
<li>如果数据库没有记录，说明是后端的问题（因为，你已经加入购物车，但是数据库里没有</li>
<li>如果数据库有记录，可以去抓包</li>
</ul>
</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<ul>
<li>抓前端查看订单请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="如果A给B评论了但是没显示可能是什么原因造成的（例如微信评论）"><a href="#如果A给B评论了但是没显示可能是什么原因造成的（例如微信评论）" class="headerlink" title="如果A给B评论了但是没显示可能是什么原因造成的（例如微信评论）"></a>如果A给B评论了但是没显示可能是什么原因造成的（例如微信评论）</h3><p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong>是谁没显示？排除网络问题先</p>
<p><strong>3、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看发送评论请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果渲染出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="视频不能播放了，定位错误"><a href="#视频不能播放了，定位错误" class="headerlink" title="视频不能播放了，定位错误"></a>视频不能播放了，定位错误</h3><p>排除本身网络的问题，先确保网络连接通畅。</p>
<p>前端APP崩溃，肯定前端的问题</p>
<p>如果是别的问题，通过抓包分析</p>
<ul>
<li>抓前端请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>如果后端返回的值正确的话，就查看前端读取值进行处理读取的是否正确</li>
</ul>
</li>
</ul>
<h3 id="朋友圈刷不出来了怎么排查"><a href="#朋友圈刷不出来了怎么排查" class="headerlink" title="朋友圈刷不出来了怎么排查"></a>朋友圈刷不出来了怎么排查</h3><p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong></p>
<p>如果切换网络测试，其他app应用都能正常访问，那么说明是微信服务器的问题</p>
<p><strong>2、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志的话，分别查看朋友圈请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果显示出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="点击购买后页面加载不出来，怎么排查？"><a href="#点击购买后页面加载不出来，怎么排查？" class="headerlink" title="点击购买后页面加载不出来，怎么排查？"></a>点击购买后页面加载不出来，怎么排查？</h3><p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong></p>
<p>如果切换网络测试，其他app应用都能正常访问，那么说明是服务器的问题</p>
<p><strong>2、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志的话，分别查看购买的请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果显示出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="微信抢红包测试，如果按钮失灵怎么定位问题"><a href="#微信抢红包测试，如果按钮失灵怎么定位问题" class="headerlink" title="微信抢红包测试，如果按钮失灵怎么定位问题"></a>微信抢红包测试，如果按钮失灵怎么定位问题</h3><p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong></p>
<p>2、排除手机故障问题，排除屏幕失灵问题</p>
<p><strong>3、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看抢红包请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果渲染出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上</li>
</ul>
</li>
</ul>
<h3 id="有用户反应邀请好友给她砍一刀没有成功怎么排查"><a href="#有用户反应邀请好友给她砍一刀没有成功怎么排查" class="headerlink" title="有用户反应邀请好友给她砍一刀没有成功怎么排查"></a>有用户反应邀请好友给她砍一刀没有成功怎么排查</h3><p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong></p>
<p><strong>2、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看砍价的请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果渲染出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、查看数据库，一些select查询语句</strong></p>
<ul>
<li>查看加入砍价商品的数据是否正常<ul>
<li>如果数据库没有记录，说明是后端的问题（因为，前端已经显示砍价成功，但是数据库里没有记录</li>
<li>如果数据库有记录，可以去抓包</li>
</ul>
</li>
</ul>
<p><strong>4、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染，显示在页面上，没成功，但是显示砍价成功，这就是错误的渲染</li>
</ul>
</li>
</ul>
<h3 id="用户反映你开发的网站访问很慢可能会是什么原因。"><a href="#用户反映你开发的网站访问很慢可能会是什么原因。" class="headerlink" title="用户反映你开发的网站访问很慢可能会是什么原因。"></a>用户反映你开发的网站访问很慢可能会是什么原因。</h3><p>（1）可能的原因一：服务器出口带宽不够用。这是一个很常见的瓶颈。一方面，可能是本身购买的服务器出口带宽就很小（企业购买带宽相当昂贵），一旦用户访问量上来了，并发量大了，自然均分给用户的出口带宽就更小了，所以某些用户的访问速度就会下降了很多。另一个，就是跨运营商网络导致带宽缩减，例如很多公司的网站（服务器）是放在电信的网络上的，而如果用户这边对接的是长城或者说联通的宽带，运营商之间网络传输在对接时是会有限制的，这就可能导致带宽的缩减。</p>
<p>（2）可能原因二：服务器负载过大忙不过来，比如说CPU和内存消耗完了，这个容易理解，不展开。</p>
<p>（3）可能原因三：网站的开发代码没写好，例如mysql语句没有进行优化，导致数据库的读写相当耗费时间。</p>
<p>（4）可能原因四：数据库的瓶颈，也是很常见的一个瓶颈，这点跟上面第三个原因可以一起来说。当我们的数据库变得愈发庞大，比如好多G好多T这么大，那对于数据库的读写就会变得相当缓慢了，索引优化固然能提升一些效率，但数据库已经如此庞大的话，如果每次查询都对这么大的数据库进行全局查询，自然会很慢。这个学过数据库的话也是挺容易理解的。</p>
<p>二、针对上面可能的原因，有哪些方法和工具去检测呢：</p>
<p>（1）某个用户反馈网站访问变慢，怎么去定位问题。首先你自己也打开下网站，看是否会出现用户反映的问题，如果你这边访问没问题，那就可能是用户那边的问题了，这块就是要先确定是用户那一方的问题还是自身比如说服务器或者网站的问题。</p>
<p>（2）发现确实是自己服务器或者网站的问题，那么可以利用浏览器的调试功能（一般浏览器都会有），调试网络看看各种数据加载的速度，哪一项消耗了多少时间都可以看到，是哪块数据耗时过多，是图片加载太慢，还是某些数据加载老半天都查不出来。</p>
<p>（3）然后针对服务器的负载情况，可以去查看下服务器硬件（网络带宽、CPU、内存）的消耗状况。带宽方面查看流量监控看是不是已经到了峰值，带宽不够用了，如果是公司自己买服务器搭的网站服务器的话，需要自己搭建监控环境；如果用的是阿里云腾讯云这些的，那这些平台那边会提供各方面的监控比如CPU、带宽等等，在后台就可以看到了。</p>
<p>（4）如果发现硬件资源消耗都不高，都比较充裕，那要去看看是不是程序的问题了。这个可以通过查日志来找，比如PHP日志、Apache日志、mysql日志等等的错误日志，特别如mysql有个慢查询的日志功能，可以看到是不是某条mysql语句特别慢，如果某条语句花的时间太长，那这条语句很有可能有问题。</p>
<p>（5）至于说到的数据库太庞大，这个直接看就看得到了，比如一个表的文件大小变得特别大了。</p>
<p>三、针对上面的这些问题，有哪些解决和优化的办法呢：</p>
<p>（1）出口带宽的问题，这个很简单，加带宽，有钱就多买带宽，很简单。</p>
<p>（2）mysql语句优化，开发人员职责。</p>
<p>（3）数据库太庞大，为了读写速度，进行“拆表”、“拆库”，就是把数据表或者数据库进行拆分。</p>
<p>（4）上面的拆库拆表都是针对数据库实在太庞大才会这样做，一般在此之前会有其他优化方法，比如mysql的主从复制，一台主服务器专门用于写，然后其他从服务器用来读，写完之后会同步更新到其他读的服务器中。例如阿里的双十一活动，都不知道用了多少万台服务器一起在扛着。</p>
<p>（6）还有这几年用得比较多的非关系型数据库，它使用了缓存机制，它把数据缓存到了内存，用户访问数据直接从内存读取，读取速度就比在磁盘中读取快了很多，还有它的一个key-value读取机制。</p>
<p>（7）CDN（content-delivery-network：内容分发网络），鸡蛋放在多个篮子里，把数据放在离用户更近的位置（例如网站的一些静态文件比如图片或者js脚本），用户访问时判断IP来源是广州，那就通过智能DNS解析到广州的服务器上，直接从广州的篮子里去获取数据，速度就快了。这里有个静态数据和动态数据的概念，例如图片和一些js文件一般是不变的，那就可以把它们的映像分布到全国各地，加快速度，而一些需要在网站后台动态产生的一些数据，则需要去到网站所在的服务器去产生并得到。这个涉及到两种数据的显示的问题，这就交由浏览器处理了。同时异步加载的技术例如前端的Ajax技术，异步请求数据，可以使这些动态数据延迟加载，这块自己不怎么了解，可能表述不好。前端开发的人员应该更懂一些。</p>
<p>（8）上面都没有说到架构的优化，如果网站扛不住，是不是网站架构已经不能适应了，比如做个小博客把数据库服务器和web服务器都用同一台服务器，那所有负载都在同一台服务器上了。但是访问量上来扛不住了，就得加服务器了，就得在架构上优化了，比如在数据库上做集群，在web服务器上也做集群，比如web服务器集群，在服务器前面加一个负载均衡，负载均衡就是专门负责分发，把用户的请求均匀分布到各个服务器上。</p>
<h3 id="浏览器打不开是什么原因？（输入一个URL，但是没有访问到预期的网站"><a href="#浏览器打不开是什么原因？（输入一个URL，但是没有访问到预期的网站" class="headerlink" title="浏览器打不开是什么原因？（输入一个URL，但是没有访问到预期的网站"></a>浏览器打不开是什么原因？（输入一个URL，但是没有访问到预期的网站</h3><p>1.网络断开了<br>2.是否数据库问题<br>3.是否被攻击了，网页被劫持了。请求或者响应在网络传输中途被劫走了<br>4.DNS无法解析网址<br>5.服务器负载过大，服务器是不是挂了，服务器拒绝访问<br>6.链路本身问题，供应商网络出口出现问题</p>
<p><strong>1、排除本身网络的问题，先确保网络连接通畅。</strong></p>
<p><strong>2、有权限的话，查看服务器日志</strong>，grep,tail等命令 </p>
<ul>
<li>有日志话，分别查看访问的请求与响应的相关日志</li>
<li>查看前端请求是否正常<ul>
<li>请求不正确，前端的问题</li>
<li>请求参数正确<ul>
<li>查看服务器返回的结果<ul>
<li>如果服务器返回结果错误，后端的问题</li>
<li>如果服务器端返回结果正确，前端的问题（因为，前端没有将正确的结果渲染出来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>没有日志的话，可以去抓包</li>
</ul>
<p><strong>3、抓包，用抓包工具，例如Fiddler、Charles</strong></p>
<p>从接口请求，参数，接口响应来分析</p>
<ul>
<li>抓前端查看请求<ul>
<li>前端<strong>是否发送请求</strong>，没有发送请求的话，说明是前端问题</li>
<li>如果前端发送了请求，查看前端发送的请求格式是否正确，<strong>请求参数错误，前端问题</strong></li>
<li>前端去调后端，请求是否接通。<strong>没接通，查看服务器是不是挂了</strong></li>
<li>如果<strong>请求参数正确</strong>，请求接通，可以正常连接，<strong>再去抓服务器返回结果</strong></li>
</ul>
</li>
<li>抓服务器返回结果<ul>
<li>服务器返回数据错误，后端问题</li>
<li>服务器返回数据正确，前端问题（因为，前端没有将正确的结果渲染</li>
</ul>
</li>
</ul>
<h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><h3 id="接口测试用例设计思路（支付为例"><a href="#接口测试用例设计思路（支付为例" class="headerlink" title="接口测试用例设计思路（支付为例"></a>接口测试用例设计思路（支付为例</h3><p>通用信息校验：如检查URL，请求方法，请求头，接口鉴权<br>接口参数校验：检查参数长度，类型，有效性等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210802174556676.png" alt="image-20210802174556676"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210802180655735.png" alt="image-20210802180655735"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210802182434137.png" alt="image-20210802182434137"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210802183648664.png" alt="image-20210802183648664"></p>
<h3 id="什么是接口测试"><a href="#什么是接口测试" class="headerlink" title="什么是接口测试"></a>什么是接口测试</h3><p>接口测试其实最主要的<strong>验证接口逻辑，可用性，边界值，异常检查.</strong></p>
<p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等（通俗来说就是，检查业务逻辑是否满足业务需求，校验字段是否正常你实际结果是否满足预期）</p>
<p>一般来说，测试接口，就是指测试接口的功能，性能和稳定性测试，当然可能还有安全性测试。<br><strong>一般来说我们听说到的接口基本上都是指HTTP或者HTTPS协议的接口测试，也就是一些web服务请求。</strong></p>
<p>一个软件项目中，有很多接口，少的有几十个，多的有几百上千个接口。<br>这个时候，我们没有软件界面，没有具体的测试场景，<strong>只有一个接口描述文档</strong>。</p>
<p>我们需要把接口这样抽象的东西，通过软件测试的理论和方法去测试接口，找出接口的功能和安全性的缺陷。接口有内部接口和外部接口。内部接口就是开发人员自己开发的接口。外部接口，好比网站调用微信支付和支付宝支付接口。还有一些模块与模块之间的接口。</p>
<h3 id="为什么要做接口测试"><a href="#为什么要做接口测试" class="headerlink" title="为什么要做接口测试"></a>为什么要做接口测试</h3><p>1、<strong>现在很多系统前后端架构是分离的，因为不同端（前段，后端）的工作进度不一样</strong>，所以我们要针对最开始出来的接口，以及需要调用其他公司的（银行，支付宝，微信，qq等）一些接口进行接口测试及验证数据。</p>
<p>从安全层面来说，只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前端太容易了）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。在这种情况下就需要从接口层面进行验证。前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。</p>
<p>2、如今系统越来越复杂，传统的靠前端测试已经大大降低了效率，而且现在我们都推崇测试前移也叫测试左移，<strong>希望测试能更早的介入，那接口测试就是一种及早介入的方式</strong>。例如<strong>传统测试，你是不是得等前后端都完成你才能进行测试</strong>，才能进行自动化代码编写。 而<strong>如果是接口测试，只需要前后端定义好接口，那这时自动化就可以介入编写接口自动化测试代码</strong>，手工测试只需要后端代码完成就可以介入测试后端逻辑而不用等待前端工作完成。</p>
<p>举例：</p>
<p>例如一个登陆接口，例如产品上规定用户名6-10个字符数字下划线，但后端没做判断。但我们业务人员测试肯定验证，但只是前端做了校验，后端压根就忘了这个小需求。那么后果来了如果一个懂的直接抓包去篡改你的接口，然后绕过校验，通过sql注入直接随意登录。如果你这是一个下单业务，是不是给公司造成了很大损失</p>
<h3 id="接口的组成："><a href="#接口的组成：" class="headerlink" title="接口的组成："></a><strong>接口的组成：</strong></h3><p>a、接口说明</p>
<p>b、调用url（请求的地址）</p>
<p>c、请求方法（get\post）</p>
<ul>
<li><p>GET提交的数据显示在地址栏，不安全;提交的数据量有限制;不重要的数据使用GET</p>
</li>
<li><p>POST隐式提交数据，更安全;没有数据量大小的限制;重要数据使用POST</p>
</li>
</ul>
<p>d、请求参数、参数类型、请求参数说明</p>
<p>e、返回参数说明</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720210113729.png" alt="image-20210720210113729" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210720210243222.png" alt="image-20210720210243222" style="zoom:50%;" />

<h3 id="怎么测："><a href="#怎么测：" class="headerlink" title="怎么测："></a><strong>怎么测：</strong></h3><p>A. 用例设计（根据业务逻辑来设计用例，登录5次，需要2分钟后再登录 删除关注的车，列表少一条数据）</p>
<p>B. 参数组合（传入不同值）</p>
<p>C. 接口安全（绕过验证&#x2F;绕过身份验证&#x2F;参数是否加密等）</p>
<p>D. 异常验证（输入异常参数边界值）</p>
<h3 id="用什么工具测"><a href="#用什么工具测" class="headerlink" title="用什么工具测"></a><strong>用什么工具测</strong></h3><p>功能：Postman&#x2F;HTTPrequest&#x2F;jemter</p>
<p>自动化：restassured&#x2F; <a href="http://www.elecfans.com/tags/python/">python</a> httprequest</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="什么是性能测试？"><a href="#什么是性能测试？" class="headerlink" title="什么是性能测试？"></a><strong>什么是性能测试？</strong></h3><p>性能测试，顾名思义，就是测试软件性能方面的质量，它是一种非功能性的测试。</p>
<p>在整个测试中，应用程序的性能在预期的或更高的负载下进行评估。评估系统的不同性能属性，如<strong>响应时间</strong>（速度）、<strong>吞吐量</strong>、可靠性、<strong>资源使用率</strong>、可扩展性等。<strong>监控系统的各项指标，是否符合需求</strong>，如果不符合，就发现了系统的性能瓶颈</p>
<h3 id="性能测试的分类（负载、压力、容量、并发、配置、可靠性持久性"><a href="#性能测试的分类（负载、压力、容量、并发、配置、可靠性持久性" class="headerlink" title="性能测试的分类（负载、压力、容量、并发、配置、可靠性持久性"></a>性能测试的分类（负载、压力、容量、并发、配置、可靠性持久性</h3><ul>
<li><p><strong>负载测试：</strong>通过在被测系统上不断加压（如逐渐增加模拟用户的数量），直到性能指标达到极限，<strong>来观察不同负载下系统的响应时间和数据吞吐量、系统占用的资源（如CPU、内存）等</strong>。</p>
<ul>
<li>看你在什么时候已经超出“需求”或系统崩溃。</li>
<li>以检验系统的行为和特性，以发现系统可能存在的性能瓶颈、内存泄漏、不能实时同步等问题。负载测试更多地体现了一种方法或一种技术。</li>
<li>这种性能测试方法需要在给定的测试环境下进行，<strong>通常也需要考虑被测试系统的业务压力量和典型场景</strong>、使得测试结果具有业务上的意义。</li>
</ul>
</li>
<li><p><strong>压力测试：</strong>系统在强负载（大数据量、大量并发用户等）下的测试，例如cpu、内存在饱和使用情况下，看系统在峰值使用情况下是否稳定，看系统处理的会话能力以及哪里会出问题。</p>
<ul>
<li>从而有效地发现系统的某项功能隐患、系统是否具有良好的容错能力和可恢复能力。</li>
</ul>
</li>
<li><p><strong>容量测试：</strong>通过测试预先分析出系统<strong>某项指标的极限值</strong>（如最大并发用户数、数据库记录数等）</p>
<ul>
<li><p>容量测试是面向数据的，并且它的目的是显示系统可以处理目标内确定的数据容量</p>
<ul>
<li><p><strong>例：一个人背X斤。</strong></p>
<p><strong>负载测试：</strong>200斤情况下，是否能坚持5分钟。</p>
<p><strong>压力测试：</strong>200,300,400… 斤情况下，他的表现，什么时候失败，失败之后什么表现，重新扛200是否正常。</p>
<p><strong>容量测试：</strong>在坚持5分钟的情况下，他一次最多能扛多少斤。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发测试：</strong>模拟多用户<strong>并发</strong>访问<strong>同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题</strong></p>
</li>
<li><p><strong>配置测试：</strong>通过对被测系统软硬件环境的调整，了解各种不同环境对系统性能影响的程度，从而找到系统各项资源的最优分配原则</p>
<ul>
<li>关注点是“微调”，通过对软硬件的不段调整，找出他们的最佳状态，使系统达到一个最强的状态。</li>
</ul>
</li>
<li><p><strong>可靠性测试(持久性测试)：</strong>给系统施加一定的业务压力，让其持续运行一段时间，测试在这种条件下能否稳定运行。</p>
<ul>
<li>关注点是“稳定”，不需要给系统太大的压力，<strong>只要系统能够长期处于一个稳定的状态</strong>。</li>
<li>通常可以测试出系统是否有内存泄露的问题。</li>
</ul>
</li>
</ul>
<h3 id="性能测试常用指标（并发数、响应时间、吞吐量、资源利用率"><a href="#性能测试常用指标（并发数、响应时间、吞吐量、资源利用率" class="headerlink" title="性能测试常用指标（并发数、响应时间、吞吐量、资源利用率"></a>性能测试常用指标（并发数、响应时间、吞吐量、资源利用率</h3><p>并发数</p>
<ul>
<li><strong>并发用户数</strong>：指同一时间点向系统提交请求的用户数</li>
<li>在线用户数：某段时间内访问系统的用户数。这些用户并不一定同时向系统提交请求</li>
<li>系统用户数: 系统注册的总用户数据</li>
</ul>
<p><strong>响应时间：</strong>用户发送一个请求到用户接收到服务器的响应数据这段时间</p>
<ul>
<li>响应时间&#x3D;网络传输(请求)时间+服务器处理(一层或多层)时间+网络传输(响应) 时间+页面前端解析渲染时间</li>
</ul>
<p><strong>吞吐量</strong>：一段时间内系统处理用户（客户端）请求的数量</p>
<ul>
<li>计算单位: 一般用请求数&#x2F;秒作为吞吐量的单位。从业务角度来说也可使用访问人数&#x2F;天，或者页面访问量&#x2F;天作为单位</li>
<li>吞吐量逐渐达到饱和：意味着系统的一种或多种资源利用达到的极限。通常可以利用拐点来进行性能测试分析和定位</li>
</ul>
<p><strong>资源利用率：</strong>对不同系统资源的使用程度， 系统资源(CPU&#x2F;内存&#x2F;磁盘&#x2F;网络)使用占比(使用量&#x2F;总量*100%)</p>
<ul>
<li>利用率指标:(没有特殊要求情况下)<ul>
<li>CPU 不超过 75%-85%</li>
<li>内存不超过 80%</li>
<li>硬盘不超过 90%(容量占有率&#x2F;读写时间比)</li>
</ul>
</li>
</ul>
<h4 id="常用服务器资源指标（CPU、内存、磁盘、网络、TPS、QPS、HPS、PV、UV"><a href="#常用服务器资源指标（CPU、内存、磁盘、网络、TPS、QPS、HPS、PV、UV" class="headerlink" title="常用服务器资源指标（CPU、内存、磁盘、网络、TPS、QPS、HPS、PV、UV"></a>常用服务器资源指标（CPU、内存、磁盘、网络、TPS、QPS、HPS、PV、UV</h4><p>CPU处理器、MEM内存(临时保存)、IO磁盘 (永久保存)、网络(带宽)</p>
<img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210731223712119.png" alt="image-20210731223712119" style="zoom:55%;" />

<p>车间中加工原料，当车间中没有原料了，在从仓库中取原料，对原料进行加工；</p>
<p>内存本身有一定的存储空间，对内存中的数据进行处理的速度比从硬盘取数据再处理的速度快很多</p>
<ul>
<li><p>CPU指标主要指的CPU利用率，包括用户态(user)、系统态(sys)、等待态(wait)、空闲态(idle)。</p>
</li>
<li><p>内存是与CPU进行沟通的桥梁。<strong>计算机中所有程序的运行都是在内存中进行的</strong>，因此内存的性能对计算机的影响非常大</p>
</li>
<li><p><strong>CPU、MEM、IO之间的关系</strong><br>CPU对数据进行判断以及逻辑处理，本身不能存储数据；这时cpu从内存取数据进行逻辑计算，如果内存没有数据，才会从硬盘读数据到内存，再对数据进行处理。</p>
<p>当cpu进程等待，会造成内存开销的增加，内存不够用的时候会用到虚拟内存，导致虚拟内存的增加，这时磁盘IO开销就会增加，系统态sy%提升，cpu开销增加；内存里数据不够用，才用磁盘中取数据。</p>
</li>
<li><p>网络吞吐量简称为Network Throughput，是指在无网络故障的情况下单位时间内通过的网络的数据数量。单位为Byte&#x2F;s。网络吞吐量指标主要有每秒有多少兆流量进出。</p>
</li>
<li><p><strong>TPS(Transactions Per Second,每秒事务数)</strong> ：是单位时间内处理事务的数量 </p>
<ul>
<li>从代码角度来说,一段代码或多段代码可以组成一个事务。单位时间内完成的事务数越多,服务器的性能越好</li>
</ul>
</li>
<li><p>**QPS(Query Per Second,每秒查询数)**：QPS是单位时间内处理请求的数量</p>
<ul>
<li>比TPS划分的更细致一些，因为一个事务可能会包含多个请求。</li>
</ul>
</li>
<li><p><strong>TPS(每秒事务数) 和 QPS(每秒查询数)区别:</strong></p>
<ul>
<li>TPS代表一个事务的处理，可以包含了多次请求</li>
<li>TPS的一次事务代表一次用户操作到服务器返回结果，QPS的一次请求代表一个接口的一次请求到服务器返回结果。</li>
<li>当一次用户操作只包含一个请求接口时，TPS和QPS没有区别。</li>
<li>当用户的一次操作包含了多个服务请求时，这时候选TPS作为这次用户操作的性能指标更好。</li>
<li>例如：访问一个页面会请求服务器30次，一次访问，产生一个“TPS”，产生30个“QPS”</li>
</ul>
</li>
<li><p>**点击数HPS(每秒点击次数)**：是指发起请求时, 服务端 对请求 进行响应的页面资源 对应的请求数量</p>
<ul>
<li>每秒用户向web服务器提交的HTTP请求数，<strong>并非鼠标的一次单击操作，因为一次单击操作中，客户端可能向服务器发送多个HTTP请求</strong></li>
</ul>
</li>
<li><p>**PV(Page View, 页面访问量)**：访问一个URL，产生一个PV</p>
<ul>
<li>每日每个网站的总PV量是形容一个网站规模的重要指标</li>
</ul>
</li>
<li><p>**UV (Unique Visitor,用户访问量)**：作为一个独立的用户，访问站点的所有页面均算作一个UV</p>
</li>
</ul>
<h3 id="性能测试的目的-为什么要进行性能测试？"><a href="#性能测试的目的-为什么要进行性能测试？" class="headerlink" title="性能测试的目的?为什么要进行性能测试？"></a><strong>性能测试的目的</strong>?<strong>为什么要进行性能测试？</strong></h3><p>识别系统的弱点，评估系统能力，发现系统性能瓶颈，提高系统可靠性能和稳定性</p>
<p>进行性能测试主要是为了保障软件能够在期望的负载下运行良好，并且通过发现性能问题来消除应用程序的性能瓶颈。</p>
<p>●<strong>提供系统速度的度量</strong>；这些测试有助于对参数进行基准测试，如度量应用程序速度的响应时间，我们都知道，这对于应用程序的成功至关重要。</p>
<p><strong>●有助于评估应用程序的可扩展性；</strong>性能测试有助于检查应用程序是否有能力扩充更多的用户量。</p>
<p><strong>●有助于检查应用程序的健壮性</strong>；通过压力测试，我们可以检查应用程序在工作负载高于预期或高于应用程序阈值时的稳健性。</p>
<p><strong>●有助于检查应用程序的可靠性</strong>；进行不同类型的性能测试是为了检查应用程序是否可靠，是否提供了正确的和一致的输出。性能测试，如负载测试和耐久测试，有助于评估系统在预期的工作负载下的正确性。</p>
<h2 id="测试报告的内容"><a href="#测试报告的内容" class="headerlink" title="测试报告的内容"></a>测试报告的内容</h2><p>软件测试报告的组成：</p>
<p>一、概述<br>包括项目背景、需求分析</p>
<p>二、测试时间 测试人员、测试环境（设备）</p>
<p>投入了哪些人，用了多少时间，测试起止时间。</p>
<p>用到哪些测试手机，什么客户端环境，什么浏览器等等。</p>
<p>三、<strong>测试过程</strong><br>评审记录、测试内容、测试范围、测试用例</p>
<p>四、功能实现清单<br>列出是否已经按照测试计划实现功能</p>
<p>五、<strong>缺陷统计，缺陷分析</strong><br>测试缺陷统计；</p>
<p>测试用例执行情况统计（一共多少，执行了多少，未执行多少，通过多少，失败多少）</p>
<p>六、测试统计情况<br>资源统计、执行情况、问题统计、问题列表、遗留的问题</p>
<p>七、<strong>测试总结</strong><br>测试结论；（是否通过）<br>测试内容、测试用例的覆盖程度、bug的解决程度</p>
<p>八、测试风险</p>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h3><p>appium 1. 13之后安卓上默认的工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210816122713727.png" alt="image-20210816122713727"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210816123515564.png" alt="image-20210816123515564"></p>
<p><strong>appium的整体架构是C&#x2F;S模式，整体流程（返回顺序为逆向）：</strong></p>
<p><strong>脚本请求 ——&gt; 4723端口appium server ——&gt; 解析参数给PC端4724端口 ——&gt; 发送给设备4724端口 ——&gt; 通过设备4724端口发给bootstrap.jar ——&gt; Bootstrap.jar把命令发给uiautomator</strong></p>
<p>首先我们要开启appium服务，即Appium server，也就是在命令行用appium命令打开的东西，默认监听4723端口。4723端口专门和脚本打交道，基于WebDriver协议。</p>
<p>client 创建1个session，在该session中通过http向appium server发送请求，appium server解析请求，完成相应操作并返回response。</p>
<p>创建session成功之前，就已将bootstrap.jar放入手机中，并开启设备上的基于appium bootstrap的socket服务，绑定本机和boostrap通信的端口号4724用于和Android设备通讯，默认监听4724端口，等待client的连接。</p>
<p>Appium server将脚本的请求解析后给到4724端口，通过设备的4724端口转发解析后的请求， 此时，对于socket服务来说，appium server就充当了client的角色，appium server通过4724端口主动去请求设备上的socket服务，即向socket服务发送请求，即bootstrap.jar，Bootstrap.jar再把Appium的命令转换成uiautomator的命令来让uiautomator进行处理。有请求就有返回，socket接收到请求后会做出响应，原路返回给脚本，然后脚本再进行下一次的请求。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。appium和手机的通信过程,主要是数据交换的一个过程，socket的作用是就是为了实现双向通信，它需要一对端口号，对应到这里就是4724，手机端的bootstrap就是socket-server端，appium server就是socket-client端。</p>
<p>关于socket的通信原理，先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210816113126948.png" alt="image-20210816113126948" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/xxpt/Blog-photo/interviewQA/image-20210816114420267.png" alt="image-20210816114420267" style="zoom: 33%;" /></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>测试开发</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/02/09/txy/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用Github.io搭建自己的博客时可能会遇到访问速度不理想的情况，可以采用如下几种方案解决：</p>
<ol>
<li>将Hexo部署到<a href="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=q7cdej5p">阿里云</a>（<a href="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=q7cdej5p">点击查看</a>），直接访问阿里云，但这种方式会暴露自己服务器的ip，存在安全隐患，服务器的带宽也不一定能满足需求，可以参考<a href="https://zhuanlan.zhihu.com/p/58654392">https://zhuanlan.zhihu.com/p/58654392</a>，做完后要对<code> /home/git/hexo/hooks/post-receive</code>文件增加可执行权限</li>
<li>采用<a href="https://gitee.com/">Gitee</a>，速度有保证，但现在个人版不能自定义域名</li>
<li>采用Github.io，配置<a href="https://curl.qcloud.com/GBzCe7gA">腾讯云CDN</a>，新手可以获得六个月，每月20G的免费CDN流量。</li>
</ol>
<h3 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h3><p>假定你已经安装网上教程配置好了Hexo等步骤</p>
<ol>
<li><p>执行完<code>hexo d -g</code>后，在仓库中配置 Pages，参考<a href="https://sspai.com/post/54608">https://sspai.com/post/54608</a>，<strong>注意</strong>不要配置自定义域名，要在腾讯云CDN中配置。</p>
</li>
<li><p>此时你应该可以访问你的github.io页面了，例如：<a href="https://liu-hx.github.io/">https://liu-hx.github.io/</a>这种形式的</p>
</li>
<li><p>腾讯云CDN主要配置host和域名即可，参考下图<br><img src="https://img-blog.csdnimg.cn/603ce85b887944e8a5d54ac8f2996115.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAaGF0YWtlLjE4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li><p>域名设置解析<br><img src="https://img-blog.csdnimg.cn/cc544eeb680b4e19bf57f9cae47ab408.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAaGF0YWtlLjE4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>两条，分别对应境外和境内</p>
</li>
</ol>
<p>现在分别访问<a href="https://liu-hx.github.io/">https://liu-hx.github.io/</a> 和 <a href="https://xpt.hatake18.top/">https://xpt.hatake18.top/</a>应该都可以访问你的网站了，cdn的缘故，第二个可能更新的较慢，需要自己设置</p>
]]></content>
  </entry>
</search>
